<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://timpcfan.site/rss.xml" rel="self" type="application/rss+xml"/>
    <title>TrystanLei</title>
    <link>https://timpcfan.site/</link>
    <description>积累点滴，汇聚成溪。</description>
    <language>zh-CN</language>
    <pubDate>Wed, 09 Nov 2022 01:22:37 GMT</pubDate>
    <lastBuildDate>Wed, 09 Nov 2022 01:22:37 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>随笔</category>
    <category>转载</category>
    <category>健康</category>
    <category>笔记</category>
    <category>基础</category>
    <category>前端</category>
    <category>API</category>
    <item>
      <title>2022/11/06 - 如何在一周之内完成毕业论文？</title>
      <link>https://timpcfan.site/note/2022-11-06.html</link>
      <guid>https://timpcfan.site/note/2022-11-06.html</guid>
      <source url="https://timpcfan.site/rss.xml">2022/11/06 - 如何在一周之内完成毕业论文？</source>
      <category>随笔</category>
      <pubDate>Sun, 06 Nov 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>不可能。</p>
]]></content:encoded>
    </item>
    <item>
      <title>人体系统调优不完全指南</title>
      <link>https://timpcfan.site/life/health/human-system-optimization.html</link>
      <guid>https://timpcfan.site/life/health/human-system-optimization.html</guid>
      <source url="https://timpcfan.site/rss.xml">人体系统调优不完全指南</source>
      <category>转载</category>
      <category>健康</category>
      <pubDate>Sun, 02 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>本文为转载文章，原文链接：<a href="https://github.com/zijie0/HumanSystemOptimization" target="_blank" rel="noopener noreferrer">https://github.com/zijie0/HumanSystemOptimization</a>。</p>
<p>本文为<a href="https://www.zhihu.com/people/zijie0" target="_blank" rel="noopener noreferrer">字节</a>大佬根据 <a href="https://hubermanlab.com/" target="_blank" rel="noopener noreferrer">Andrew Huberman 教授的 Podcast</a> 整理的比较系统的科学养生指南。之所以说是「科学养生」是因为相较于互联网上广泛传播的各种没有根据的养生知识，这里收集的都是科学界普遍认可的科学研究成果，并且给出了很多我们可以直接应用的实操建议。阅读这篇文章给我的感受，也跟字节大佬所说的一样，就是仿佛打开了新世界的大门。由于我本人身体素质较差，对自己的健康状态是非常关心的，现在有了一个具有科学依据的而且简单易操作的手册，让我对自己的健康状态的调整更加有信心。这篇文章将诸多科学研究中复杂的论文以及实验，使用大众能够接受的语言和文字进行总结归纳，极大地降低了科学养生的门槛。总之，很感谢大佬们对知识的整理归纳，推荐所有人都来看看这篇文章，有能力的去给大佬在github上点个star吧。</p>
</div>
<div><p>注意</p>
<p>本文信息量非常大，推荐一部分一部分地学习。</p>
</div>
<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li></li>
<li></li>
<li>
<ul>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li>
<ul>
<li></li>
<li>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
</li>
<li></li>
</ul>
</li>
<li></li>
</ul>
<h2 id="背景" tabindex="-1"> 背景</h2>
<p>去年 5 月曾经写了一篇文章介绍了下 <a href="https://zhuanlan.zhihu.com/p/371254789" target="_blank" rel="noopener noreferrer">Lex Fridman 大佬的日常生活安排</a>，后续我也根据他的方法对自己的日常生活做了一系列规范和改进。这一年整体实行下来，效果还是非常显著的，本文的最后会对我的一些实践以及借助的工具做一些分享。</p>
<p>最近几个月，偶然在油管上看到了个 <a href="https://youtu.be/2ekdc6jCu2E" target="_blank" rel="noopener noreferrer">Rich Roll 采访 Andrew Huberman 的 podcast</a>，介绍了如何提升我们日常工作，学习表现的相关神经科学原理与可以利用的“工具”，瞬间打开了一扇新世界的大门。后续又一连追了好几集 Huberman 自己的 podcast，从各个方面了解了一下跟我们日常生活，健康，学习，工作，锻炼等方面相关的知识。与其它很多讲“养生”的文章和视频最大的区别在于，Huberman 本身是斯坦福的神经科学教授，其中讲述的内容都是<strong>来自于高质量，peer reviewed 的科学研究成果</strong>，从机体工作原理出发，非常细致地介绍了相关的实验和结论，并给出了很多实操建议（很多都是零成本，不是搞推销的……）。</p>
<p>通过一系列的学习，逐渐有种学习了各种人类的“组成和操作原理”的感觉。通过一系列的工具和实践，我们也可以<strong>像调优软件程序那样来“调优”我们自身的人体系统</strong>。这篇文章就来介绍一些相关的知识内容。注意，原版的 podcast 中有非常多专业性的阐述，在这篇文章中基本都去掉了，尽量以故事性的描述来讲解，相对会比较好理解。当然准确性也会因此有所下降，如果希望获取更专业的内容，强烈建议观看 <a href="https://hubermanlab.com/" target="_blank" rel="noopener noreferrer">原版的 podcast 内容</a>。</p>
<h2 id="睡眠" tabindex="-1"> 睡眠</h2>
<p>如果你想要获得健康，更好的工作学习状态，提升生理健康如免疫，新陈代谢，以及心理健康如更好的心情，专注能力等，最最重要的前提是拥有一个良好的睡眠。</p>
<h3 id="原理" tabindex="-1"> 原理</h3>
<p>睡眠最重要的控制机理是我们内在的生物钟。随着生物钟的影响，我们体内的各类化学物质会发生变化，体温也随之改变，会影响我们的各种内在状态和外在行为。Huberman 教授很形象地描述了这个“生物钟”的具体作用方式：在早上，身体释放的皮质醇（cortisol）和肾上腺素（aderenaline）会让我们醒来，同时还会设定松果体释放褪黑素的倒计时钟，会在十多个小时之后让我们感到困意再次入睡。</p>
<p>影响这个生物钟的最大因素是光照。我们的眼睛除了能够看到东西，另外一个重大的作用就是<strong>通过黑视素神经节细胞来接收光照信息，用以设定我们的内在生物钟</strong>。这也是为什么有时候我们通宵工作之后，虽然已经持续很久时间没有睡眠了，但随着太阳升起，整体的生物钟被设定到了类似起床时的状态，各类化学物质的释放会让我们突然感觉又有精神了。后续很多最佳实践里也都跟这个原理相关，我们需要控制自己接收光照的时间点，类型和时长。</p>
<p>此外，<strong>体温也是一个用于控制我们生物钟的手段</strong>。一般来说我们的体温会从深睡眠中比较低的状态逐渐升高，到醒来后持续上升。到了一天的后半段会开始逐渐下降，直到再次进入睡眠。</p>
<h3 id="实践" tabindex="-1"> 实践</h3>
<p>基于上面的原理，Huberman 教授提供了一系列提升睡眠的最佳实践：</p>
<ul>
<li>皮质醇的释放与接触阳光有关，因此如果想尽快醒来且保持日间良好的精神状态，<strong>起床后应该到外面去接触阳光，持续 2-10 分钟</strong>。这对于血压控制，心理状态，设定睡眠的“倒计时钟”等都有很大好处。户外日光的效果最好，如果是人造光源，蓝光的效果会比较好，且最好是上部（天空的位置）的光源。根据光照强度推算，隔着窗户接收日光的强度会降低 50%以上，而达到同样效果所需要的光照时间则需要 50 到 100 倍。有意思的是，这一点对于视障人士也有效，因为前面提到的黑视素神经节细胞并不是用于视觉成像的细胞。</li>
<li>对应的，<strong>在晚上要尽量减少光源的接触</strong>，因为这会扰乱我们的生物钟，让身体系统误以为是在白天。尤其是晚上 11 点到次日凌晨 4 点之间接收光源，会抑制后续几天的多巴胺的释放，影响心情，心理健康，专注度，学习能力，新陈代谢等等。关于多巴胺的作用和机理，后面会再单独介绍。</li>
<li>如果不可避免需要在晚上接触光源，处于较低位置，暗淡的红光，蜡烛之类的会相对好一些。如果要看电脑，建议使用 blue blockers 眼镜，这跟一些电脑软件会自动调节屏幕色温的效果可能类似。</li>
<li>傍晚观察落日，对于后续入睡也有帮助，甚至能减轻晚上摄入光照的负面影响，有点神奇。</li>
<li>人一天中的精神状态一般会在中间有个短暂的低谷，所以午睡对于有些人可能是有帮助的。也可以用一些其它的非睡眠深度休息的方式来替代，如 <a href="https://youtu.be/M0u9GST_j3s" target="_blank" rel="noopener noreferrer">Yoga Nidra</a>，<a href="https://www.headspace.com/" target="_blank" rel="noopener noreferrer">冥想</a>，<a href="https://www.youtube.com/c/MichaelSealey" target="_blank" rel="noopener noreferrer">自我催眠</a>（可以利用一些 App，如 Reveri）等。</li>
<li>体温对生物钟周期的影响：
<ul>
<li>早上洗冷水澡，会让人快速升温，从而把睡眠周期往前移（早起）。</li>
<li>晚上锻炼身体，会让人保持高体温，从而延后周期（晚睡）。</li>
<li>可以选购一些自动控制体温的智能床垫来提升睡眠质量。</li>
</ul>
</li>
<li>一般建议的锻炼时间：醒来后 30 分钟，3 小时和 11 小时这三个时间点。不过总体来看好像影响度比较小。</li>
<li>饮食和药物因素：
<ul>
<li>咖啡因会占据腺苷（adenosine）的受体，阻断入睡的信号。有不少文章都提到中午之后尽量不要喝咖啡，但 Huberman 表示没有科学实验表明咖啡因对所有人的效果是一样的，得根据自己的测试情况来。比如他自己在下午 5 点喝咖啡也能正常入睡。</li>
<li>镁，对入睡有帮助。</li>
<li>芹黄素也能帮助入睡，但要注意对雌性激素的影响。</li>
<li>建议不要摄入太多牛磺酸。</li>
<li>不建议通过摄入褪黑素来帮助入睡，褪黑素药物本身的规格把控不严格，且褪黑素容易引起抑郁情绪。</li>
<li>中午可以吃低卡路里以及含酪氨酸的食物，如坚果，大豆，部分蔬菜等，提升多巴胺，肾上腺素，保持清醒。</li>
<li>晚上则可以吃点淀粉，白肉等富含色氨酸的食物，进而转化为血清素，会让人更加平静，容易入睡。</li>
</ul>
</li>
<li>对于绝大多数人，6-8 小时的睡眠时长是比较健康的。</li>
<li>对于各类药物的检索可以参考：<a href="https://examine.com/" target="_blank" rel="noopener noreferrer">examine.com</a>。</li>
</ul>
<h2 id="饮食" tabindex="-1"> 饮食</h2>
<p>在前面 Lex 的分享中，提到了他采取了生酮饮食以及 fasting（禁食）的习惯，这引起了我对于饮食习惯的注意。Huberman 教授正好也有几个 podcast 介绍了 fasting，肠道健康等话题，很有意思。</p>
<h3 id="fasting-的背景" tabindex="-1"> Fasting 的背景</h3>
<p>我们可以把身体跟进食相关的化学状态分成 2 类：</p>
<ol>
<li>吃饱了的状态，也就是血糖含量较高的状态。此时我们身体会更活跃地进行体内细胞的复制与成长。</li>
<li>禁食的状态，也就是血糖含量较低的状态。此时我们的身体会更活跃地进行体内细胞的修复与清理（autophagic）。</li>
</ol>
<p>由于睡眠时我们天然是不吃东西的，所以一般来说睡眠中的一部分时间会使我们处于禁食状态，饮食时间的选择实际上就是在控制上述两个状态的持续时间和平衡关系。比较有意思的是世界上很多民族文化和宗教中，都有一些跟禁食相关的习俗，甚至会持续很多天。</p>
<p>在 2012 年，科学家开始对小白鼠做实验，把他们分成两大组，一组可以在一天中的任何时间吃东西，而另一组只能在固定的 8 小时里吃东西。在大组里再区分小组，给小白鼠吃健康的和不健康的食物。结果发现，只能在 8 小时里吃东西的小白鼠们，即使吃的是不健康的高脂肪食物，他们的健康水平仍然得到了保持甚至提高，相比所有不做限制的组都有明显的提升。</p>
<p>这个研究震动了学术界，后续又有非常多的针对人类，不同性别，不同年龄，不同职业（包括运动员）的各种实验与论文发表，科学家们发现这种<strong>间歇性禁食状态对于身体有非常多的好处</strong>，包括：促进肝脏健康，胆汁酸代谢，炎症自愈，保持体重，提升 brown fat 储备（对健康有益），防止非酒精性脂肪肝，血糖控制，肠道健康等等。如果养成间歇性禁食的习惯 60 天以上，还会让我们的身体倾向于代谢脂肪来供能，控制体重。</p>
<p>因此，Huberman 教授指出，<strong>何时进食，与吃什么东西，其实是同等重要的</strong>。这个研究也让很多学术界的研究人员自己也都养成了 fasting 的习惯，包括 Huberman 自己。</p>
<h3 id="fasting-的实践" tabindex="-1"> Fasting 的实践</h3>
<p>由于长时间的禁食难度较大，所以绝大多数的研究都专注于<strong>间歇性禁食</strong>，也就是 intermittent fasting。简单来说就是跟前面的小白鼠实验一样，在一天的固定时间段来吃东西（跟睡眠周期对齐），而其它时间段都不摄入任何食物的做法。这里简单整理为基础和高阶两个版本：</p>
<ul>
<li>基础：如果想享受 fasting 的基础收益，最简单的执行原则是<strong>起床后至少 1 小时内不要吃东西，同时睡前的 2-3 小时不要吃任何东西</strong>。</li>
<li>高阶：目前研究结果中<strong>最理想的进食窗口是 8 小时</strong>，结合社会习俗等，一般比较合理的时间在 10-18 点或 12-20 点的范围。看起来<strong>不吃早饭并不是什么坏事</strong> 😃</li>
<li>作者特地温馨提醒，如果想通过健身来增肌，建议可以把这个时间窗口往前移，因为早上摄入蛋白质会对肌肉增长有益。而健身的时间可以自由选择。</li>
<li>尽量<strong>保证这个窗口时间的稳定性</strong>，也非常重要。否则就跟频繁倒时差产生的效果差不多，会打不少收益折扣。</li>
<li>如果想尝试高阶 fasting，建议逐渐切换进食习惯，例如每两天缩短 1 小时的进食窗口，逐渐达到理想的 8 小时。</li>
</ul>
<p>值得注意的是，这里说的不吃任何东西，并不是说连水也不能喝。从前面的背景可以看到，是否处于禁食状态，主要依据是血糖水平，因此：</p>
<ul>
<li>喝水，茶，咖啡（不加牛奶）等，并不会中断禁食。但一勺糖的摄入就会中断。</li>
<li>晚饭后想尽快进入禁食状态，可以做一些轻量运动，比如散步等，加快血糖清理。</li>
<li>二甲双胍，黄连素（berberine）等可以直接促进血糖清理。肉桂皮，柠檬汁，也能轻微降低血糖。</li>
</ul>
<p>最后，如果禁食期间觉得有些头晕，颤抖，并不需要立刻进食或摄入糖分。可以喝一点盐水（可以加柠檬汁），一般就能很好的缓解症状。这让我想起 Lex 会提到了会服用药片来补充各种电解质元素，比如钠，镁，钾等。</p>
<h3 id="饮食与消化道健康" tabindex="-1"> 饮食与消化道健康</h3>
<p>由于我个人的肠胃功能比较差，所以也特别关注了一下消化道健康的话题。Huberman 邀请了一位非常知名的微生物学家 Sonnenburg 来介绍肠胃微生物群落与我们的健康之间的关系，也是学到了很多新的知识：</p>
<ul>
<li>肠道的微生物群不仅影响消化系统的健康运作，<strong>对人体的免疫系统也起到了非常关键的因素</strong>。</li>
<li>婴儿出生，成长的方式会形成非常不同的肠道菌群生态。暴露在微生物环境中（但要注意会引起疾病的情况），对于维持菌群环境是有益的，比如家里养宠物，让孩子自由玩耍等，不需要过度清洁与消毒。</li>
<li>什么是健康的肠道菌群生态，目前没有一个标准的结论。不过总体来看，<strong>菌群的多样性程度高，一般就表示更加健康</strong>。</li>
<li>抗生素会严重破坏肠道菌群生态，需要谨慎使用。</li>
</ul>
<p>在访谈中，两位重点讨论了一个实验，就是什么样的饮食方式会让我们更好的维持肠道菌群的多样性和健康。实验主要对比了两种附加饮食：</p>
<ul>
<li>高纤维食物：全谷类，豆类，蔬菜，坚果。这也是传统上被认为非常健康的食物，其中很多纤维的分解都需要肠道菌群的帮助，换句话说，纤维就是它们的“食物”。</li>
<li>发酵类食物：酸奶，牛奶酒（kefir），康普茶，酸菜，泡菜，纳豆等。注意需要是自然发酵，一般是冷藏且非罐装的食品。而且像酸奶这类要格外注意不要加糖等添加剂。</li>
</ul>
<p>实验的结果也颇令人意外：</p>
<ul>
<li>摄入发酵类食品的组，显著提升了肠道菌群的多样性。被试者<strong>几十个免疫标志物的显著降低，对各类炎症都有更好的抑制作用</strong>。没想到吧，肠道菌群还能调节炎症。</li>
<li>肠道菌群本来的多样化程度比较高的人，摄入高纤维食物是有帮助的。如果不是，则摄入高纤维食物的帮助不大。在工业化进程中，人类的进食习惯已经有很多代都转变为了摄入大量肉类，加工食品等，肠道菌群的生态无法仅通过提高纤维食物的量来改变其族群结构。</li>
</ul>
<p>此外在访谈中，两位还讨论了具体食谱推荐的问题，引用了 <a href="https://youtu.be/sJLK3sVexIk" target="_blank" rel="noopener noreferrer">Christopher Gardner 关于生酮饮食与地中海饮食比较的研究</a>。这里总结一下实践建议：</p>
<ul>
<li><strong>如果要改善肠道菌群生态，最好的方式是一天两次摄入天然发酵类食品</strong>。</li>
<li>高纤维食物对于肠道菌群生态的维护是有益的，建议日常饮食以植物类食物为主，尽量避免深度加工食品的摄入，控制糖的摄入。Sonnenburg 教授还讲了个故事，说微生物学家参加的会议，一般餐厅的沙拉吧总是会供不应求 😃 前面提到的 Rich Roll 大佬也是个素食者。</li>
<li><strong>益生菌的效果没有广泛研究支持</strong>，且这类产品的监管很有限。<strong>益生元的效果也是好坏参半</strong>，缺乏多样性，溶解速度太快等问题都使总体效果存疑。</li>
<li>地中海饮食相比生酮饮食来说对健康的影响效果接近，但更容易坚持遵循。另外生酮饮食如果长期实践可能有一定的风险。所以<strong>总体更推荐地中海饮食结构</strong>。</li>
</ul>
<p>另外值得参考的是我们也有官方的 <a href="https://sspai.com/post/72984" target="_blank" rel="noopener noreferrer">中国居民膳食指南</a>，或许更适合东方人的饮食习惯。</p>
<h2 id="心态与动力" tabindex="-1"> 心态与动力</h2>
<p>这一部分主要介绍的是人体的多巴胺系统原理，以及如何利用它来形成健康，自律的生活方式。这一集是 Huberman 开播以来播放量最高的一集，对于强健我们的心智有着非常好的指导作用。</p>
<h3 id="原理-1" tabindex="-1"> 原理</h3>
<p>多巴胺是一种非常重要的化学物质，主要作用于两个神经回路：一个影响身体的运动，例如帕金森病与多巴胺的分泌不足有关；另一个则影响我们的动机，欲望与快乐，这几乎与我们从事的各种活动有关，无论是工作，学习还是社交，休闲娱乐。这里我们会主要讨论多巴胺的后者影响能力。我们为什么会“放弃”，实际上是由于在不安，压力，沮丧等情绪作用下，身体内的去甲肾上腺素水平不断提升，当超过一定阈值时，神经系统中的认知控制就会关闭，我们就放弃了。多巴胺能够抑制去甲肾上腺素作用，从而持续“激励”我们前行。</p>
<p>神经系统中多巴胺含量水平的高低会影响我们的情绪，当多巴胺水平低时，我们会感到情绪低落，没有动力，而多巴胺水平高时，我们会感到兴奋和快乐。在通常情况下，我们的身体处于多巴胺 baseline 的状态，当我们达成一些令人兴奋的目标（比如玩游戏胜利，考试拿高分）后，多巴胺的水平会达到一个高峰，此时我们就会获得巨大的愉悦感。在高峰之后，多巴胺水平会回落到比 baseline 更低的一个水平，且这个状态会持续一段时间。</p>
<p>这里有两个非常重要的原理：</p>
<ul>
<li>多巴胺绝对值含量的高低只是一方面，<strong>更重要的是其“相对变化量”的多少</strong>。比如在刷抖音时看到了一个很有趣的视频，多巴胺水平升高，你会感到快乐，刷到下一个视频时，你感到的快乐程度好像不会那么强烈了，因为多巴胺已经在一个比较高的水平，难以形成更大的变化量。而同样的视频，如果你是几天之后看到，或许你会觉得有意思的多。所以<strong>当你持续做一件喜欢的事情时，你感受到快乐的阈值也会不断提高</strong>。</li>
<li><strong>多巴胺的总体“储备”是有限的</strong>！也就是说无论你是通过学习，工作，娱乐，社交，运动等不同方式来获得快乐，所消耗的“快乐货币”都是同一种：多巴胺。举几个例子来看下这个原理带来的影响：
<ul>
<li>很多自律的人都会说自己是 work hard，play hard 的生活方式，比如工作日通过高强度的工作来获得成就和满足感，休息日进行各种休闲娱乐，运动，社交等方式来获得快乐，其实背后都是在释放多巴胺来获取快乐。长期持续，我们身体的多巴胺 baseline 会逐渐下降，出现一种耗尽（burn out）的心理感觉，对很多事物无法保持之前的兴趣与精力。</li>
<li>很多人会对玩电子游戏着迷，因为它们能带来巨大的多巴胺释放刺激让人感到快乐。但要意识到，多巴胺的储备是有限的，如果对此上瘾，你的多巴胺耗尽问题就会变得非常严重：一方面能够引起你兴趣的事物会变少，可能只有玩游戏才能带来快乐；另一方面，后续甚至会导致玩游戏本身也无法触发多巴胺释放，引起严重的抑郁问题。</li>
</ul>
</li>
</ul>
<p>另外，<strong>多巴胺也具有叠加效应</strong>。比如你喜欢健身，那么运动就会刺激多巴胺的释放。而我们实际去健身时，可能会不自觉地安排了很多其它的“快乐因素”，比如选一个精神状态比较好的日子，运动前喝一些能量饮料，跟认识的朋友一起去，边健身边 social，听一些自己喜欢的音乐或 podcast，等等。这些因素也都会促进多巴胺的释放，让你感到“前所未有的快乐”。但要注意前面的原理，多巴胺的高峰越高，后面随之而来持续的低谷也会越长，而且长此以往，可能会降低你单纯从运动中获取快乐的能力。这样的例子还有很多，比如边跟朋友吃饭，边玩手机，拍照发朋友圈，可以计算一下叠加了几种快乐因素 😃</p>
<h3 id="影响多巴胺的外界因素" tabindex="-1"> 影响多巴胺的外界因素</h3>
<p>我们来看下具体影响多巴胺释放的各类因素有哪些，首先是促进多巴胺分泌的：</p>
<ul>
<li>巧克力，提升到 1.5 倍的多巴胺 baseline</li>
<li>性行为，提升到 2 倍</li>
<li>尼古丁，提升到 2.5 倍</li>
<li>可卡因，提升到 2.5 倍</li>
<li>安非他命，提升到 10 倍</li>
<li>咖啡因本身只会少量提升多巴胺，但它会抑制一些多巴胺受体，提升同等多巴胺造成感受的效果</li>
<li>马黛茶，包含咖啡因，能控制血糖，还能保护多巴胺神经元</li>
<li>刺蒺藜豆也能提升多巴胺（基本等同于 L-DOPA），还能提升男性精子数量和质量</li>
<li>运动，带有主观成分，喜欢跑步的人，可以提升到 2 倍 baseline</li>
<li>健康的社交关系也会促进多巴胺释放</li>
</ul>
<p>食物方面感觉 Huberman 教授<strong>非常推荐马黛茶</strong>。</p>
<p>也有很多提升多巴胺释放或影响其效果的药物：</p>
<ul>
<li>L-Tyrosine（酪氨酸），提升多巴胺</li>
<li>Phenethylamine（PEA），巧克力中也包含，能够提升多巴胺</li>
<li>Huperzine A，提升多巴胺</li>
<li>各种“聪明药”，如 Adderall, Modafinil, Alpha-GPC, Ginkgo 等，留学党应该很多都有耳闻</li>
</ul>
<p>通常来说，<strong>不推荐持续使用这些药物</strong>，因为多巴胺释放之后的高峰会带来 baseline 水平的降低，导致无法享受活动的快乐，无法专注，限制学习能力和神经元可塑性等。Huberman 表示<strong>一周使用一次的频率应该是安全的</strong>。</p>
<p>最后还有一个比较特别的研究，就是<strong>冷水浴能够提升多巴胺释放到 baseline 的 2.5 倍左右</strong>，且持续时间更长，能达到 3 小时左右。建议使用 10-14 摄氏度的水温，注意安全。此外冷水浴也不需要太频繁，每周 11 分钟左右足够。如果已经习惯了冷水浴，那么也就没有释放多巴胺的效果了。</p>
<p>还有一些因素会降低多巴胺，如：</p>
<ul>
<li><strong>褪黑素，会引起多巴胺的减少</strong>。前面也提到过并不建议使用褪黑素来帮助入睡，或者适应时差等。</li>
<li>睡眠时段接触光源，也会引起接下来几天的多巴胺水平下降。<strong>半夜睡不着刷手机是很有害的哦</strong>。</li>
</ul>
<h3 id="维持健康的多巴胺水平" tabindex="-1"> 维持健康的多巴胺水平</h3>
<p>了解了原理和各种影响因素后，我们来看下如何有效设计我们的生活工作方式来维持健康，可持续的多巴胺水平。</p>
<p>简单回顾一下，前面我们已经知道了多巴胺储备有限，且对一件事物上瘾会不断提高感受快乐的阈值，那么如何让我们能对一件事情保持长时间的兴趣和投入度，又不至于耗尽多巴胺呢？一个经典的例子是赌场的运作方式，我们并不是每一次下注都能赢，偶尔赢一次会释放多巴胺，而且根据赢得钱的多少有所上下浮动，这会吸引玩家持续参与。这就是一种非常有效的<strong>间歇性且随机的奖励机制</strong>。感觉很多游戏，社交网络产品也借鉴了这个思路来进行设计。</p>
<p>对于我们经常需要从事的活动，我们也可以模拟这个机制。还记得前面提到的<strong>多巴胺叠加效应</strong>吗？我们可以<strong>通过随机化叠加因素的多少，来实现多巴胺释放的差异性</strong>。还是以健身为例，我们可以随机决定今天是否要听音乐，是否去健身时带手机，是否要在健身前喝能量饮料等因素。如果其它什么都不做，只是单纯健身，那么多巴胺的释放量就会相对较低。如此就能模拟多巴胺释放有高有低的随机奖励机制。</p>
<h3 id="成长型思维" tabindex="-1"> 成长型思维</h3>
<p>最后来看下如何构建良好的思维方式来利用多巴胺系统提升自我。</p>
<p>有一个非常知名的实验，挑选了一群天生喜爱画画的小朋友，在他们完成画作后给与一些奖励。后面在移除这些奖励后，小朋友们对于画画的兴趣和动力大大降低了。这个实验说明，当我们因为一个活动收到奖励（比如金钱，美食等）时，我们<strong>反而会降低活动本身的愉悦程度</strong>。而且多巴胺本身影响我们对时间的认知，同时也影响我们的情绪状态，如果我们<strong>始终以完成活动后的奖励为目标，则整个过程中就很少释放多巴胺，让原本困难的过程变得更加难以坚持</strong>。</p>
<p>仔细想一下，这是一个非常有意思的观察。多巴胺有点像我们的“本能系统”，决定了我们是否有动力做一件事。但反过来<strong>我们的主观思想却可以影响这个系统起作用的方式</strong>，这也是人类为何能摆脱动物本能，达成很多需要“反人性”的投入才能取得的成就的原因吧。上述的实验是我们的主观思想造成的一个反面作用的例子，我们自然也可以实现正面作用，那就是成长型思维。</p>
<p>具体来说，就是<strong>通过自我暗示，把努力过程本身当作一种“奖励”</strong>。我在努力学习，这个过程本身就是有趣的，会让我不断变得更强，这样的想法会在过程中激发身体系统释放多巴胺，而多巴胺提升了我们的情绪和动力水平，也会让努力的过程中碰到的困难变得相对容易克服。专注于这个过程的本身，而不是在过程前进行各种外界刺激（如前面提到的药物），或者在过程后给自己巨大的奖励。</p>
<p>这种思维方式看起来很主观，但这就是我们的神经系统工作的方式，虽然人类的“硬件系统”都差不多，但知识，思维这些运行之上的“软件”却可以千差万别。<strong>我们可以通过自律，自我暗示来改变自身对各类活动的喜好</strong>。例如通过暗示 fasting 对我们健康的益处，来获取满足感，而不是借助于 fasting 结束后的大快朵颐。通过自律抵御高油盐食物的吸引力，并且自我暗示植物类食物对身体的好处，坚持一段时间，会觉得花椰菜也挺美味的。这也是为什么我们在这篇文章中介绍了很多原理性的内容，而不仅仅是行为建议。因为这些原理知识能够让我们做更好的自我暗示 😃</p>
<p>多巴胺系统中也有对我们认知成长造成“障碍”的运作机理。例如当我们接受到的信息支撑我们之前的信念时，也能够激发多巴胺的释放让我们感到快乐，这从本质上会改变我们对世界的认知。由此可见，“空杯心态”是多么难得的品质，网上如此多的争论无法达成共识也有很大一部分“归功”于此。如何克服神经系统中的这类缺陷呢？一种可能的方法是尽可能调节情绪，使自己处于镇静的状态（提升血清素水平），这样才能让自己更好的去倾听和吸收跟自己认知不一致的信息，更好地协同合作。</p>
<p>这一节的 podcast 对我本人的冲击非常大，强烈建议大家观看这期 <a href="https://hubermanlab.com/controlling-your-dopamine-for-motivation-focus-and-satisfaction/" target="_blank" rel="noopener noreferrer">Mindset &amp; Drive</a>，相信也会有不同的收获。</p>
<h2 id="学习与专注" tabindex="-1"> 学习与专注</h2>
<p>在了解了多巴胺的运作机制基础上，我们可以继续探究一些跟大脑健康，专注度，如何进行高效学习相关的话题。</p>
<h3 id="学习的原理" tabindex="-1"> 学习的原理</h3>
<p>从脑神经科学来看，学习的本质是神经元的重新连接（rewire），进一步来看，需要大脑处在一种学习的化学状态下，也就是 Huberman 经常提到的神经可塑性（neuroplasticity）状态。要达到这个神经可塑性状态，有两个重要条件，一个是足够的专注度，另外一个是“犯错”的信号（后面会展开）。另外大脑一个比较有意思的机制是，在学习时的神经可塑状态下，乙酰胆碱会标记需要改变的神经元，而具体的神经元重连接则主要是在休息和睡眠时发生，是不是有点像 JVM 虚拟机的垃圾回收机制 😃</p>
<p>什么是犯错信号呢？当我们尝试做一些事情，但没有达到预期目标时，身体会给大脑发信号，“我犯错了”。处在这种犯错，沮丧的认知状态下，神经系统会释放肾上腺素（提升 alertness），乙酰胆碱（提升 focus），多巴胺（促进神经元的 change，rewire）等化学物质，激活神经元的可塑性。也就是说，<strong>犯错是我们进入学习状态的重要前提</strong>。搞机器学习的同学应该很熟悉了吧，这跟我们训练模型不是一模一样么 😃 另外很多人可能觉得心流（flow）状态是学习的最佳状态，而 Huberman 则不这么认为。<strong>心流是一种精神高度集中且接近于自动化的状态，是在做我们已经知道怎么做的事情，而不是在学习新的知识技能</strong>。</p>
<p>对于这个学习状态，经典的实验是给人们戴上一些能转变角度的眼镜，然后执行一些类似物体抓取的任务。由于看到的东西通过眼镜改变了其本来的位置，一开始在尝试时总会出现抓取动作的偏离。但后续在进入神经可塑性状态后，我们能逐渐适应相关的视觉偏移，协调自己的听觉，动作等都与之协同，顺利完成任务。更有意思的是，<strong>这个“神经可塑性”的化学状态是可以持续的</strong>，我们甚至可以先通过一些其它操作触发大脑的这个机制，再去进行真正的学习，以加快学习的速度。这里还有一个隐藏逻辑，当你在遇到挫折困难时，大脑进入了可塑性状态，而此时你却放弃了，那么<strong>神经元也会重新连接到这种容易放弃的行为模式，形成恶性循环</strong>。</p>
<p>人在年幼时期大脑天然的神经可塑性会比较好，而在 25 岁以后则会大大下降。我们后面会提到如何来进行克服。</p>
<p>另外，<strong>休息和睡眠时也会发生大量的神经元重连接的活动</strong>，这也是之前我们就提到过的，高质量的睡眠是实现很多生理，心理健康强壮的先决条件。</p>
<h3 id="利用神经可塑性" tabindex="-1"> 利用神经可塑性</h3>
<p>如果正在阅读文章的你还未满 25 岁，那么恭喜你，你的神经可塑性仍然非常的好，可以<strong>尽可能广泛的学习各种知识和技能</strong>。比如你可以很快学会各种乐器，新的语言，新的运动，新的专业技能等等。通过更广阔领域的体验接触，尽量找到你最有兴趣的方向，可以后续再不断深入经营。</p>
<p>如果已经像我一样超过了 25 岁，那么还有很多办法来提升神经可塑性：</p>
<ul>
<li>通过实验发现，<strong>成年人对于小幅度的增量学习是完全可以适应与掌握的</strong>。例如每次视觉上的偏差只有 7 度，而不是一下子就来个 180 的大颠倒，那么成年人也能很快从错误中学习纠正。应用到实际学习中，我们每次学习的内容可以控制一下不要太多（本文有点违反了，建议收藏慢慢学习），多次积累来完成神经系统的调整学习。</li>
<li>对于达成目标的渴求度越高，重要性越大，奖励的刺激越大（比如为了生存），则神经可塑性就会越容易出现。这个比较符合直觉，但是现实中可操作性可能不高。</li>
<li>第三点最有意思，<strong>通过扰乱前庭神经系统（vestibular system），能够达到神经元可塑性的状态</strong>。简单来说，就是让你的身体有一些“新颖的重力体验”，如倒立，瑜伽，体操，滑板，任何让身体会失去平衡的一些状态等，会快速激发“我犯错了”的信号，进入学习状态，甚至可以在之后去做别的任务的学习。这一下子就让我想到了<strong>淘宝成立初期的“倒立文化”，没想到还真的有科学依据</strong>。需要注意的是，这个体验必须要新颖，也就是说如果你已经倒立很熟练了，那么去做倒立就是个日常行为，并不会给身体一种在犯错边缘，需要纠正的刺激。</li>
</ul>
<p>Huberman 认为，大脑的主要功能链路是感知，认知，情感，思想，行动。在尝试控制我们的神经系统来进行各种任务时（例如学习，解决困难问题，挑战运动极限），我们是很难用精神思想来控制其本身的（比如不断跟自己说我不能分心），更可行的办法是“逆向链路”，从我们的行动出发，利用神经系统的运作原理，逐渐影响思想，情感，认知甚至感知部分。这也是 Huberman 非常推崇各种“行动工具”的原因。Mood follows action。</p>
<h3 id="学习的理想状态" tabindex="-1"> 学习的理想状态</h3>
<p>除了神经可塑性的化学状态外，我们也需要注意其它的因素。例如我们<strong>不能太放松以至于有些昏昏欲睡，也不能太紧张激动，无法控制自己拥有清晰的思考</strong>等。这些也都跟我们体内的多巴胺，肾上腺素，乙酰胆碱，血清素，褪黑素等化学物质的水平有关，需要做好调节。在之前 Rich Roll 的访谈节目中，Huberman 提了一个非常有效的“呼吸工具”，叫<strong>生理叹息</strong>（Physiological Sigh）。操作方法上简单来说就是吸两口气，然后出一口长气。通常情况下，只要一两次生理叹息就足以使我们的压力和警觉水平迅速下降，让人感到更加平静，提升学习表现。</p>
<p>前面提到的成长型思维也很重要，在遇到错误导致的沮丧感觉时，可以不断增强自我暗示，失败是帮助我们学习成长的唯一路径，对我们是有益的，以此增加多巴胺的释放，提升学习动力和过程中的愉悦感。</p>
<p>联系到睡眠对学习的促进作用，也有一些研究提供了一些相关的 tips：</p>
<ul>
<li>在学习时听一些有规律的节拍，在入睡时也播放同样的微弱节拍，能够提升学习和记忆的效果。</li>
<li>一般在 90 分钟的学习后（人体生物钟的周期），可以选择进行 20 分钟的休息（non sleep deep rest），也会加强学习的效果。</li>
<li>Gap effect，在学习中随机停止 10 秒钟，这些停止会在睡眠中加速“播放”，提升学习效果。</li>
</ul>
<h3 id="提升专注" tabindex="-1"> 提升专注</h3>
<p>“专注”背后的机理是大脑中两种“网络模式”的协调，一种叫 Default network，在我们不做任何事情时被激活，另一种叫 Task networks，在我们专注于做某些事情时被激活。普通人的大脑能够很好地协调这两个模式，两者像跷跷板一样，当一种模式被激活时另一种模式会被抑制。而具有专注障碍（比如多动症）的人来说，这两者无法很好地进行协调，因此会出现无法专注的现象。</p>
<p>通过提升多巴胺水平，可以有效促进这两种网络模式的协调，因此有非常多的多动症治疗药物都跟提升多巴胺有关，例如 <strong>Adderall，Modafinil</strong> 等。一些调查表明，这些药物（经常被称为聪明药，nootropics）在美国被滥用的程度甚至超过了大麻，不少“学霸”都以此来提升注意力，减少对睡眠的需求。但 Huberman 教授表示，一方面多巴胺的刺激提升后都会带来多巴胺水平的低谷，另一方面这些药物也可能导致上瘾，对新陈代谢作用造成扰动，有很多负面影响，<strong>对长期的学习与记忆效果可能并没有提升作用</strong>。在之前介绍多巴胺的章节也有提到，应该谨慎使用这类药物，并严格控制使用频率不能过高。</p>
<p>最好的提升专注的方法当然是前面聊过的更好的控制我们的多巴胺系统，例如把行动跟背后的意义相连接，给自己正面的心理暗示；将任务拆成多个小的里程碑，通过过程自身的激励来促进多巴胺的释放提升我们的专注度。此外一些安全有效的提升专注力的方法包括：</p>
<ul>
<li>适量补充 <strong>Omega-3 EPA 鱼油</strong>，这是神经细胞的组成原料之一，能够有效减轻抑郁，对治疗多动症（ADHD）也有帮助。</li>
<li><strong>通过身体其它部分释放运动，可以帮助提升注意力</strong>。教授举的例子是作为神经科医生在开刀时，如果采用半蹲半站的姿态（运动释放），拿手术刀的手更稳定不容易颤抖。这让我想起以前读书时很多同学习惯转笔，现在工作了也有不少人喜欢玩指尖陀螺，或者站立办公，可能都是类似效果。</li>
<li><strong>限制视野范围，能够提升专注度</strong>。比如我们经常因为眼睛瞟到了任务栏上的消息提示闪动而分心，可以通过一些设置来进入“专注模式”。</li>
<li>视线的高低也会影响神经状态，<strong>视线往下看会让神经系统偏向镇静，放松，甚至困倦，而视线向上则会让系统提升警惕</strong>。工作时一般至少把显示器放置在鼻子位置之上。</li>
<li>大脑不擅长处理大量频繁的 context switch，典型的比如刷抖音，不同的信息以非常快的速度频繁切换，这对我们的注意力是有伤害作用的。2014 年的一项研究表示，<strong>我们每天在手机上花费的时间应该少于 60 分钟（青少年）/120 分钟（成年）</strong>，以免引起注意力障碍问题。</li>
<li>还有研究表明，<strong>17 分钟的冥想，能够对大脑中的神经元做重新连接，永久地改善注意力</strong>。只要做一次就可以，完全可以尝试一下。</li>
</ul>
<h3 id="大脑健康" tabindex="-1"> 大脑健康</h3>
<p>最后来看下提升大脑健康和效能的一些方法。</p>
<p>首先是前面提到过的，保证高质量的睡眠。</p>
<p>运动方面，<strong>对大脑直接帮助最大的是有氧运动</strong>，提升心肺功能，支持大脑供能。建议每周 150-180 分钟的有氧训练。</p>
<p>对于大脑健康有帮助的食物，其中前三点是比较重要的，后面的部分涉及的研究没有那么多：</p>
<ul>
<li><strong>Omega3, 尤其是 EPA 等脂肪酸</strong>，是大脑组成的重要部分，且一般人都容易摄入不足。多吃鱼，牡蛎，鱼子酱，奇亚籽，核桃，大豆。一天至少摄入 1.5 克，理想情况需要 3 克以上。不喜欢吃鱼的话可以辅助摄入鱼油。</li>
<li><strong>磷脂酰丝氨酸</strong>，也对认知能力有帮助。通过鱼，肉类，卷心菜来摄入。</li>
<li><strong>乙酰胆碱</strong>，重要的神经调质，提升注意力。摄入胆碱的重要来源是鸡蛋，尤其是蛋黄。土豆，坚果，水果中也含有，虽然没有蛋黄中的含量那么丰富。可以通过 Alpha-GPC 等补充剂来获取。</li>
<li>肌酸，尤其对于不吃肉的人，一天需要摄入 5 克左右。</li>
<li>花青素，在蓝莓，黑莓，葡萄等食物中有提供。可以降低 DNA 损伤，缓解认知下降等问题。大约每天需要 60-120 克蓝莓的补充。</li>
<li>谷氨酰胺，可以通过牛肉，鸡肉，鱼肉，鸡蛋，大豆，卷心菜，菠菜，芹菜等食物来摄取。提升大脑在缺氧（高海拔地区）下的表现，还能够抑制对糖的需求。</li>
<li>水，钠，钾，镁等电解质是神经元信号传递所需的基础元素，需要保证。</li>
</ul>
<p>这一节中还讨论了我们身体对各种食物喜好进行判断的三个渠道，前两个分别是味觉判断和营养成分的下意识判断。第三个比较有意思，也跟多巴胺有关，即我们可以<strong>通过提升大脑代谢的活跃度来增加对某种食物的喜好</strong>。比如你如果不喜欢吃鱼，一种方法是你可以把鱼跟你平时爱吃的食物一起吃，另一种是给自己足够的心理暗示，说服自己吃鱼是有益身体健康的。通过这两种办法，你都可以让大脑释放多巴胺，从而逐渐提升对鱼类食物的喜好程度。</p>
<p>最后，如果你对膳食补充剂感兴趣，还可以看看 <a href="https://www.thorne.com/u/huberman" target="_blank" rel="noopener noreferrer">Huberman 教授平时会吃的补充剂有哪些</a>。</p>
<h2 id="长寿" tabindex="-1"> 长寿</h2>
<p>最后我们来看下如何延年益寿，这是 Huberman 跟这个领域的专家，来自哈佛的 David Sinclair 的一集访谈节目。</p>
<h3 id="衰老的本质" tabindex="-1"> 衰老的本质</h3>
<p>Sinclair 认为，衰老是一种疾病，它本身导致了非常多通常意义上的疾病的出现，比如阿尔兹海默症，癌症等。我们可以通过科学的手段来“治疗”衰老，甚至逆转它。</p>
<p>从本质上来说，衰老是<strong>基因信息的损失</strong>，这分为两部分：</p>
<ul>
<li>DNA 本身的信息，比如细胞中的 DNA 结构会在辐射等情况下受到破坏。</li>
<li>控制哪些基因进行表达的信息受到了破坏，也就是所谓的表观基因组（epigenome）。这部分在衰老的因素中占了 80%。</li>
</ul>
<p>人体内有一个天然的“衰老时钟”，而且并不是以匀速走的。在年轻时我们的生长发育过程中，这个时钟走得更快。所以如果青春期发育比较迅速的人，一般来说整体的时钟走的比较快，寿命也会相对短，是不是有点吓人……而且，一般比较矮小的人，像侏儒很少会得心脏病，癌症，也会明显更长寿。不过不要紧张，前面提到了，基因本身的信息只占了衰老因素的 20%，<strong>控制基因表达这部分占了大多数</strong>。</p>
<p>这里有点意外的是 Sinclair 教授介绍的最重要的几个实验，都跟前面我们提到的 fasting 有关。比如一般老鼠的寿命大概是 2 年，他们实验室有一只叫 Yoda 的老鼠，活了足足 5 年。其主要的做法就是选取了侏儒基因，以及执行 fasting。</p>
<p>教授详细介绍了 <strong>fasting 为何能提升动物/人类 30% 以上的寿命</strong>：</p>
<ul>
<li>在低血糖水平时，身体会抑制哺乳动物雷帕霉素靶蛋白（mTOR），激活去乙酰化酶（sirtuin），形成一个非常良好的化学状态，清理旧蛋白质，提高胰岛素敏感度，提供更多能量，修复细胞等等。后面这个乙酰化酶是我们抵御衰老的一个重要武器。</li>
<li>当胰岛素水平低时，“长寿基因”会被激活，如 SIRT1 等。</li>
<li>fasting 会给细胞足够的“休息时间”。</li>
<li>血糖水平低，会让身体对胰岛素更敏感，更快吸收血糖，也对健康有益。</li>
<li>当你从来不感受饥饿时，你的衰老时钟也走的更快。</li>
<li>除了 24 小时周期 fasting 触发的 autophagic，还有更深层次的清理机制，会在禁食第二，三天启动。在老年老鼠上的实验表明，这种长时间的禁食可以让他们延长寿命 35%。不过这个实操难度对普通人来说有点大。</li>
</ul>
<p>Sinclair 也对比了一些上个世纪失败的研究，比如通过抗氧化剂来抵御衰老。现代长寿研究的核心思想是，如何<strong>通过一些机制手段来触发身体自身的衰老抵抗机制</strong>。</p>
<p>此外 Sinclair 也介绍了一些激动人心的前沿技术，例如<strong>通过基因治疗方法，可以重启我们的 DNA 表达系统</strong>。通过一次注射，可以让盲人恢复视力，这已经在老鼠身上得到了验证。或许几年后，我们可以像死侍那样实现身体各部分的逆转老化。</p>
<h3 id="抗衰老手段" tabindex="-1"> 抗衰老手段</h3>
<p>先来总览看一下各种抗衰老的手段。</p>
<h4 id="饮食-1" tabindex="-1"> 饮食</h4>
<p>包括食物结构和饮食控制。饮食控制方面前面有提到过，建议缩短进食窗口到 8 小时左右。饮食结构可以参考最新发表在 Cell 上的这篇文章 <a href="https://www.cell.com/cell/pdf/S0092-8674(22)00398-1.pdf" target="_blank" rel="noopener noreferrer">Nutrition, longevity and disease: From molecular mechanisms to interventions</a>。简单总结一下就是多吃植物类的蛋白（花生，藜麦，豆类，西兰花等），脂肪（橄榄油，坚果，牛油果等），减少精制碳水（白米饭，白面包，蛋糕，饼干等）；动物脂肪，动物蛋白质，糖这些总体来说是加速衰老的。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UWYiCh.jpg" alt="长寿饮食建议" loading="lazy"></p>
<h4 id="体育锻炼" tabindex="-1"> 体育锻炼</h4>
<p>有氧锻炼对心肺功能，血管健康等方面的促进对延寿很有帮助。力量训练也能持续保持我们的肌肉，关节，韧带的力量水平，支撑保护能力等，在年纪大时减少各种跌倒或者受伤的风险。一般建议是一周 3 小时左右的有氧运动，搭配 2 到 3 次的力量训练。有氧运动一般比较简单，跑步，骑车，游泳都可以。力量训练有一定的门槛，个人也最近正在学习一些入门训练方式。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/aRWpBL.jpg" alt="力量训练计划" loading="lazy"></p>
<h4 id="药物" tabindex="-1"> 药物</h4>
<p>药物方面的研究也非常多，不过绝大多数都还在人体实验的早期。具体可以参考发表在 Nature 上的这篇 <a href="https://www.nature.com/articles/s41573-020-0067-7" target="_blank" rel="noopener noreferrer">The quest to slow ageing through drug discovery</a>，总结了各种相关研究，其中就包括了著名的二甲双胍，NMN 等。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/8f6neF.jpg" alt="长寿药物" loading="lazy"></p>
<h4 id="细胞重编程" tabindex="-1"> 细胞重编程</h4>
<p>前面也提到了基因表达是影响衰老最重要的因素，那么有没有手段来控制人体细胞的基因表达呢？著名的山中因子（Yamanaka Factors）给出了一种可能。山中伸弥团队发现的诱导方法是，通过慢病毒载体将 Oct4、Sox2、c-Myc、Klf4 四种转录因子基因转入成体细胞，将其转化为类似于胚胎干细胞的多能干细胞（iPS 细胞）。iPS 细胞与胚胎干细胞拥有相似的再生能力，理论上可以分化为成体的所有器官、组织，而这一点完美地对冲了由细胞衰减带来的人体衰老。听起来是不是非常的神奇？基于这些新技术也出现了很多主攻长寿领域的科技创新公司，如 <a href="https://www.lifebiosciences.com/" target="_blank" rel="noopener noreferrer">Life Biosciences</a>，<a href="https://altoslabs.com/" target="_blank" rel="noopener noreferrer">Altos Labs</a> 等，我们可以期待一下未来这些技术的普及应用。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/rImwzR.jpg" alt="山中因子" loading="lazy"></p>
<h3 id="实践-1" tabindex="-1"> 实践</h3>
<p>这里列出一些 Sinclair 自己的实践方式，如果想要采纳还是要结合自身的情况来看。有意思的是这集节目下有个热门留言是这个教授竟然已经 52 岁了，完全看不出来……所以你懂的。</p>
<ul>
<li>不吃早饭，午饭也吃的比较少，酸奶或者橄榄油，晚饭吃蔬菜为主，加鱼和虾，基本不吃牛排。不吃糖，甜品，面包。基本达到了 2 小时进食窗口的高阶 fasting 状态。他偶尔也会尝试一整天都不吃东西，但比较难坚持。</li>
<li>每天摄入 1 克的白藜芦醇（resveratrol），1 克的 NMN（进而会转化为 NAD，which is sirtuin 的“燃料”），还有二甲双胍（metformin）。其中锻炼的日子可能会跳过一些补充品。他并不吃复合维生素。</li>
<li>以蔬菜为主食的好处：富含各种营养，维生素；包含异种激素（Xenohormesis），植物基于“压力”之下产生的物质，对长寿有益。后者也可以通过槲皮素（quercetin）来做膳食补充。</li>
<li>一般会隔一天进行有氧运动和力量训练。有氧运动能提升 NAD 水平。</li>
<li>根据家族病史来决定一些药物摄入，如他 29 岁就开始服用降胆固醇药物。</li>
<li>对于人造甜味剂，教授认为总体来说是安全的。他偶尔也会喝健怡可乐。</li>
</ul>
<p>对于这一系列实践，Sinclair 教授都进行了 10 多年的自身实验，并使用各种手段来监控身体数据。通过监控数据可以推测出一个人的“生理年龄”如何（不是光看脸），他自己在上述实践下，生理年龄在持续下降，现在已经达到了 30 岁左右的水平（实际年龄 52 岁）。另外，他认为每个人的身体情况不一样，医院约定俗成的生理指标范围也不一定适合每个人。<strong>未来这种健康数据的实时监控与个性化诊断会成为主流</strong>。他举了一些例子：</p>
<ul>
<li>监控血糖水平 HbA1c，观察 fasting 的影响等。</li>
<li>监控炎症指标 CRP，与心脏病等各种疾病的诱发相关。</li>
<li>监控 LDL，通过药物等进行控制。膳食胆固醇对血液胆固醇几乎没有影响，不需要戒红肉，黄油等。</li>
<li>补充铁元素可能加速衰老。医学指标需要个性化，低铁元素含量并不一定导致贫血。</li>
</ul>
<p>还有一些影响寿命的负面因素：</p>
<ul>
<li>肥胖症会加速衰老。</li>
<li>吸烟，会破坏基因表达，加速衰老。</li>
<li>X 光检查同理，没有必要时，避免接触。</li>
</ul>
<p>展望一下 longevity 研究的未来，还是挺激动人心的。现代科学每一年能让我们的平均寿命延长 1/4 年，如果每一年能让我们的平均寿命延长超过 1 年，则达到了<strong>寿命“逃逸速度”</strong>（类比以 1000 英里每小时的速度往西飞行，太阳永远不会落下），实现了“永生”。著名的未来学家 Ray Kurzweil 预测，大约 12 年后（2034 年）就能实现，让我们拭目以待。</p>
<p>除了这集 podcast，也必须附上吴承霖大佬的万星项目 <a href="https://github.com/geekan/HowToLiveLonger" target="_blank" rel="noopener noreferrer">程序员延寿指南</a>。</p>
<h2 id="个人实践" tabindex="-1"> 个人实践</h2>
<div><p>提示</p>
<p>此处为原文作者的个人实践，而我基于这篇文章个人实践<a href="???">在这里</a>。</p>
</div>
<p>前面介绍的内容有点多，这篇文章篇幅也有些超了。最后来简单介绍下我个人目前采纳的一些行动和辅助工具。</p>
<p>睡眠方面暂时没有什么特别的措施，现在带娃基本上晚上睡眠质量也比较一般。只是会稍稍注意一下晚上 11 点后尽量不接触手机光源。早起接收光照这点，基本上就是早上遛狗或者开车通勤时间来接触，基本压力不大。如果比较讲究的同学，还可以下一个 <a href="https://mycircadianclock.org/" target="_blank" rel="noopener noreferrer">My Circadian Clock App</a> 来追踪一下生物钟，也是 Satchin Panda 等大佬参与开发的项目，值得信赖。</p>
<p>饮食方面，开始尝试 8 小时进食窗口的 fasting，目前感觉良好。中饭一般吃蔬菜为主的轻食，晚上就比较放飞自我，想吃啥吃啥。早上会看情况喝点盐水，茶或者 AG1 的补充剂。膳食补充剂目前基本只有复合维生素和 EPA 鱼油在使用，后面可以参考下 <a href="https://fastlifehacks.com/andrew-huberman-supplements-list/" target="_blank" rel="noopener noreferrer">Huberman 的“配方”</a> 增加一些。Huberman 自己也在节目中表示<strong>对白藜芦醇和 NMN 还在观望状态</strong>，我查了些资料发现有争议的地方还不少，所以我个人建议先采纳广受认可和使用的一些补充剂，如 EPA 鱼油，二甲双胍等。个人目前考虑的补充剂列表：</p>
<ul>
<li><a href="https://www.thorne.com/products/dp/basic-nutrients-2-day" target="_blank" rel="noopener noreferrer">基础维生素</a>，常规补充剂，也可以根据自己的饮食结构，生活习惯选择特定的营养物质补充。</li>
<li><a href="https://www.thorne.com/products/dp/super-epa-sp608nc" target="_blank" rel="noopener noreferrer">Omega-3 EPA</a>，常年销量靠前的补充剂，好处前面已经说了很多了。</li>
<li><a href="https://athleticgreens.com/en" target="_blank" rel="noopener noreferrer">AG1</a>，超火的小绿粉，各种植物提取物 + 各种维生素矿物会，Fridman 等大佬的节目里都有提到。个人买了一次，不过看一些其它评测貌似并不是很划得来。</li>
<li><a href="https://www.thorne.com/products/dp/betaine-hcl-pepsin-225-s" target="_blank" rel="noopener noreferrer">Betaine HCL &amp; Pepsin</a>，保护肠胃，促进吸收。</li>
<li><a href="https://www.thorne.com/products/dp/l-tyrosine" target="_blank" rel="noopener noreferrer">L-Tyrosine</a>，提升多巴胺，可能会买个尝尝鲜。</li>
<li><a href="https://zh.m.wikipedia.org/zh/%E4%BA%8C%E7%94%B2%E5%8F%8C%E8%83%8D" target="_blank" rel="noopener noreferrer">二甲双胍</a>，抗衰老“神药”，不过这个药的有效性和安全性还有争议，建议谨慎。</li>
<li><a href="https://www.thorne.com/products/dp/resveracel" target="_blank" rel="noopener noreferrer">ResveraCel</a>，白藜芦醇，NR 等抗衰老组合。效果同样有争议，尤其 NMN 这块更是各种产品鱼龙混杂无法分辨，谨慎购入。</li>
</ul>
<p>很多人都关心 fasting 可能引发胆结石，这里提供一些补充信息：</p>
<ul>
<li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1419405/" target="_blank" rel="noopener noreferrer">Bloch, H. M. 等人的论文</a> 来看，fasting 过程中胆汁的饱和度有一个先上升后下降的过程，<a href="https://youtu.be/2lGuXBwudKw" target="_blank" rel="noopener noreferrer">Dr. Berg 也以此做了解释</a>，认为 fasting 加生酮饮食（摄入脂肪）对胆囊健康反而是有益的。</li>
<li>从这篇 <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1405175/" target="_blank" rel="noopener noreferrer">Sichieri, R. 等人的论文</a> 的结果来看，long overnight fasting 和节食会提升得胆结石的概率。不过减肥（减少脂肪）本身就会提升得胆结石的概率。</li>
<li>持续 24 小时以上的禁食相关的研究比较少（比较难执行），但从机理上来说长时间的禁食应该会增加得胆结石的概率。</li>
<li>饮食结构，自身状况对胆结石的形成也会有很大影响，例如高胆固醇，高胰岛素水平，高碳水饮食等。高纤维食物，健康的脂肪摄入，有助于降低得胆结石的概率。</li>
</ul>
<p>总体看下来，我个人感觉这块的实验上没有一个定论（就跟 <a href="https://www.coffeeandhealth.org/factsheet/gallstones-factsheet" target="_blank" rel="noopener noreferrer">咖啡是否会引发胆结石</a> 一样），但应该不是一个概率很大的问题，起码 Huberman 教授跟这个领域的另一位权威 Satchin Panda 教授都没有提到这块的问题。理想情况是执行 fasting 时持续对你的身体状况做医学指标的跟踪。其它就看个人选择了 😃</p>
<p>工作，学习，专注方面，主要看自律了。这方面我总体控制还可以，在了解了多巴胺的工作原理之后就更加有自信了，主要靠各种软件的专注模式来近似执行番茄时钟法，此外也采用了升降桌，大概有 30% 的时间站立办公。工作间歇会尝试一下 Yoga Nidra。此外晚上学习时段会用 iPad 的 Books 来记录一下阅读时间，基本上每天保持 30 分钟以上，持续坚持。后面考虑试试工作时喝马黛茶，以及夏天开始尝试冷水澡。</p>
<p>运动方面是这一年来改观最大的一项，依靠小米手环 PAI 指数功能的督促，基本上做到了每周平均 3 次的跑步或者羽毛球活动，持续把 PAI 值保持在 200 左右。总体来说对于精神状态的改观还是很大的，肚子上的脂肪也减少了很多。唯一比较困扰的是一般下班后运动都要 9，10 点开始了，结束后会离入睡的时间比较近，有时候会对睡眠质量有所影响。</p>
<p>最后，Huberman 教授的 podcast 中还有很多其它内容，比如习惯养成，健身增肌，应对恐惧与创伤，情绪管理等，感兴趣的朋友可以进一步挖掘。本文以实验事实与原理假设的陈述为主，以上所有的行动方案都需要在咨询医师，专业人员的条件下，结合自身情况执行，注意自身安全，本人与 Huberman 都不负相关后果责任。</p>
<p>备注：这篇文章也同时发布到了 <a href="https://github.com/zijie0/HumanSystemOptimization" target="_blank" rel="noopener noreferrer">Github</a>，欢迎大家 Star 并提出宝贵建议，谢谢！如果你对我的其它作品感兴趣，也欢迎搜索关注公众号：RandomGenerator。</p>
]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/UWYiCh.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Git 笔记</title>
      <link>https://timpcfan.site/code/basic/git.html</link>
      <guid>https://timpcfan.site/code/basic/git.html</guid>
      <source url="https://timpcfan.site/rss.xml">Git 笔记</source>
      <category>笔记</category>
      <category>基础</category>
      <pubDate>Wed, 05 Oct 2022 14:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>Git 是一个非常常用的代码版本控制程序，算是每个开发者必备的技能。本笔记前半部分罗列了一些 Git 的常用指令，后半部分介绍了 。</p>
</div>
<h2 id="git-常用指令" tabindex="-1"> Git 常用指令</h2>
<p>查看版本：<code>git log (--pretty=oneline)</code>  图形：<code>git log --graph --pretty=oneline --abbrev-commit</code></p>
<p>查看历史命令：<code>git reflog</code></p>
<p>回退到目标版本：<code>git reset --hard (版本号/HEAD^/HEAD~n)</code></p>
<p>将文件加入暂存区：<code>git add (文件名/.)</code></p>
<p>将暂存区的内容提交：<code>git commit -m &quot;说明&quot;</code></p>
<p>将工作区中的内容撤销到上一次add或commit命令的状态：<code>git checkout–(文件名)</code></p>
<p>将暂存区的内容撤销：<code>git reset HEAD (文件名)</code></p>
<p><code>git reset --patch (filename)</code></p>
<p>在工作区删除文件，并将删除操作加入暂存区：<code>git rm (文件名)</code></p>
<p>🌟 撤销commit，保留修改的代码：<code>git reset --soft HEAD^</code></p>
<ul>
<li>--mixed：不删除工作空间改动代码，撤销commit，撤销add</li>
<li>--soft：不删除工作空间改动代码，撤销commit，不撤销add</li>
<li>--hard：删除改动代码，撤销commit，撤销add</li>
</ul>
<hr>
<h3 id="分支" tabindex="-1"> 分支</h3>
<ul>
<li>创建分支：<code>git branch (branch_name)</code></li>
<li>切换分支：<code>git checkout (branch_name)</code></li>
<li>创建并切换到分支：<code>git checkout -b (branch_name)</code></li>
<li>切换到远程分支：<code>git checkout -b (branch_name) origin/2.3-dev</code></li>
<li>查看当前所有分支：<code>git branch</code>，查看远程所有分支：<code>git branch -r</code></li>
<li>将指定分支合并到当前分支：<code>git merge (branch_name)</code></li>
<li>删除分支：<code>git branch -d (branch_name)</code> ，删除没有合并的分支要用-D</li>
<li>不使用FastForward模式进行分支的合并（在历史上能看出做过合并，ff模式看不出来做了合并）：
<ul>
<li><code>git merge --no-ff -m &quot;说明&quot; (branch_name)</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="暂存" tabindex="-1"> 暂存</h3>
<ul>
<li>把工作现场临时储存起来：<code>git stash</code></li>
<li>恢复工作现场：<code>git stash apply</code></li>
<li>将存档从stash中删除：<code>git stash drop</code></li>
<li>恢复工作现场并将存档从stash中删除：<code>git stash pop</code></li>
<li>列出所有stash内容：<code>git stash list</code></li>
</ul>
<hr>
<h3 id="远程服务器" tabindex="-1"> 远程服务器</h3>
<ul>
<li>查看远程库的信息：<code>git remote (-v)</code></li>
<li>将master分支推送至服务器origin上的master：<code>git push origin master</code></li>
<li>将dev分支推送至服务器origin上的test：<code>git push origin dev:test</code></li>
</ul>
<hr>
<h3 id="标签" tabindex="-1"> 标签</h3>
<ul>
<li>给指定commit创建标签：<code>git tag ()</code> 默认为HEAD</li>
<li>指定标签信息：<code>git tag -a -m &quot;balabala&quot;</code></li>
<li>使用PGP签名标签：<code>git tag -s -m &quot;balabala&quot;</code></li>
<li>查看所有标签：<code>git tag</code></li>
<li>删除标签： <code>git tag -d</code></li>
<li>将标签推送到服务器：<code>git push origin</code></li>
<li>将所有标签推送到服务器：<code>git push origin --tags</code></li>
<li>删除远程服务器上的一个标签：<code>git push origin :/refs/tags/</code></li>
</ul>
<hr>
<h3 id="初始化相关" tabindex="-1"> 初始化相关</h3>
<ul>
<li>生成ssh密钥：<code>ssh-keygen -t rsa -C &quot;lztsmail@gmail.com&quot;</code></li>
<li>添加远程库：<code>git remote add origin git@github.com/xxx</code></li>
<li><code>git pull origin master --allow-unrelated-histories</code></li>
<li><code>git push -u origin master</code></li>
</ul>
<hr>
<h3 id="设置基本信息" tabindex="-1"> 设置基本信息</h3>
<ul>
<li><code>git config --global user.name &quot;你的名字或昵称&quot;</code></li>
<li><code>git config --global user.email &quot;你的邮箱&quot;</code></li>
</ul>
<hr>
<h3 id="配置别名" tabindex="-1"> 配置别名</h3>
<div><pre><code><span>git</span> config <span>--global</span> alias.lg <span>"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="git-相关概念-基础篇" tabindex="-1"> Git 相关概念：基础篇 <sup></sup></h2>
<div><p>提示</p>
<p>强烈建议使用该线上教程 <a href="https://learngitbranching.js.org/?demo=&amp;locale=zh_CN" target="_blank" rel="noopener noreferrer">Learn Git Branching</a> 了解 git 的各种概念，本文后半部分为该线上教程的文字版本，供读者参考。</p>
</div>
<h3 id="git-commit" tabindex="-1"> Git Commit</h3>
<p>Git 仓库中的提交记录保存的是你的目录下所有文件的快照，<strong>就像是把整个目录复制</strong>，然后再粘贴一样，但比复制粘贴优雅许多！</p>
<p>Git 希望提交记录尽可能地轻量，因此在你每次进行提交时，它并<strong>不会盲目地复制整个目录</strong>。条件允许的情况下，它会将当前版本与仓库中的上一个版本进行对比，并<strong>把所有的差异打包到一起作为一个提交记录</strong>。</p>
<p>Git <strong>还保存了提交的历史记录</strong>。这也是为什么大多数提交记录的上面都有父节点的原因 —— 我们会在图示中用箭头来表示这种关系。对于项目组的成员来说，维护提交历史对大家都有好处。</p>
<p>关于提交记录太深入的东西咱们就不再继续探讨了，现在你可以把提交记录看作是项目的快照。提交记录非常轻量，可以快速地在这些提交记录之间切换！</p>
<h3 id="git-branch" tabindex="-1"> Git Branch</h3>
<p>Git 的分支也非常轻量。它们只是简单地指向某个提交纪录 —— 仅此而已。所以许多 Git 爱好者传颂：</p>
<blockquote>
<p>早建分支！多用分支！</p>
</blockquote>
<p>这是因为即使创建再多的分支也不会造成储存或内存上的开销，并且按逻辑分解工作到不同的分支要比维护那些特别臃肿的分支简单多了。</p>
<p>在将分支和提交记录结合起来后，我们会看到两者如何协作。现在只要记住使用分支其实就相当于在说：“我想基于这个提交以及它所有的父提交进行新的工作。”</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/FjFb0t.gif" alt="" height="300" loading="lazy"></p>
<h3 id="git-merge" tabindex="-1"> Git Merge</h3>
<p>我们已经知道如何提交以及如何使用分支了。接下来咱们看看如何将两个分支合并到一起。就是说我们新建一个分支，在其上开发某个新功能，开发完成后再合并回主线。</p>
<p>咱们先来看一下第一种方法 —— <code>git merge</code>。在 Git 中合并两个分支时会产生一个特殊的提交记录，<strong>它有两个父节点</strong>。翻译成自然语言相当于：“我要把这两个父节点本身及它们所有的祖先都包含进来。”</p>
<p>右图为将main 与 bugFix 进行合并，main移动指针指向新的结果。之后可以 <code>git checkout bugFix; git merge main</code> 会将bugFix指针直接移动到 C4，因为 C4 继承于 C2，已经包含了 C2的所有信息。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/0c2tyq.png" alt="" height="300" loading="lazy"></p>
<h3 id="git-rebase" tabindex="-1"> Git Rebase</h3>
<p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p>
<p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p>
<p>还是准备了两个分支；注意当前所在的分支是 bugFix（星号标识的是当前分支）</p>
<p>我们想要把 bugFix 分支里的工作直接移到 main 分支上。移动以后会使得两个分支的功能看起来像是按顺序开发，但实际上它们是并行开发的。</p>
<p>咱们这次用 <code>git rebase</code> 实现此目标</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Ot8Kis.gif" alt="" height="300" loading="lazy"></p>
<p>怎么样？！现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。</p>
<p>注意，提交记录 C3 依然存在（树上那个半透明的节点），而 C3' 是我们 Rebase 到 main 分支上的 C3 的副本。</p>
<h2 id="git-相关概念-在提交树上移动" tabindex="-1"> Git 相关概念：在提交树上移动</h2>
<p>在接触 Git 更高级功能之前，我们有必要先学习在你项目的提交树上前后移动的几种方法。</p>
<h3 id="head" tabindex="-1"> HEAD</h3>
<p>我们首先看一下 “HEAD”。 HEAD 是一个对当前检出记录的符号引用 —— 也就是<strong>指向你正在其基础上进行工作的提交记录</strong>。</p>
<p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。</p>
<p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p>
<div><p>相关信息</p>
<p>如果想看 HEAD 指向，可以通过 <code>cat .git/HEAD</code> 查看， 如果 HEAD 指向的是一个引用，还可以用 <code>git symbolic-ref HEAD</code> 查看它的指向。</p>
</div>
<h3 id="分离的-head" tabindex="-1"> 分离的 HEAD</h3>
<p>分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。在命令执行之前的状态如下所示：</p>
<p>HEAD -&gt; main -&gt; C1</p>
<p>HEAD 指向 main， main 指向 C1</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Vu5FYW.png" alt="" height="300" loading="lazy"></p>
<h3 id="相对引用" tabindex="-1"> 相对引用</h3>
<p>通过指定提交记录哈希值的方式在 Git 中移动不太方便。在实际应用时，并没有像本程序中这么漂亮的可视化提交树供你参考，所以你就不得不用 <code>git log</code> 来查查看提交记录的哈希值。</p>
<p>并且哈希值在真实的 Git 世界中也会更长（译者注：基于 SHA-1，共 40 位）。例如前一关的介绍中的提交记录的哈希值可能是 <code>fed2da64c0efc5293610bdd892f82a58e8cbc5d8</code>。舌头都快打结了吧...</p>
<p>比较令人欣慰的是，Git 对哈希的处理很智能。你只需要提供能够唯一标识提交记录的前几个字符即可。因此我可以仅输入<code>fed2</code> 而不是上面的一长串字符。</p>
<p>正如我前面所说，通过哈希值指定提交记录很不方便，所以 Git 引入了相对引用。这个就很厉害了!</p>
<p>使用相对引用的话，你就可以从一个易于记忆的地方（比如 <code>bugFix</code> 分支或 <code>HEAD</code>）开始计算。</p>
<p>相对引用非常给力，这里我介绍两个简单的用法：</p>
<ul>
<li>使用 <code>^</code> 向上移动 1 个提交记录</li>
<li>使用 <code>~&lt;num&gt;</code> 向上移动多个提交记录，如 <code>~3</code></li>
</ul>
<p>首先看看操作符 (^)。把这个符号加在引用名称的后面，表示让 Git 寻找指定提交记录的父提交。</p>
<p>所以 <code>main^</code> 相当于“<code>main</code> 的父节点”。</p>
<p><code>main^^</code> 是 <code>main</code> 的第二个父节点</p>
<p>现在咱们切换到 main 的父节点</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oHYiQr.png" alt="" height="300" loading="lazy"></p>
<h3 id="操作符" tabindex="-1"> “~”操作符</h3>
<p>如果你想在提交树中向上移动很多步的话，敲那么多 <code>^</code> 貌似也挺烦人的，Git 当然也考虑到了这一点，于是又引入了操作符 <code>~</code>。</p>
<p>该操作符后面可以跟一个数字（可选，不跟数字时与 <code>^</code> 相同，向上移动一次），指定向上移动多少次。咱们还是通过实际操作看一下吧</p>
<h3 id="强制修改分支位置" tabindex="-1"> 强制修改分支位置</h3>
<p>你现在是相对引用的专家了，现在用它来做点实际事情。</p>
<p>我使用相对引用最多的就是移动分支。可以直接使用 <code>-f</code> 选项让分支指向另一个提交。例如:</p>
<p><code>git branch -f main HEAD~3</code></p>
<p>上面的命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>
<p>这就对了! 相对引用为我们提供了一种简洁的引用提交记录 <code>C1</code> 的方式， 而 <code>-f</code> 则容许我们将分支强制移动到那个位置。</p>
<h2 id="git-相关概念-撤销变更" tabindex="-1"> Git 相关概念：撤销变更</h2>
<p>在 Git 里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p>
<p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。接下来咱们逐个进行讲解。</p>
<h3 id="git-reset" tabindex="-1"> Git Reset</h3>
<p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p>
<p><code>git reset HEAD~1</code> ←右侧执行的指令</p>
<p>Git 把 main 分支移回到 <code>C1</code>；现在我们的本地代码库根本就不知道有 <code>C2</code> 这个提交了。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/FATkLc.png" alt="" height="300" loading="lazy"></p>
<h3 id="git-revert" tabindex="-1"> Git Revert</h3>
<p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p>
<p><code>git revert HEAD</code> ← 右侧执行的指令</p>
<p>奇怪！在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2'</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2'</code> 的状态与 <code>C1</code> 是相同的。</p>
<p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dMf2k4.png" alt="" height="300" loading="lazy"></p>
<h2 id="git-相关概念-整理提交记录" tabindex="-1"> Git 相关概念：整理提交记录</h2>
<p>到现在我们已经学习了 Git 的基础知识 —— 提交、分支以及在提交树上移动。 这些概念涵盖了 Git 90% 的功能，同样也足够满足开发者的日常需求</p>
<p>然而, 剩余的 10% 在处理复杂的工作流时(或者当你陷入困惑时）可能就显得尤为重要了。接下来要讨论的这个话题是“整理提交记录” —— 开发人员有时会说“我想要把这个提交放到这里, 那个提交放到刚才那个提交的后面”, 而接下来就讲的就是它的实现方式，非常清晰、灵活，还很生动。</p>
<p>看起来挺复杂, 其实是个很简单的概念。</p>
<h3 id="git-cherry-pick" tabindex="-1"> Git Cherry-pick</h3>
<p>本系列的第一个命令是 <code>git cherry-pick</code>, 命令形式为:</p>
<ul>
<li><code>git cherry-pick &lt;提交号&gt;...</code></li>
</ul>
<p>如果你<strong>想将一些提交复制到当前所在的位置</strong>（<code>HEAD</code>）下面的话， Cherry-pick 是最直接的方式了。我个人非常喜欢 <code>cherry-pick</code>，因为它特别简单。</p>
<p>这里有一个仓库, 我们想将 <code>side</code> 分支上的工作复制到 <code>main</code> 分支，你立刻想到了之前学过的 <code>rebase</code> 了吧？但是咱们还是看看 <code>cherry-pick</code> 有什么本领吧。</p>
<p>这就是了！我们只需要提交记录 <code>C2</code> 和 <code>C4</code>，所以 Git 就将被它们抓过来放到当前分支下了。 就是这么简单!</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UkaXXr.gif" alt="" height="300" loading="lazy"></p>
<h3 id="交互式的-rebase" tabindex="-1"> 交互式的 rebase</h3>
<p>当你知道你所需要的提交记录（<strong>并且</strong>还知道这些提交记录的哈希值）时, 用 cherry-pick 再好不过了 —— 没有比这更简单的方式了。</p>
<p>但是如果你不清楚你想要的提交记录的哈希值呢? 幸好 Git 帮你想到了这一点, 我们可以利用交互式的 rebase —— 如果你想从一系列的提交记录中找到想要的记录, 这就是最好的方法了</p>
<p>交互式 rebase 指的是使用带参数 <code>--interactive</code> 的 rebase 命令, 简写为 <code>-i</code></p>
<p>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。</p>
<p>在实际使用时，所谓的 UI 窗口一般会在文本编辑器 —— 如 Vim —— 中打开一个文件。 考虑到课程的初衷，我弄了一个对话框来模拟这些操作。</p>
<p>当 rebase UI界面打开时, 你能做3件事:</p>
<ul>
<li>调整提交记录的顺序（通过鼠标拖放来完成）</li>
<li>删除你不想要的提交（通过切换 <code>pick</code> 的状态来完成，关闭就意味着你不想要这个提交记录）</li>
<li>合并提交。 遗憾的是由于某种逻辑的原因，我们的课程不支持此功能，因此我不会详细介绍这个操作。简而言之，它允许你把多个提交记录合并成一个。</li>
</ul>
<p>接下来咱们看个实例</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/y9HpbZ.gif" alt="" loading="lazy"></p>
<h2 id="git-相关概念-一些小技巧" tabindex="-1"> Git 相关概念：一些小技巧</h2>
<h3 id="本地栈式提交" tabindex="-1"> 本地栈式提交</h3>
<p>来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。</p>
<p>这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！</p>
<p>最后就差把 <code>bugFix</code> 分支里的工作合并回 <code>main</code> 分支了。你可以选择通过 fast-forward 快速合并到 <code>main</code> 分支上，但这样的话 <code>main</code> 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式……</p>
<p>实际我们只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用</p>
<ul>
<li><code>git rebase -i</code></li>
<li><code>git cherry-pick</code></li>
</ul>
<p>来达到目的。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/d4WhjT.png" alt="" height="300" loading="lazy">  
<img src="http://timpcfan-site.cdn.bcebos.com/imgs/uOu6XQ.png" alt="" height="300" loading="lazy"></p>
<h3 id="提交的技巧-1" tabindex="-1"> 提交的技巧 #1</h3>
<p>接下来这种情况也是很常见的：你之前在 <code>newImage</code> 分支上进行了一次提交，然后又基于它创建了 <code>caption</code> 分支，然后又提交了一次。</p>
<p>此时你想对某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 <code>newImage</code> 中图片的分辨率，尽管那个提交记录并不是最新的了。</p>
<p>我们可以通过下面的方法来克服困难：</p>
<ul>
<li>先用 <code>git rebase -i</code> 将提交重新排序，然后把我们想要修改的提交记录挪到最前</li>
<li>然后用 <code>git commit --amend</code> 来进行一些小修改</li>
<li>接着再用 <code>git rebase -i</code> 来将他们调回原来的顺序</li>
<li>最后我们把 main 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！</li>
</ul>
<p>当然完成这个任务的方法不止上面提到的一种（我知道你在看 cherry-pick 啦），之后我们会多点关注这些技巧啦，但现在暂时只专注上面这种方法。 最后有必要说明一下目标状态中的那几个<code>'</code> —— 我们把这个提交移动了两次，每移动一次会产生一个 <code>'</code>；而 C2 上多出来的那个是我们在使用了 amend 参数提交时产生的，所以最终结果就是这样了。</p>
<p>也就是说，我在对比结果的时候只会对比提交树的结构，对于 <code>'</code> 的数量上的不同，并不纳入对比范围内。只要你的 <code>main</code> 分支结构与目标结构相同，我就算你通过。</p>
<h3 id="提交的技巧-2" tabindex="-1"> 提交的技巧 #2</h3>
<p><em>如果你还没有完成“提交的技巧 #1”（前一关）的话，请先通过以后再来！</em></p>
<p>正如你在上一关所见到的，我们可以使用 <code>rebase -i</code> 对提交记录进行重新排序。只要把我们想要的提交记录挪到最前端，我们就可以很轻松的用 <code>--amend</code> 修改它，然后把它们重新排成我们想要的顺序。</p>
<p>但这样做就唯一的问题就是要进行两次排序，而这有可能造成由 rebase 而导致的冲突。下面还是看看 <code>git cherry-pick</code> 是怎么做的吧。</p>
<h3 id="git-tags" tabindex="-1"> Git Tags</h3>
<p>相信通过前面课程的学习你已经发现了：分支很容易被人为移动，并且当有新的提交时，它也会移动。分支很容易被改变，大部分分支还只是临时的，并且还一直在变。</p>
<p>你可能会问了：有没有什么可以<em>永远</em>指向某个提交记录的标识呢，比如软件发布新的大版本，或者是修正一些重要的 Bug 或是增加了某些新特性，有没有比分支更好的可以永远指向这些提交的方法呢？</p>
<p>当然有了！Git 的 tag 就是干这个用的啊，它们可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。</p>
<p>更难得的是，它们并不会随着新的提交而移动。你也不能切换到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。</p>
<p>咱们来看看标签到底是什么样。</p>
<p>咱们先建立一个标签，指向提交记录 <code>C1</code>，表示这是我们 1.0 版本。</p>
<div><pre><code>git tag v1 C1
</code></pre><div aria-hidden="true"><div></div></div></div><p>很容易吧！我们将这个标签命名为 <code>v1</code>，并且明确地让它指向提交记录 <code>C1</code>，如果你不指定提交记录，Git 会用 <code>HEAD</code> 所指向的位置。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/B84z6y.png" alt="" height="300" loading="lazy"></p>
<h3 id="git-describe" tabindex="-1"> Git Describe</h3>
<p>由于标签在代码库中起着“锚点”的作用，Git 还为此专门设计了一个命令用来<strong>描述</strong>离你最近的锚点（也就是标签），它就是 <code>git describe</code>！</p>
<p>Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 <code>git bisect</code>（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。</p>
<p><code>git describe</code> 的语法是：</p>
<p><code>git describe &lt;ref&gt;</code></p>
<p><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（<code>HEAD</code>）。</p>
<p>它输出的结果是这样的：</p>
<p><code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code></p>
<p><code>tag</code> 表示的是离 <code>ref</code> 最近的标签， <code>numCommits</code> 是表示这个 <code>ref</code> 与 <code>tag</code> 相差有多少个提交记录， <code>hash</code> 表示的是你所给定的 <code>ref</code> 所表示的提交记录哈希值的前几位。</p>
<p>当 <code>ref</code> 提交记录上有某个标签时，则只输出标签名称</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/nlsthb.png" alt="" height="300" loading="lazy"></p>
<h3 id="多分支-rebase" tabindex="-1"> 多分支 rebase</h3>
<p>哥们儿，我们准备了很多分支！咱们把这些分支 rebase 到 main 上吧。</p>
<p>但是你的领导给你提了点要求 —— 他们希望得到有序的提交历史，也就是我们最终的结果应该是 <code>C6'</code> 在 <code>C7'</code> 上面， <code>C5'</code> 在 <code>C6'</code> 上面，依此类推。</p>
<p>即使你搞砸了也没关系，用 <code>reset</code> 命令就可以重新开始了。记得看看我们提供的答案，看你能否使用更少的命令来完成任务！</p>
<h3 id="选择父提交记录" tabindex="-1"> 选择父提交记录</h3>
<p>操作符 <code>^</code> 与 <code>~</code> 符一样，后面也可以跟一个数字。</p>
<p>但是该操作符后面的数字与 <code>~</code> 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。</p>
<p>Git 默认选择合并提交的“第一个”父提交，在操作符 <code>^</code> 后跟一个数字可以改变这一默认行为。</p>
<p>废话不多说，举个例子。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/GzTuD6.png" alt="" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5UVgNg.png" alt="" loading="lazy"></p>
<hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://learngitbranching.js.org/?demo=&amp;locale=zh_CN" target="_blank" rel="noopener noreferrer">Learn Git Branching</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>CSS 笔记</title>
      <link>https://timpcfan.site/code/frontend/css.html</link>
      <guid>https://timpcfan.site/code/frontend/css.html</guid>
      <source url="https://timpcfan.site/rss.xml">CSS 笔记</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Tue, 04 Oct 2022 01:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>相关信息</p>
<p>整理了一些学习 CSS 时的笔记。</p>
</div>
<h2 id="css-布局之-position-篇" tabindex="-1"> CSS 布局之 position 篇 <sup></sup></h2>
<div><p>提示</p>
<p><code>position</code> 属性用来描述 HTML 元素如何在文档流中定位。</p>
</div>
<h3 id="position-属性" tabindex="-1"> position 属性</h3>
<p>position 属性的值有：</p>
<ul>
<li>static：（默认值）根据正常文档流放置。</li>
<li>relative：基于正常文档流的位置使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
<li>absolute：将元素<strong>移出文档流</strong>，在<a href="/code/frontend/css_containing_block.html"><mark>包含块</mark></a>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>fixed：将元素<strong>移出文档流</strong>，在<strong>整个视图区域</strong>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>sticky：基于正常文档流的位置放置，并且在滚动屏幕时能粘在画面内，使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
</ul>
<div><p>巨大的坑</p>
<p>注意：<strong>包含块</strong>不一定就是直接的父容器！详情请查阅<a href="/code/frontend/css_containing_block.html">文档</a>。</p>
</div>
<h3 id="指定位置" tabindex="-1"> 指定位置</h3>
<p><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性用于指定元素的最终位置。</p>
<div><p>这里拿 absolute 模式来举例。</p>
</div>
<ul>
<li>top: 元素上边界距离包含块的相对距离。</li>
<li>right: 元素右边界距离包含块的相对距离。</li>
<li>bottom: 元素下边界距离包含块的相对距离。</li>
<li>left: 元素左边界距离包含块的相对距离。</li>
</ul>
<iframe height="370px" width="100%" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe>
<h2 id="css-布局之-flexbox-篇-基础" tabindex="-1"> CSS 布局之 Flexbox 篇（基础） <sup></sup></h2>
<h3 id="介绍" tabindex="-1"> 介绍</h3>
<p>Flexbox 是Flexible Box Module. 一种布局模型，可以轻松控制 html 元素 之间的空间分布和对齐方式。</p>
<p>Flexbox 控制一次仅在一维（行或列）中的定位。对于二维控件，CSS Grid Layout 应运而生。</p>
<p>给定以下模板：</p>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-10<span>"</span></span><span>></span></span>10<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上述 div 的默认行为，尊重正常的 html 文档流，是从上到下、从左到右呈现并占据整个正文宽度，因为它的display属性默认为block.</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/4USqRq.jpg" alt="4USqRq" height="300" loading="lazy"></p>
<h3 id="弹性item" tabindex="-1"> 弹性item</h3>
<p>当<code>display: flex</code>应用于<code>.container div</code> 时，所有直接子 <code>div</code> 变为<code>flex-items</code>，并获得新的行为：</p>
<ul>
<li>它们将显示在一行中，因为 <code>flex-direction</code> 默认为 <code>row</code></li>
<li>它们将从左到右显示</li>
<li>项目<strong>不会拉伸</strong>以适应整个宽度（主轴），但它们会收缩以做到这一点。
<img src="http://timpcfan-site.cdn.bcebos.com/imgs/AsUQoe.gif" alt="AsUQoe" loading="lazy"></li>
<li>项目<strong>拉伸</strong>以适应交叉轴（本例中的高度）。</li>
<li>如果物品有不同的高度，它们将伸展到最高的一个高度</li>
<li>flex-basis默认为auto（项目宽度将由其内容设置）</li>
<li>flex-wrap默认为nowrap（如果容器的宽度不足以容纳物品，它们不会包装，而是会溢出）</li>
</ul>
<div><p>提示</p>
<p>在主轴上收缩（收缩成自身宽度），在交叉轴上拉伸（拉伸成最高那个）。</p>
</div>
<h3 id="弹性容器" tabindex="-1"> 弹性容器</h3>
<ul>
<li>display: flex使容器扩展可用的整个宽度。与flex相反display: inline-flex，它使容器折叠到内容的宽度。</li>
</ul>
<h3 id="flex-direction" tabindex="-1"> flex-direction</h3>
<p>一旦声明为 flex 容器，该元素就可以被认为是两个轴。主轴，由flex-direction属性定义。和交叉轴，它垂直于第一个。</p>
<p>该属性有四个值flex-direction：<code>row</code>、 <code>column</code>、<code>row-reverse</code>、 <code>columncolumn-reverse</code></p>
<p>默认值为row，它设置主轴水平，从左到右，横轴垂直截取它，从上到下。类似地，该column值设置垂直轴，从上到下，交叉轴从左到右。两个选项的reverse属性都将主轴反转 180°。交叉轴保持不变。</p>
<p>这些值的弹性项目行为可以在下面观察到：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oibRlg.gif" alt="oibRlg" loading="lazy"></p>
<h3 id="flex-wrap" tabindex="-1"> flex-wrap</h3>
<p>flex-wrap是当容器中的空间不足以容纳所有弹性项目时处理弹性项目的属性。</p>
<p>默认情况下flex-wrap设置为nowrap，这意味着如果容器不能以原始宽度容纳一行中的项目，它们将缩小以适应。如果由于某种原因它们无法收缩，那么它们会溢出容器。</p>
<p>通过为项目设置 300px 宽度，该nowrap选项会输出以下结果：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yuHKj4.png" alt="yuHKj4" height="300" loading="lazy"></p>
<p>其中，每个项目都缩小到大约 70px 以适应容器。</p>
<p>当属性更新为 时wrap，项目的宽度现在实际上将具有其原始值 300 像素。当第一行的宽度不足以容纳 300 像素时，该项目不会溢出容器，而是换行到新行。每一行都应该被认为是一个单独的弹性容器。一个容器中的空间分布不会影响相邻的其他容器。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HqmnPV.png" alt="HqmnPV" height="300" loading="lazy"></p>
<p>另一种选择是wrap-reverse，它反转交叉轴。flex-direction由属性从上到下设置，wrap-reverse将其转换为从下到上。</p>
<h3 id="弹性流" tabindex="-1"> 弹性流</h3>
<p><code>flex-direction</code>并且<code>flex-wrap</code>可以在单个属性中声明：<code>flex-flow: [direction] [wrap]</code></p>
<h3 id="对齐" tabindex="-1"> 对齐</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/invnoF.png" alt="" loading="lazy"></p>
<p>在 Flexbox 中，项目沿轴的对齐和空间分布可以通过四个属性来控制 ：</p>
<ul>
<li>justify-content：对齐主轴上的所有项目</li>
<li>align-items：对齐交叉轴上的所有项目</li>
<li>align-self：在交叉轴上对齐单个项目</li>
<li>align-content: 控制交叉轴上弯曲线之间的空间</li>
</ul>
<h3 id="弹性盒尺寸" tabindex="-1"> 弹性盒尺寸</h3>
<p>项目的大小和灵活性可以通过三个属性来控制flex-grow、flex-shrink和flex-basis。这三个都作用于主轴。</p>
<ul>
<li>flex-grow: 如果有多余的空间，每个项目应该如何放大</li>
<li>flex-shrink: 如果没有足够的空间，每个项目应该如何减少</li>
<li>flex-basis: 在设置上面两个属性之前，项目应该是什么大小</li>
</ul>
<h4 id="flex-grow-弹性成长" tabindex="-1"> flex-grow 弹性成长</h4>
<p>此属性的flex grow factor设置是处理项目大小相对于彼此的比率。</p>
<p>默认值为 0，表示如果有可用空间，则将其放在最后一项之后。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/55rRLZ.png" alt="" loading="lazy"></p>
<p>在上面的示例中，direction设置为row，并且每个弹性项目width都设置为60px。由于容器很980px宽，因此有680px可用空间。该空间称为positive free space。</p>
<p>通过设置flex-grow为1，正的可用空间量在弹性项目之间平均分配。每个项目的宽度将增加136px，总计196px。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5trUDz.png" alt="" loading="lazy"></p>
<p>通过<code>flex-grow: 2</code>应用于第三个项目，它获得的可用正可用空间量是<code>286px</code>其余项目的两倍，<code>173px</code>。</p>
<p>下图显示了<code>flex-grow</code>属性设置为其内容值的项目。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1ftKa2.png" alt="" loading="lazy"></p>
<h4 id="flex-shrink-弹性收缩" tabindex="-1"> flex-shrink 弹性收缩</h4>
<p>flex-shrink处理项目大小，当没有足够的可用空间将它们全部放入容器中时。因此，它negative free space通过缩小项目来划分项目。</p>
<p>下一张图片显示了980px装有五个300px宽物品的容器。由于没有空间容纳1500px所需，默认flex shrink factor值1使每个项目均匀收缩到196px。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Y3Pm8q.png" alt="" loading="lazy"></p>
<p>通过<code>flex-shrink: 2</code>为第三项设置比率，它会比其他项小两倍。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Wcu0xX.png" alt="" loading="lazy"></p>
<p>本节中的最后一张图片显示了将其内容值保存为 flex 收缩率的每个项目。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/uAEXro.png" alt="" loading="lazy"></p>
<h4 id="flex-basis-弹性基础" tabindex="-1"> flex-basis 弹性基础</h4>
<p>flex-basis是在实际设置可用空间之前检查每个项目应具有的大小的属性。默认值为auto，并且项目宽度由width属性显式设置，或者采用内容宽度。它还接受像素值。</p>
<p>下面的 gif 显示了一个800px宽容器和五个设置为flex-basis: 160px. 这告诉浏览器：理想情况下，有足够的空间来放置所有项目，尊重它们的160px宽度，并且没有正/负的可用空间。如果没有足够的空间，由于flex-shrink默认为1，所有项目都被均匀收缩。如果有多余的空间，则flex-grow默认为0，并且空白空间位于最后一项之后。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SKURrp.png" alt="" loading="lazy"></p>
<p>下一个 gif 显示项目 1 设置为<code>flex-shrink: 10</code>，项目 4 设置为<code>flex-grow: 10</code>。对于负的可用空间，项目 1 的宽度减少了 10 倍。对于正的可用空间，项目 4 的宽度是其他项目的 10 倍。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/B184OW.png" alt="" loading="lazy"></p>
<p><code>flex-basis</code>也接受 value <code>content</code>，无论<code>width</code>是否设置，计算可用空间的宽度都是项目的内容。如果您不想考虑该计算的项目宽度，请将基础设置为<code>0</code>。</p>
<h4 id="flex-弹性" tabindex="-1"> flex 弹性</h4>
<p>flex 是 <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code> 的简写.</p>
<p>它接受以下预定义值：</p>
<ul>
<li><code>initial</code>: 重置为 flexbox 默认值，与 <code>flex: 0 1 auto</code> 相同</li>
<li><code>auto</code>: flex-items 可以根据需要增长/缩小，与 <code>flex: 1 1 auto</code> 相同</li>
<li><code>none</code>: 使项目不灵活，与 <code>flex: 0 0 auto</code> 相同</li>
<li><code>flex: 1</code>: flex-items 具有增长/收缩的能力并且flex-basis设置为零，与 <code>flex: 1 1 0</code> 相同</li>
</ul>
<h2 id="css-布局之-flexbox-篇-扩展" tabindex="-1"> CSS 布局之 Flexbox 篇（扩展） <sup></sup></h2>
<h3 id="几个例子" tabindex="-1"> 几个例子</h3>
<h4 id="例子-居中对齐" tabindex="-1"> 例子：居中对齐</h4>
<div><pre><code><span>.CenterMe</span> <span>{</span>
	<span>background-color</span><span>:</span> indigo<span>;</span>
	<span>color</span><span>:</span> #ebebeb<span>;</span>
	<span>font-size</span><span>:</span> 2rem<span>;</span>
	<span>height</span><span>:</span> 200px<span>;</span>
	<span>display</span><span>:</span> flex<span>;</span>
	<span>align-items</span><span>:</span> center<span>;</span> <span>/* 沿着交叉轴对齐 */</span>
	<span>justify-content</span><span>:</span> center<span>;</span> <span>/* 沿着主轴对齐 */</span>
<span>}</span>

&lt;div class=<span>"CenterMe"</span>>Hello<span>,</span> I'm centered with Flexbox!&lt;/div>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/K3PDPP.png" alt="K3PDPP" loading="lazy"></p>
<h4 id="例子-偏移" tabindex="-1"> 例子：偏移</h4>
<div><pre><code><span>.LastItem,
.ListItem</span> <span>{</span>
  <span>color</span><span>:</span> #ebebeb<span>;</span>
  <span>text-decoration</span><span>:</span> none<span>;</span>
<span>}</span>

<span>.ListItem</span> <span>{</span>
  <span>margin-right</span><span>:</span> 1rem<span>;</span>
<span>}</span>

<span>.LastItem</span> <span>{</span>
  <span>margin-left</span><span>:</span> auto<span>;</span> <span>/* 用上该侧所有可用的外边距 */</span>
<span>}</span>

&lt;div class=<span>"MenuWrap"</span>>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Home&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>About Us&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Products&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Policy&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"LastItem"</span>>Contact Us&lt;/a>
&lt;/div>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/9jnlas.png" alt="9jnlas" loading="lazy"></p>
<h4 id="例子-反序" tabindex="-1"> 例子：反序</h4>
<p>让所有项反序排列</p>
<div><pre><code><span>flex-direction</span><span>:</span> row-reverse
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>相关信息</p>
<p>此外还有 column-reverse  为垂直反序。</p>
</div>
<h3 id="flexbox的对齐" tabindex="-1"> flexbox的对齐</h3>
<p>关于Flexbox的对齐，最重要的是理解坐标轴。有两个轴，“主轴”和“交叉轴”。这两个轴代表什么取决于Flexbox排列的方向。比如，如果将Flexbox的方向设置为<code>row</code>，则主轴就是横轴， 而交叉轴就是纵轴。</p>
<p>反之，如果Flexbox的方向是<code>column</code>，则主轴就是纵轴，而交叉轴为横轴。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OioNsa.png" alt="OioNsa" loading="lazy"></p>
<h4 id="沿着交叉轴对齐" tabindex="-1"> 沿着交叉轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>align-items：设置容器内所有item沿交叉轴对齐的方式（对容器内元素）</li>
<li>align-self：针对内部元素，设置特定的沿交叉轴对齐的方式（对自己）</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start: 把元素的对齐设置为flex-start，可以让元素从Flexbox父元素的起始边 开始。</li>
<li>flex-end: 把元素的对齐设置为flex-end，会沿Flexbox父元素的末尾对齐该元素。</li>
<li>center: 把元素放在Flexbox元素的中间。</li>
<li>baseline: 让Flexbox元素中的所有项沿基线对齐。</li>
<li>stretch: 让Flexbox中的所有项(没交叉轴)拉伸至与父元素一样大</li>
</ul>
<h4 id="沿着主轴对齐" tabindex="-1"> 沿着主轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>justify-content：设置容器内所有item沿主轴的对齐方式</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-between：设置如何处理空白，将空白分配到元素之间</li>
<li>space-around：设置如何处理空白，将空白分配到元素两边</li>
</ul>
<div><pre><code>&lt;div class=<span>"FlexWrapper"</span>>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 1.&lt;/div>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 2.&lt;/div>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 3.&lt;/div>
&lt;/div>
<span>/* 再看以下CSS。我们把每个内部元素(FlexInner)的宽度都设置为25%，包含它们的容器
Flexbox(FlexWrapper)的宽度为100% */</span>
<span>.FlexWrapper</span> <span>{</span>
	<span>background-color</span><span>:</span> indigo<span>;</span>
	<span>display</span><span>:</span> flex<span>;</span>
	<span>justify-content</span><span>:</span> space-between<span>;</span>
	<span>height</span><span>:</span> 200px<span>;</span>
	<span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>
<span>.FlexInner</span> <span>{</span>
  <span>background-color</span><span>:</span> #34005B<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
  <span>width</span><span>:</span> 25%<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Iqs9fg.png" alt="Iqs9fg" loading="lazy"></p>
<h3 id="flex属性" tabindex="-1"> flex属性</h3>
<p>前面已经给伸缩项(flex-item)定义过宽度了。除了width，还可以通过flex属性来定义宽 度，或者叫“伸缩性”(flexiness)。再看另一个例子，同样的标记，但CSS有所不同:</p>
<div><pre><code><span>.FlexInner</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #ebebeb<span>;</span>
  <span>background-color</span><span>:</span> #34005B<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
	<span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的flex实际上是三个属性合体的简写:flex-grow、flex-shrink和flex-basis。 关于这三个属性的详细介绍，可以参考规范<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener noreferrer">原文</a>。不过， 规范还是建议大家使用flex这个简写属性，也就是我们这里用的这个，明白吗?</p>
<div><pre><code><span>flex</span><span>:</span> 1       1     100px
      伸展    收缩    基准
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>对于伸缩项，如果flex属性存在(且浏览器支持)，<strong>则使用它的值控制元素的大小，忽略宽度和高度值的设置</strong>，即使它们的声明位于flex声明之后，也会被忽略。下面分别看看这三个 属性。</p>
<ul>
<li>flex-grow(传给flex的第一个值)是相对于其他伸缩项，当前伸缩项在空间允许的情况下可以伸展的量。</li>
<li>flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量。</li>
<li>flex-basis(传给flex的最后一个值)是伸缩项伸缩的基准值。</li>
</ul>
<p>虽然只写<code>flex: 1</code>也没问题，但还是建议大家把三个值写全。这样才能更清楚地表明你想干什么。比如<code>flex: 1 2 auto</code>的意思是在有空间的情况下可以伸展1部分，在空间不足时可以收缩1部分，而<strong>基准大小是内容的固有宽度</strong>(即不伸缩的情况下内容的大小)。
再试一个:<code>flex: 0 0 50px</code>的意思是，这个伸缩项既不伸也不缩，基准为50像素(即无论是否存在自由空间，都是50像素)。那么<code>flex: 2 0 50%</code>呢?意思就是会多占用两个可用空间， 不收缩，基准为50%。但愿这几个例子能帮大家理解flex属性。</p>
<div><p>提示</p>
<p>将flex-shrink的值设置为0，flex-basis实际上就相当于最小宽度。</p>
</div>
<h2 id="css-布局之-grid-篇" tabindex="-1"> CSS 布局之 Grid 篇 <sup></sup></h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/GwfRmw.png" alt="" loading="lazy"></p>
<p>一个网格通常具有许多的<strong>列（column）<strong>与</strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p>
<h3 id="定义网格" tabindex="-1"> 定义网格</h3>
<p>在一个父容器中使用：<code>display: grid;</code> ，将这个容器改为网格布局。</p>
<ul>
<li>初始状态：只有一列的网格，你的子项还是会像正常布局流那样从上往下排布。</li>
</ul>
<div><pre><code><span>.container</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template-columns</span><span>:</span> 200px 200px 200px<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>使用 <code>grid-template-columns</code> 来定义多个列，每个参数代表一个列的宽度。可以使用 <code>fr</code> 这个单位来灵活定义网格的行与列的大小。这个单位表示了<strong>可用空间</strong>的一个比例。</p>
<div><pre><code><span>grid-template-columns</span><span>:</span> 1fr 1fr 1fr<span>;</span>          <span>/* 三个列，每个列宽度相等 */</span>
<span>grid-template-columns</span><span>:</span> 400px 1fr 1fr<span>;</span>        <span>/* 三个列，后面两个列的宽度为：(总宽度-400px)/2 */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 1fr<span>)</span><span>;</span>       <span>/* 三个列，可以使用repeat函数来重复定义 */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>2<span>,</span> 1fr<span>,</span> 2fr<span>)</span><span>;</span>  <span>/* 1fr 2fr 1fr 2fr */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fill<span>,</span> <span>minmax</span><span>(</span>200px<span>,</span> 1fr<span>)</span><span>)</span><span>;</span> <span>/* auto-fill 表示填满屏幕，minmax限制大小 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>同样的，使用 <code>grid-template-rows</code> 可以定义多个行 ，每个参数代表一个行的高度。</p>
</div>
<h4 id="网格间隙" tabindex="-1"> 网格间隙</h4>
<div><pre><code><span>gap</span><span>:</span> 20px<span>;</span>  <span>/* 标准 */</span>
<span>grid-gap</span><span>:</span> 20px<span>;</span>  <span>/* 旧 */</span>
<span>grid-row-gap</span><span>:</span> 20px<span>;</span>  <span>/* 行间距 */</span>
<span>grid-column-gap</span><span>:</span> 20px<span>;</span>  <span>/* 列间距 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h4 id="显式网格与隐式网格" tabindex="-1"> 显式网格与隐式网格</h4>
<p>使用 <code>grid-template-columns</code> 与 <code>grid-template-rows</code> 定义的网络称为显式网格，而多余的内容则会继续往下填充到新的行的格子内，这些格子被称为隐式网格。</p>
<p>隐式网格的默认行/列大小是参数<code>auto</code> ，大小会根据放入的内容自动调整。也可以使用 <code>[grid-auto-rows](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows)</code>和<code>[grid-auto-columns](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns)</code>属性手动设定隐式网格的大小。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 1fr<span>)</span><span>;</span>
  <span>grid-auto-rows</span><span>:</span> 100px<span>;</span>
  <span>grid-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="元素放置" tabindex="-1"> 元素放置</h3>
<h4 id="基于线的元素放置" tabindex="-1"> 基于线的元素放置</h4>
<p>定义完网格之后，每行每列的边界（网格线的边缘）都有一个索引，可以使用这些线来定位放置元素。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHBtux.png" alt="" loading="lazy"></p>
<div><pre><code><span>grid-column-start</span><span>:</span> 1  <span>/* 列的开始边界 */</span>
<span>grid-column-end</span><span>:</span> 3  <span>/* 列的结束边界，因此 1 / 3 表示 1、2列 */</span>
<span>grid-row-start</span><span>:</span> 2
<span>grid-row-end</span><span>:</span> 3
<span>/* 或者 */</span>
<span>grid-column</span><span>:</span> 1 / 3
<span>grid-row</span><span>:</span> 2
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>可以使用负数来进行倒数，但对于隐式网格来说 -1 不一定代表最后一条分界线。</p>
</div>
<h4 id="使用-grid-template-areas-属性放置元素" tabindex="-1"> 使用 grid-template-areas 属性放置元素</h4>
<p>另一种往网格放元素的方式是用<code>[grid-template-areas](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas)</code>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p>
<p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-areas</span><span>:</span>
      <span>"header header"</span>
      <span>"sidebar content"</span>
      <span>"footer footer"</span><span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 3fr<span>;</span>
  <span>grid-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>

<span>header</span> <span>{</span>
  <span>grid-area</span><span>:</span> header<span>;</span>
<span>}</span>

<span>article</span> <span>{</span>
  <span>grid-area</span><span>:</span> content<span>;</span>
<span>}</span>

<span>aside</span> <span>{</span>
  <span>grid-area</span><span>:</span> sidebar<span>;</span>
<span>}</span>

<span>footer</span> <span>{</span>
  <span>grid-area</span><span>:</span> footer<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>grid-template-areas</code>属性的使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用<code>.</code>符号，让一个格子留空</li>
</ul>
<p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p>
<h2 id="css-选择器" tabindex="-1"> CSS 选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>.class</td>
<td>.intro</td>
<td>选择所有class=&quot;intro&quot;的元素</td>
<td>1</td>
</tr>
<tr>
<td>#id</td>
<td>#firstname</td>
<td>选择所有id=&quot;firstname&quot;的元素</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>选择所有元素</td>
<td>2</td>
</tr>
<tr>
<td>element</td>
<td>p</td>
<td>选择所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element,element</td>
<td>div,p</td>
<td>选择所有<code>&lt;div&gt;</code>元素和<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element element</td>
<td>div p</td>
<td>选择<code>&lt;div&gt;</code>元素内的所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>div&gt;p</td>
<td>选择所有父级是 <code>&lt;div&gt;</code> 元素的 <code>&lt;p&gt;</code> 元素（div的直接儿子，不包含孙子）</td>
<td>2</td>
</tr>
<tr>
<td>element+element</td>
<td>div+p</td>
<td>选择所有紧跟在 <code>&lt;div&gt;</code> 元素之后的第一个 <code>&lt;p&gt;</code> 元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute]</td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>[target=-blank]</td>
<td>选择所有使用target=&quot;-blank&quot;的元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词&quot;flower&quot;的所有元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute</td>
<td>=language]</td>
<td>[lang</td>
<td>=en]</td>
</tr>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问链接</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
<td>1</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择活动链接</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
<td>1</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
<td>2</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一个字母</td>
<td>1</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一行</td>
<td>1</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>指定只有当<code>&lt;p&gt;</code>元素是其父级的第一个子级的样式。</td>
<td>2</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个<code>&lt;p&gt;</code>元素之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个<code>&lt;p&gt;</code>元素之后插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值=&quot;it&quot;的所有<code>&lt;p&gt;</code>元素</td>
<td>2</td>
</tr>
<tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=&quot;https&quot;]</td>
<td>选择每一个src属性的值以&quot;https&quot;开头的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=&quot;.pdf&quot;]</td>
<td>选择每一个src属性的值以&quot;.pdf&quot;结尾的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=&quot;runoob&quot;]</td>
<td>选择每一个src属性的值包含子字符串&quot;runoob&quot;的元素</td>
<td>3</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
<td>3</td>
</tr>
<tr>
<td>:root</td>
<td>:root</td>
<td>选择文档的根元素</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
<td>3</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
<td>3</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
<td>3</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range</td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-write</td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-only</td>
<td>:read-only</td>
<td>用于匹配设置 &quot;readonly&quot;（只读） 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:optional</td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:required</td>
<td>:required</td>
<td>用于匹配设置了 &quot;required&quot; 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid</td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
<td>3</td>
</tr>
<tr>
<td>:invalid</td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener noreferrer">position - CSS | MDN</a> </p>
</li>
<li id="footnote2"><p><a href="https://blog.csdn.net/allway2/article/details/125083126" target="_blank" rel="noopener noreferrer">Flexbox 基础知识_allway2的博客-CSDN博客</a> </p>
</li>
<li id="footnote3"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener noreferrer">弹性盒子 - 学习 Web 开发 | MDN</a> </p>
</li>
<li id="footnote4"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexbox_%E7%BD%91%E6%A0%BC" target="_blank" rel="noopener noreferrer">网格 - 学习 Web 开发 | MDN</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js 笔记</title>
      <link>https://timpcfan.site/code/frontend/vue.html</link>
      <guid>https://timpcfan.site/code/frontend/vue.html</guid>
      <source url="https://timpcfan.site/rss.xml">Vue.js 笔记</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 03 Oct 2022 12:48:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>Vue (读音 /vjuː/，类似于  view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</div>
<div><p>注意</p>
<p>本笔记整理较为混乱，建议使用<a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">官方文档</a>学习。</p>
</div>
<h2 id="相关学习资源" tabindex="-1"> 相关学习资源</h2>
<ul>
<li>
<p><a href="https://v2.cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue2 文档</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue3 文档</a></p>
</li>
</ul>
<h2 id="vue-简介" tabindex="-1"> vue 简介</h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" alt="AYFU9u" loading="lazy"></p>
<p>官方给 vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称 vue 全家桶）</p>
<ul>
<li>vue（核心库）</li>
<li>vue-router（路由方案）</li>
<li>vuex（状态管理方案）</li>
<li>vue 组件库（快速搭建页面 UI 效果的方案）</li>
</ul>
<p>以及辅助 vue 项目开发的一系列工具：</p>
<ul>
<li>vue-cli（npm 全局包：一键生成工程化的 vue 项目 - 基于 webpack，大而全）</li>
<li>vite（npm 全局包：一键生成工程化的 vue 项目 - 小而巧）</li>
<li>vue-devtools（浏览器插件：辅助调试的工具）</li>
<li>vetur（vscode 插件：提供语法高亮和智能提示）</li>
</ul>
<h3 id="vue-的特性" tabindex="-1"> vue 的特性</h3>
<ul>
<li>数据驱动视图：
<ul>
<li>在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。</li>
<li>好处：当页面数据发生变化时，页面会自动重新渲染。</li>
<li>注：这是单向的数据绑定</li>
</ul>
</li>
<li>双向数据绑定
<ul>
<li>在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中。</li>
</ul>
</li>
</ul>
<h3 id="mvvm" tabindex="-1"> MVVM</h3>
<p>MVVM 是 vue 实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。它把每个 HTML 页面都拆分成了三个部分：</p>
<ul>
<li>View：当前页面所渲染的 DOM 结构</li>
<li>Model：当前页面渲染时所依赖的数据源</li>
<li>ViewModel：表示 vue 的实例，它是 MVVM 的核心，连接 View 与 Model</li>
</ul>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/mZ91S3.png" alt="mZ91S3" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/qF2xKn.png" alt="qF2xKn" loading="lazy"></p>
<h3 id="vue-的版本" tabindex="-1"> vue 的版本</h3>
<ul>
<li>2.x 版本是目前企业级项目开发中的主流版本</li>
<li>3.x 版本于 2020-09-19 发布，是未来企业级项目开发的趋势</li>
</ul>
<h3 id="_2-x-与-3-x-的对比" tabindex="-1"> 2.x 与 3.x 的对比</h3>
<ul>
<li>2.x 的绝大多数 API 在 3.x 中同样支持。</li>
<li>3.x 新增：组合式 API、多根节点组件、更好的 TypeScript 支持等</li>
<li>3.x 废弃：过滤器、不再支持$on，$off 和$once 实例方法等</li>
</ul>
<h2 id="vue-基础" tabindex="-1"> vue 基础</h2>
<p>渐进式 JavaScript 框架</p>
<h3 id="第一个-vue-程序" tabindex="-1"> 第一个 Vue 程序</h3>
<ol>
<li>导入开发版本的 Vue.js</li>
<li>创建 Vue 实例对象，设置 <code>el</code> 属性和 <code>data</code> 属性</li>
<li>使用简洁的模板语法把数据渲染到页面上</li>
</ol>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>基础</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>{</span><span>{</span> message <span>}</span><span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@next<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var vm = new Vue({
        el: "#app",
        data: {
          message: "Hello Vue!",
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="el-挂载点" tabindex="-1"> el：挂载点</h4>
<ul>
<li>Vue 实例的作用范围？
<ul>
<li>作用在 <code>el</code> 作用的元素内部（包括任意层次的子标签）</li>
</ul>
</li>
<li>其值可以使用其他选择器吗？
<ul>
<li>可以，css 选择器都可以，但建议使用 ID 选择器</li>
</ul>
</li>
<li>是否可以设置其他的 dom 元素
<ul>
<li>可以，但建议使用 div 标签，因为没有其他样式</li>
</ul>
</li>
</ul>
<h4 id="data-数据对象" tabindex="-1"> data：数据对象</h4>
<ul>
<li>Vue 中用到的数据定义在 <code>data</code> 中</li>
<li><code>data</code> 中可以写复杂类型的数据</li>
<li>渲染复杂类型的数据时，遵守 js 的语法即可</li>
</ul>
<h2 id="vue-指令" tabindex="-1"> vue 指令</h2>
<h3 id="v-text" tabindex="-1"> v-text</h3>
<blockquote>
<p>设置标签的文本值（textContent）</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>她说：{{ message }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>她说：{{ message+'???' }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span> <span>v-text</span><span><span>=</span><span>"</span>message<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span> <span>v-text</span><span><span>=</span><span>"</span>message+'???'<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>将标签中的文本，都使用 <code>data</code> 的指定属性替换。</p>
<p>可以在 v-text 中拼接字符串。</p>
<h3 id="v-html" tabindex="-1"> v-html</h3>
<blockquote>
<p>设置标签的 innerHTML</p>
</blockquote>
<p>与 <code>v-text</code> 类似，不过如果设置的文本为 html 内容会进行解析。</p>
<h3 id="v-on-基础" tabindex="-1"> v-on 基础</h3>
<blockquote>
<p>为元素绑定事件</p>
</blockquote>
<p>语法：<code>v-on:事件名=&quot;方法名&quot;</code> 或者 <code>@事件名=&quot;方法名&quot;</code></p>
<ul>
<li>方法定义在 Vue 对象的 <code>methods</code> 属性中。</li>
<li>方法内部通过 <code>this</code> 关键字可以访问定义在 <code>data</code> 中的数据</li>
<li>如果是直接将方法写在属性的位置，则不需要 <code>this.xxx</code></li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>method1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>method1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span><span>v-on:</span>monseenter</span><span><span>=</span><span>"</span>method2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span>@dblclick</span><span><span>=</span><span>"</span>message='点击啦'<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注</p>
<p>注：事件名不需要写 <code>on</code> 因为左侧 <code>v-on</code> 已经有了</p>
</div>
<div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>method1</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>"你好吗"</span><span>;</span>
    <span>}</span><span>,</span>
    <span>method2</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-show" tabindex="-1"> v-show</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>isShow<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>age>=18<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>isShow</span><span>:</span> <span>false</span><span>,</span>
    <span>age</span><span>:</span> <span>16</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-if" tabindex="-1"> v-if</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏（操纵 dom 元素）</p>
</blockquote>
<p>与 <code>v-show</code> 类似，但操纵的是 dom 元素（在 dom 中添加或删除该标签）</p>
<div><p>如何选择 `v-show` 还是 `v-if` ？</p>
<p>频繁切换的元素使用 <code>v-show</code> ，否则使用 <code>v-if</code></p>
</div>
<h3 id="v-else" tabindex="-1"> v-else</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div><p>注意</p>
<p>前一兄弟元素必须有  <code>v-if</code>  或  <code>v-else-if</code>。</p>
</div>
<h3 id="v-else-if" tabindex="-1"> v-else-if</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>type === 'A'<span>"</span></span><span>></span></span><span>
  A
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else-if</span><span><span>=</span><span>"</span>type === 'B'<span>"</span></span><span>></span></span><span>
  B
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else-if</span><span><span>=</span><span>"</span>type === 'C'<span>"</span></span><span>></span></span><span>
  C
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else</span><span>></span></span><span>
  Not A/B/C
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-bind" tabindex="-1"> v-bind</h3>
<blockquote>
<p>设置元素的属性（比如：src, title, class）</p>
</blockquote>
<p>语法：<code>v-bind:属性名=表达式</code> 或 <code>:属性名=表达式</code></p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>img</span> <span><span>v-bind:</span>src</span><span><span>=</span><span>"</span>imgSrc<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>imgtitle+'!!!'<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span>:class</span><span><span>=</span><span>"</span>isActive?'active':''<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span>:class</span><span><span>=</span><span>"</span>{active:isActive}<span>"</span></span> <span>/></span></span>
  <span>&lt;!-- 对象的写法：active 是否生效，取决于 isActive 的值 --></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>设置 <code>class</code> 属性时，建议使用对象的写法（第 4 个）</p>
</div>
<h3 id="v-for" tabindex="-1"> v-for</h3>
<blockquote>
<p>根据数据生成列表结构</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>item in arr<span>"</span></span> <span>:title</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>{{ item }}<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item, index) in arr<span>"</span></span><span>></span></span>{{ index }}{{ item }}<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>arr</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>当列表的数据变化时，默认情况下，vue 会尽可能地复用已存在的 DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会<strong>导致有状态的列表无法被正确更新</strong>。此时，需要为每项提供一个<strong>唯一</strong>的 key 属性（不能使用 index）：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>user in userlist<span>"</span></span> <span>:key</span><span><span>=</span><span>"</span>user.id<span>"</span></span><span>></span></span><span>
    </span><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>checkbox<span>"</span></span> <span>/></span></span><span>
    姓名：</span><span>{</span><span>{</span>user<span>.</span>name<span>}</span><span>}</span><span>
  </span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div>
<h3 id="v-on-补充" tabindex="-1"> v-on 补充</h3>
<blockquote>
<p>传递自定义参数，事件修饰符</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>method1(p1,p2)<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>@keyup.enter</span><span><span>=</span><span>"</span>sayHi<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>method1</span><span>:</span> <span>function</span> <span>(</span><span>p1<span>,</span> p2</span><span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>解释</strong></p>
<ul>
<li>可以在 v-on 的属性中传入函数的参数</li>
<li>对于事件，可以使用修饰符</li>
</ul>
<p><strong>修饰符</strong>（文档：<a href="https://v2.cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener noreferrer">https://v2.cn.vuejs.org/v2/api/#v-on</a>）</p>
<ul>
<li><code>.stop</code> - 调用  <code>event.stopPropagation()</code>。（阻止冒泡行为（内到外））</li>
<li><code>.prevent</code> - 调用  <code>event.preventDefault()</code>。（例如：阻止超链接的跳转）</li>
<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。（定义在外层组件上，以捕获的形式来触发事件（外到内））</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。（只有点他自己才会触发，而不受冒泡影响）</li>
<li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
<li><code>.once</code> - 只触发一次回调。</li>
<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>
<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>
<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>
<li><code>.passive</code> - (2.3.0) 以  <code>{ passive: true }</code>  模式添加侦听器</li>
</ul>
<h4 id="事件对象-event" tabindex="-1"> 事件对象 event</h4>
<p>在原生的 DOM 事件绑定中，可以在事件处理函数处，接收事件对象 event。同理，在 v-on 指令所绑定的事件处理函数中，同样可以接收到事件对象 event：</p>
<div><pre><code><span>&lt;</span>button @click<span>=</span><span>"addCount"</span><span>></span><span>+</span><span>1</span><span><span><span>&lt;/</span>button</span><span>></span></span>
<span>// ----------------------------------------------------</span>
<span>methods</span><span>:</span> <span>{</span>
  <span>addCount</span><span>(</span><span>e</span><span>)</span> <span>{</span> <span>// e 为事件对象</span>
    <span>const</span> color <span>=</span> e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor
    e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor <span>=</span> color <span>===</span> <span>'red'</span> <span>?</span> <span>''</span> <span>:</span> <span>'red'</span>
    <span>this</span><span>.</span>count <span>+=</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当传递参数时，event 对象将被覆盖掉，此时我们可以传递一个特殊的参数 <code>$event</code> 来表示原生的事件参数对象：</p>
<div><pre><code><span>&lt;</span>button @click<span>=</span><span>"addCount(step, $event)"</span><span>></span><span>+</span><span>1</span><span><span><span>&lt;/</span>button</span><span>></span></span>
<span>// ----------------------------------------------------</span>
<span>methods</span><span>:</span> <span>{</span>
  <span>addCount</span><span>(</span><span>step<span>,</span> e</span><span>)</span> <span>{</span> <span>// e 为事件对象</span>
    console<span>.</span><span>log</span><span>(</span>step<span>)</span>
    <span>const</span> color <span>=</span> e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor
    e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor <span>=</span> color <span>===</span> <span>'red'</span> <span>?</span> <span>''</span> <span>:</span> <span>'red'</span>
    <span>this</span><span>.</span>count <span>+=</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-model" tabindex="-1"> v-model</h3>
<blockquote>
<p>获取和设置表单元素的值（<strong>双向数据绑定</strong>）</p>
</blockquote>
<ul>
<li>绑定的是 <code>input</code> 的 <code>value</code> 属性</li>
<li>之后无论是在表单中直接修改元素，还是在 js 中修改绑定的变量，都会使得两边的值都被改变</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>message<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"lalala"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="vue-过滤器-vue2-x-内容" tabindex="-1"> vue 过滤器（vue2.x 内容）</h2>
<p>过滤器（Filters）常用于文本的格式化。例如：hello → Hello</p>
<p>过滤器应该被添加在 JavaScript 表达式的尾部，由“管道符”进行调用，示例代码如下：</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> message <span>|</span> capitalize <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span><span>v-bind:</span>id</span><span><span>=</span><span>"</span>rawId | formatId<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>过滤器可以用在两个地方：</p>
<ul>
<li>插值表达式（{{}}）</li>
<li>和 v-bind 属性绑定（:xxx）</li>
</ul>
<p>在创建 vue 实例期间，可以在 filters 节点中定义过滤器，示例代码：</p>
<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"hello vue.js"</span><span>,</span>
    <span>info</span><span>:</span> <span>"title info"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>filters</span><span>:</span> <span>{</span>
    <span>capitalize</span><span>(</span><span>str</span><span>)</span> <span>{</span>
      <span>return</span> str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>+</span> str<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="连续调用多个过滤器" tabindex="-1"> 连续调用多个过滤器</h3>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> text <span>|</span> capitalize <span>|</span> maxLength <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="过滤器传参" tabindex="-1"> 过滤器传参</h3>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> message <span>|</span> <span>filterA</span><span>(</span>arg1<span>,</span> arg2<span>)</span> <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

Vue<span>.</span><span>filter</span><span>(</span><span>'filterA'</span><span>,</span> <span>(</span><span>msg<span>,</span> arg1<span>,</span> arg2</span><span>)</span> <span>=></span> <span>{</span><span>...</span><span>}</span><span>)</span>  <span>// msg永远是第一个参数</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="版本兼容性" tabindex="-1"> 版本兼容性</h3>
<p>3.x 版本中取消掉了过滤器的特性，官方建议使用或<strong>方法</strong>代替之。</p>
<h2 id="vue-组件基础" tabindex="-1"> vue 组件基础</h2>
<p>如何创建 vite 项目：</p>
<h3 id="组件化开发思想" tabindex="-1"> 组件化开发思想</h3>
<div><p>相关信息</p>
<p>根据封装的思想，把页面上可重用的部分封装成组件，从而方便项目的开发和维护。</p>
</div>
<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。</p>
<h3 id="vue-组件的构成" tabindex="-1"> vue 组件的构成</h3>
<p>每个.vue 组件都由 3 部分构成，分别是：</p>
<ul>
<li>template → 组件的模板结构（必需）</li>
<li>script → 组件的 JavaScript 行为（可选）</li>
<li>style → 组件的样式（可选）</li>
</ul>
<h4 id="组件的-template-节点" tabindex="-1"> 组件的 template 节点</h4>
<p>在组件 <code>&lt;template&gt;</code> 节点中，支持使用 vue 指令，来辅助渲染当前组件的 DOM 结构。</p>
<div><p>注意</p>
<p>2.x 中，template 标签内仅支持单一根节点，3.x 中取消了该限制。</p>
</div>
<h4 id="组件的-script-节点" tabindex="-1"> 组件的 script 节点</h4>
<p>vue 规定：组件内 <code>&lt;script&gt;</code> 节点是可选的，开发者可以在 <code>&lt;script&gt;</code> 节点中封装组件的 JavaScript 业务逻辑。 <code>&lt;script&gt;</code> 节点的基本结构如下：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
// 今后，组件相关的 data 数据、methods 方法等，
// 都需要定义到 export default 所导出的对象中。
export default {
    name: 'MyApp', // name属性表示组件名称（建议首字母大写）
    data() {  // 组件中 data 需要指向一个函数，而不是一个对象！！
        return {
            username: 'lzt',
            count: 0,
        }
    },
    methods: {
        addCount() {
            this.count++;
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="组件中的-style-节点" tabindex="-1"> 组件中的 style 节点</h4>
<p>vue 规定：组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code> 节点中编写样式美化当前组件的 UI 结构。 <code>&lt;style&gt;</code> 节点的基本结构如下：</p>
<div><pre><code><span><span><span>&lt;</span>style</span> <span>lang</span><span><span>=</span><span>"</span>css<span>"</span></span><span>></span></span><span>
h1 {
    font-weight: normal;
}
</span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>也可以使用其他的语法，如 less 等，需要安装相应的依赖包：<code>npm install less -D</code></p>
</div>
<h3 id="组件的注册" tabindex="-1"> 组件的注册</h3>
<p>组件之间可以进行相互的引用，例如：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SieVd6.png" alt="SieVd6" loading="lazy"></p>
<p>vue 中组件的引用原则：先注册后使用。</p>
<h4 id="组件注册的两种方式" tabindex="-1"> 组件注册的两种方式</h4>
<p>vue 中注册组件的方式分为“全局注册”和“局部注册”两种，其中：</p>
<ul>
<li>全局注册：可以在全局任何一个组件内使用</li>
<li>局部注册：只能在当前注册的范围内使用</li>
</ul>
<h4 id="全局注册组件" tabindex="-1"> 全局注册组件</h4>
<div><pre><code><span>// main.js</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>// 1. 导入需要被全局注册的组件</span>
<span>import</span> Swiper <span>from</span> <span>"./components/01.globalReg/Swiper.vue"</span><span>;</span>
<span>import</span> Test <span>from</span> <span>"./components/01.globalReg/Test.vue"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

<span>// 2. 调用 app.compenent() 方法全局注册组件</span>
app<span>.</span><span>compenent</span><span>(</span><span>"my-swiper"</span><span>,</span> Swiper<span>)</span><span>;</span>
app<span>.</span><span>compenent</span><span>(</span><span>"my-test"</span><span>,</span> Test<span>)</span><span>;</span>

app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// App.vue</span>
<span>// 3. 在页面中使用上面定义的标签名</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>my-swiper</span><span>></span></span><span><span><span>&lt;/</span>my-swiper</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>my-test</span><span>></span></span><span><span><span>&lt;/</span>my-test</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="局部注册组件" tabindex="-1"> 局部注册组件</h4>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>my-search</span><span>></span></span><span><span><span>&lt;/</span>my-search</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
import MySearch from './compenents/MySearch.vue'
export default {
    compenents: {  // 通过 compenents 节点，为当前的组件注册私有子组件
        'my-search': MySearch,
        MySearch, // 也可以直接这样，这是使用大驼峰法命名
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="组件注册时的命名" tabindex="-1"> 组件注册时的命名</h4>
<ul>
<li>使用 kebab-case 命名法（短横线命名法，如 my-swiper ）
<ul>
<li>必须严格按照短横线名称进行使用</li>
</ul>
</li>
<li>使用 PascalCase 命名法（帕斯卡命名法或大驼峰法，如 MySwiper）
<ul>
<li>既可以严格按照帕斯卡名称使用，也可以转换成短横线名称使用</li>
</ul>
</li>
</ul>
<p>可以直接使用组件的.name 属性</p>
<div><pre><code><span>// main.js</span>
app<span>.</span><span>compenent</span><span>(</span>Swiper<span>.</span>name<span>,</span> Swiper<span>)</span><span>;</span> <span>// Swiper.name === 'MySwiper'</span>
app<span>.</span><span>compenent</span><span>(</span>Test<span>.</span>name<span>,</span> Test<span>)</span><span>;</span> <span>// Test.name === 'MyTest'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="组件之间样式冲突问题" tabindex="-1"> 组件之间样式冲突问题</h3>
<div><p>相关信息</p>
<p>若在父组件中定义样式，会影响到子组件的样式，这样就很容易造成多个组件之间的样式冲突问题。导致组件冲突问题的根本原因是：</p>
<ol>
<li>单页面应用程序中，所有组件的 DOM 结构，都是基于<strong>唯一的 index.html 页面</strong>进行呈现的</li>
<li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li>
</ol>
</div>
<h4 id="使用自定义属性解决样式冲突" tabindex="-1"> 使用自定义属性解决样式冲突</h4>
<p>为每个组件<strong>分配唯一的自定义属性</strong>，在编写组件样式时，通过<strong>属性选择器</strong>来控制<strong>样式的作用域</strong>：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span> <span>data-v-001</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h3</span> <span>data-v-001</span><span>></span></span><span>轮播图组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span>
  /* 通过中括号“属性选择器”，来防止组件之间的样式冲突问题 */
    .container[data-v-001] {
        border: 1px solid red;
    }
</span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="使用-scoped-属性解决样式冲突" tabindex="-1"> 使用 scoped 属性解决样式冲突</h4>
<p>手动分配自定义属性非常难以维护，可以使用 style 节点的 scoped 属性，vue 将自动分配自定义属性：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>轮播图组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span>&lt;</span>style <span>**</span>scoped<span>**</span><span>></span><span><span>
    <span>.container</span> <span>{</span>
        <span>border</span><span>:</span> 1px solid red<span>;</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="deep-样式穿透" tabindex="-1"> /deep/ 样式穿透</h4>
<p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。</p>
<div><pre><code><span>&lt;</span>style lang<span>=</span>"less scoped<span>></span><span><span>
<span>.title</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 不加 /deep/ 时，生成 .title[data-v-xxx] */</span>
<span>}</span>

<span>/deep/ .title</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 加上 /deep/ 时，生成 [data-v-xxx] .title */</span>
<span>}</span>

<span>:deep(.title)</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 这是3.x的推荐写法，生成 [data-v-xxx] .title */</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件的-props" tabindex="-1"> 组件的 props</h3>
<p>为了提高组件的复用性，在封装 vue 组件时需要遵守如下的规则：</p>
<ul>
<li>组件的<strong>DOM 结构</strong>、<strong>style 样式</strong>要尽量复用</li>
<li>组件中<strong>要展示的数据</strong>，尽量由组件的使用者提供</li>
</ul>
<div><p>相关信息</p>
<p>props 是组件的自定义属性，组件的使用者可以通过 props 把数据传递到子组件内部，供子组件内部进行使用。</p>
</div>
<p>例子：</p>
<div><pre><code><span><span><span>&lt;</span>my-article</span> <span>title</span><span><span>=</span><span>"</span>面朝大海，春暖花开<span>"</span></span> <span>author</span><span><span>=</span><span>"</span>海子<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>props 的<strong>作用</strong>：父组件通过 props<strong>向子组件传递要展示的数据</strong>。</p>
<p>props 的<strong>好处</strong>：提高了组件的<strong>复用性</strong>。</p>
<h4 id="在组件中声明-props" tabindex="-1"> 在组件中声明 props</h4>
<p>在封装 vue 组件时，可以把动态的数据项声明为 props 自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>标题：</span><span>{</span><span>{</span>title<span>}</span><span>}</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h5</span><span>></span></span><span>作者：</span><span>{</span><span>{</span>author<span>}</span><span>}</span><span><span><span>&lt;/</span>h5</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: ['title', 'author'], // 父组件传递给my-article组件的数据，必须在props节点中声明
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>props 中未声明的属性，如果传递会被忽视。</p>
</div>
<h4 id="动态绑定-props-的值" tabindex="-1"> 动态绑定 props 的值</h4>
<p>可以使用 v-bind 属性绑定的形式，为组件动态绑定 props 的值。</p>
<div><pre><code><span><span><span>&lt;</span>my-article</span> <span>:title</span><span><span>=</span><span>"</span>info.title<span>"</span></span> <span>author</span><span><span>=</span><span>"</span>info.author<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="props-的大小写命名" tabindex="-1"> props 的大小写命名</h4>
<p>组件中如果使用“camelCase（驼峰命名法）”声明了 props 属性的名称，则有两种方式为其绑定属性的值：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: ['**pubTime**'],
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>my-article</span> <span>pubTime</span><span><span>=</span><span>"</span>1989<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
<span><span><span>&lt;</span>my-article</span> <span>pub-time</span><span><span>=</span><span>"</span>1989<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="props-验证" tabindex="-1"> props 验证</h4>
<p>在分装组件时对外界传递过来的 props 数据进行合法性的校验，从而防止数据不合法的问题。使用对象类型的 props 节点，可以对每个 prop 进行数据类型的校验：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: {  // 使用对象类型的 props 而不是数组类型，若不按类型传递会在浏览器中警告
        p1: Number,
        p2: Boolean,
        p3: String,
        p4: Array,
        p5: Object,
        p6: Date,
        p7: Funciton,
        p8: Symbol,  // 共8种基础类型

        pA: [String, Number],  // 可以使用数组来指定多个可能的类型

        pB: { // 使用配置对象形式
            type: String,
            required: true // 当前属性为必填项
        },

        pC: {
            type: String,
            default: "lzt" // 当前属性的默认值
        },

        pD: {
            validator(value) {  // 自定义的验证函数，返回true代表合法
                return ['A', 'B', 'C'].indexOf(value) !== -1
            }
        }
    }
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="class-与-style-绑定" tabindex="-1"> Class 与 Style 绑定</h3>
<h4 id="以三元表达式绑定-html-的-class" tabindex="-1"> 以三元表达式绑定 HTML 的 class</h4>
<p>可以使用三元表达式，动态地为元素绑定 class 的类名。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>isItalic ? 'italic' : ''<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="以数组语法绑定-html-的-clas" tabindex="-1"> 以数组语法绑定 HTML 的 clas</h4>
<p>如果元素需要动态绑定多个 class 的类名，此时可以使用数组的语法格式。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>[isItalic ? 'italic' : '', isDelete ? 'delete' : '']<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="以对象语法绑定-html-的-class" tabindex="-1"> 以对象语法绑定 HTML 的 class</h4>
<p>推荐使用此方法绑定 class。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>{italic:isItalic}<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>:class</span><span><span>=</span><span>"</span>classObj<span>"</span></span><span>></span></span><span>how are you</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>isItalic</span><span>:</span> <span>true</span><span>,</span>
        <span>classObj</span><span>:</span> <span>{</span> <span>// 对象中，属性名是class名，值是布尔值</span>
            <span>italic</span><span>:</span> <span>true</span><span>,</span>  <span>// true代表应用这个类名</span>
            <span>delete</span><span>:</span> <span>false</span><span>,</span>  <span>// false代表不应用这个类名</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="以对象语法绑定内联的-style" tabindex="-1"> 以对象语法绑定内联的 style</h4>
<p><code>:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或短横线分隔（需要加引号）来命名：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>:style</span><span><span>=</span><span>"</span>{color: active, fontSize: fsize + 'px', 'background-color': bgcolor}<span>"</span></span><span>></span></span><span>
    lalala
</span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>active</span><span>:</span> <span>'red'</span><span>,</span>
        <span>fsize</span><span>:</span> <span>30</span><span>,</span>
        <span>bgcolor</span><span>:</span> <span>'pink'</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="计算属性" tabindex="-1"> 计算属性</h3>
<div><p>相关信息</p>
<p>计算属性本质上就是一个函数，它可以实时监听 data 中数据的变化，并 return 一个计算后的新值，供组件渲染 DOM 时使用。</p>
</div>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model.number</span><span><span>=</span><span>"</span>count<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span>count<span>}</span><span>}</span><span> 乘以 2 的值为：</span><span>{</span><span>{</span>plus<span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>1</span> <span>}</span>
<span>}</span><span>,</span>
<span>computed</span><span>:</span> <span>{</span>
    <span>plus</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>count <span>*</span> <span>2</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>调用时不需要加()，当作普通属性使用。</li>
<li>计算属性会缓存结果，只用依赖发生变化时才重新计算，因此性能比方法好。</li>
<li>使用场景：购物车金额等</li>
</ul>
<div><pre><code><span>computed</span><span>:</span> <span>{</span>
    <span>total</span><span>(</span><span>)</span> <span>{</span>
        <span>let</span> t <span>=</span> <span>0</span>
        <span>this</span><span>.</span>fruitlist<span>.</span><span>forEach</span><span>(</span><span>x</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span>x<span>.</span>state<span>)</span> <span>{</span>
                t <span>+=</span> x<span>.</span>count
            <span>}</span>
        <span>}</span><span>)</span>
        <span>return</span> t
    <span>}</span><span>,</span>
    <span>amount</span><span>(</span><span>)</span> <span>{</span>
        <span>let</span> a <span>=</span> <span>0</span>
        <span>this</span><span>.</span>fruitlist<span>.</span><span>filter</span><span>(</span><span>x</span> <span>=></span> x<span>.</span>state<span>)</span><span>.</span><span>forEach</span><span>(</span><span>x</span> <span>=></span> <span>{</span>
            a <span>+=</span> x<span>.</span>price <span>*</span> x<span>.</span>count
        <span>}</span><span>)</span>
        <span>return</span> a
    <span>}</span><span>,</span>
    <span>isDisabled</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>total <span>==</span> <span>0</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="自定义事件-子传父" tabindex="-1"> 自定义事件（子传父）</h3>
<div><p>相关信息</p>
<p>在封装组件时，为了让<strong>组件的使用者</strong>可以<strong>监听到组件内状态的变化</strong>，此时需要用到<strong>组件的自定义事件</strong>。</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/6LdgWa.png" alt="6LdgWa" loading="lazy"></p>
<h4 id="自定义事件的使用" tabindex="-1"> 自定义事件的使用</h4>
<p>在封装组件时：</p>
<ol>
<li><strong>声明</strong>自定义事件：定义自定义组件时，在 emits 节点中声明。</li>
<li><strong>触发</strong>自定义事件：</li>
</ol>
<p>在使用组件时：</p>
<ol>
<li><strong>监听</strong>自定义事件</li>
</ol>
<div><pre><code><span>// 组件定义</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>button</span><span>></span></span><span>press me</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    emits: ['change'],  // 1. 声明自定义事件
    methods: {
        onBtnClick() {
            this.$emit('change') // 2. 手动触发自定义事件，参数为自定义事件名称
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 使用组件</span>
<span>// 3. 使用v-on监听事件</span>
<span>&lt;</span>my<span>-</span>counter @change<span>=</span><span>"getCount"</span><span>></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

<span>methods</span><span>:</span> <span>{</span>
    <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'count changed!'</span><span>)</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="自定义事件传参" tabindex="-1"> 自定义事件传参</h4>
<p>在调用 <code>this.$emit()</code> 方法触发自定义事件时，可以通过<strong>第 2 个</strong>参数为自定义事件传参。</p>
<div><pre><code><span>// 组件定义</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>button</span><span>></span></span><span>press me</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    emits: ['change'],
    methods: {
        onBtnClick() {
            this.$emit('change', this.count) // 可以使用**第2个**参数来向外传递信息
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 使用组件</span>
<span>&lt;</span>my<span>-</span>counter @change<span>=</span><span>"getCount"</span><span>></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

<span>methods</span><span>:</span> <span>{</span>
    <span>getCount</span><span>(</span><span>val</span><span>)</span> <span>{</span> <span>// 这里可以得到传递的信息</span>
        console<span>.</span><span>log</span><span>(</span><span>'count changed'</span><span>,</span> val<span>)</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件上的-v-model" tabindex="-1"> 组件上的 v-model</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hQRD5V.png" alt="hQRD5V" loading="lazy"></p>
<p>v-model 是双向数据绑定指令，当需要<strong>维护组件内外数据的同步</strong>时，可以在组件上使用 v-model 指令。</p>
<hr>
<ul>
<li><strong>外界数据的变化</strong>会<strong>自动同步</strong>到 counter 组件中</li>
<li>counter 组件中数据的变化，也会<strong>自动同步到外界</strong>。</li>
</ul>
<h4 id="在组件上使用-v-model-的步骤" tabindex="-1"> 在组件上使用 v-model 的步骤</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xb4bel.png" alt="xb4bel" loading="lazy"></p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>父组件 --- count:</span><span>{</span><span>{</span> count <span>}</span><span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    &lt;button @click="count += 1">+1</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>hr</span> <span>/></span></span><span>
    &lt;MyCounter **v-model**:number="count"></span><span><span><span>&lt;/</span><span>MyCounter</span></span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span>
import MyCounter from "./MyCounter.vue";
export default {
  name: "Father",
  data() {
    return {
      count: 0,
    };
  },
  components: { MyCounter },
};
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>count值是：</span><span>{</span><span>{</span> number <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
    &lt;button @click="handleClick">-1</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>  // 注意子组件中并没有v-model
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
  name: "MyCounter",
  props: ["number"],
  emits: ["**update:**number"],
  methods: {
    handleClick() {
      this.$emit("update:number", this.number - 1);  // 可以通过 this.number 访问到 props 中的值
    },
  },
};
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p><code>update:xxx</code> 表示让 v-model 去更新 xxx 的值，为后面传递的参数</p>
</div>
<div><p>注意</p>
<p>此词条为 3.x 专属特性，请参考 <a href="https://cn.vuejs.org/guide/components/events.html#usage-with-v-model" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2 id="vue-组件高级" tabindex="-1"> vue 组件高级</h2>
<h3 id="watch-侦听器" tabindex="-1"> watch 侦听器</h3>
<div><p>相关信息</p>
<p>watch 侦听器允许开发者监视数据的变化，从而<strong>针对数据的变化做特定的操作</strong>。例如，监听用户名的变化并发起请求，判断用户名是否可用。</p>
</div>
<p>开发者需要在 watch 节点下，定义自己的侦听器。实例代码如下：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>username</span><span>:</span> <span>""</span> <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>watch</span><span>:</span> <span>{</span>
    <span>// 监听 username 的值的变化，</span>
    <span>// 形参列表中，第一个值是“变化后的新值”，第二个为“变化之前的旧值”</span>
    <span>username</span><span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>newVal<span>,</span> oldVal<span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用 object 的形式定义 watch，可以设置更多的选项：</p>
<ul>
<li>immediate 选项：组件加载完立即调用一次</li>
<li>deep 选项：当监听的是一个对象，对象的属性值变化都会被监听（若只想监听一个属性，则不需要使用 deep 选项，而是使用 ‘info.username’ 这样的形式作为监听的变量）</li>
</ul>
<div><pre><code><span>watch</span><span>:</span> <span>{</span>
    <span>username</span><span>:</span> <span>{</span>
        <span>async</span> <span>hander</span><span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>{</span>  <span>// handler 为处理方法</span>
            <span>const</span> <span>{</span> <span>data</span><span>:</span> res<span>}</span> <span>=</span> <span>await</span> axios<span>.</span><span>get</span><span>(</span><span><span>`</span><span>https://www.example.cn/api/</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            console<span>.</span><span>log</span><span>(</span>res<span>)</span>
        <span>}</span><span>,</span>
        <span>immediate</span><span>:</span> <span>true</span><span>;</span>  <span>// 表示组件加载完立即调用一次 watch 监听器</span>
    <span>}</span><span>,</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件的生命周期" tabindex="-1"> 组件的生命周期</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hEeD6v.png" alt="hEeD6v" loading="lazy"></p>
<p>组件的生命周期：组件从 <strong>创建</strong> → <strong>运行</strong>（渲染）→ <strong>销毁</strong> 的整个过程，强调的是一个时间段。</p>
<p>生命周期函数：</p>
<ol>
<li>created：当组件在内存中被创建完毕之后调用（唯一一次）</li>
<li>mounted：当组件被成功渲染到页面上之后调用（唯一一次）</li>
<li>unmounted：当组件被销毁完毕之后调用（例如 v-if 为 false）（唯一一次）</li>
<li>updated：组件被重新渲染（data 更新了）完毕之后调用（0 至多次）</li>
<li>beforeCreate 等：在上述周期之前执行。</li>
</ol>
<div><p>相关信息</p>
<p>在实际开发中，created 是最常用的，比如进行 ajax 请求数据。若需要操作 dom 元素，则需要使用 mounted，因为 created 时组件还未被渲染。</p>
</div>
<h3 id="组件之间的数据共享" tabindex="-1"> 组件之间的数据共享</h3>
<p>在项目开发中，组件之间的关系分为如下 3 种：</p>
<ol>
<li>父子关系</li>
<li>兄弟关系</li>
<li>后代关系</li>
</ol>
<h4 id="父子组件的数据共享" tabindex="-1"> 父子组件的数据共享</h4>
<p>父子组件之间的数据共享又分为：</p>
<ol>
<li>父 → 子</li>
<li>子 → 父</li>
<li>父 ↔  子</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/X1WYvK.png" alt="X1WYvK" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gRIHQf.png" alt="gRIHQf" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/TktxFT.png" alt="TktxFT" loading="lazy"></p>
<h4 id="兄弟组件的数据共享" tabindex="-1"> 兄弟组件的数据共享</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/DWEqdA.png" alt="DWEqdA" loading="lazy"></p>
<h5 id="_1-安装-mit" tabindex="-1"> 1. 安装 mit</h5>
<div><pre><code>npm install mitt <span>-</span><span>S</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h5 id="_2-创建公共的-eventbus-模块" tabindex="-1"> 2. 创建公共的 EventBus 模块</h5>
<p>在项目中创建公共的 eventBus 模块如下：</p>
<div><pre><code><span>// 创建一个文件 eventBus.js</span>

<span>import</span> mitt <span>from</span> <span>"mitt"</span><span>;</span>
<span>const</span> bus <span>=</span> <span>mitt</span><span>(</span><span>)</span><span>;</span>

<span>export</span> <span>default</span> bus<span>;</span> <span>// 把创建的EventBus的实例共享出去</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="_3-在数据接收方自定义事件" tabindex="-1"> 3. 在数据接收方自定义事件</h5>
<p>在数据接收方，调用 bus.on(’事件名称’, 事件处理函数） 方法注册一个自定义事件。</p>
<div><pre><code><span>import</span> bus <span>from</span> <span>'./eventBus.js'</span>

<span>export</span> <span>default</span> <span>{</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span> <span>return</span> <span>{</span><span>count</span><span>:</span> <span>0</span><span>}</span> <span>}</span><span>,</span>
    <span>created</span><span>(</span><span>)</span> <span>{</span>
        bus<span>.</span><span>on</span><span>(</span><span>'countChange'</span><span>,</span> <span>(</span><span>count</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>count <span>=</span> count<span>;</span>
        <span>}</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="_4-在数据发送方触发事件" tabindex="-1"> 4. 在数据发送方触发事件</h5>
<p>在数据发送方，调用 bus.emit(’事件名称’，要发送的数据) 方法触发自定义事件。</p>
<div><pre><code><span>import</span> bus <span>from</span> <span>"./eventBus.js"</span><span>;</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>addCount</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>count<span>++</span><span>;</span>
      bus<span>.</span><span>emit</span><span>(</span><span>"countChange"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="后代关系组件之间的数据共享" tabindex="-1"> 后代关系组件之间的数据共享</h4>
<p>可以使用 provide 和 inject 实现后代组件之间的数据共享。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5QQbjj.png" alt="5QQbjj" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dM8Wma.png" alt="dM8Wma" loading="lazy"></p>
<p>上述的方法不是响应式的，改变了父组件的值，子孙组件没有变化，要使用 computed 函数修改：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WLpXE4.png" alt="WLpXE4" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gPCKax.png" alt="gPCKax" loading="lazy"></p>
<h4 id="vuex——终极的组件之间数据共享方案" tabindex="-1"> vuex——终极的组件之间数据共享方案</h4>
<p>vuex 可以让组件之间的数据共享变得高效、清晰、且易于维护。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/0HtmYq.png" alt="0HtmYq" loading="lazy"></p>
<p>创建一个共享的 store，存取数据都通过 store，实现不同组件之间的数据共享。</p>
<h3 id="vue3-x-中全局配置-axios" tabindex="-1"> vue3.x 中全局配置 axios</h3>
<h4 id="为什么要全局配置-axios" tabindex="-1"> 为什么要全局配置 axios？</h4>
<ol>
<li>每个组件中都需要导入 axios 包（代码臃肿）</li>
<li>没吃发请求都需要填写完整的请求路径（不利于后期的维护）</li>
</ol>
<h4 id="如何全局配置-axios" tabindex="-1"> 如何全局配置 axios？</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CwAmsY.png" alt="CwAmsY" loading="lazy"></p>
<div><pre><code><span>// main.js</span>

<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>
<span>import</span> <span>"./index.css"</span><span>;</span>

<span>import</span> axios <span>from</span> <span>"axios"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>"https://timpcfan.site"</span><span>;</span>
app<span>.</span>config<span>.</span>globalProperties<span>.</span>$http <span>=</span> axios<span>;</span> <span>// 这里的 $http 为自己取的名字，可以在组件中通过 this.$http 访问**</span>

app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="ref-的使用" tabindex="-1"> ref 的使用</h3>
<p>ref 是用于辅助开发者获得 DOM 元素或者组件的引用的。（不建议使用 jQuery 获取 DOM 元素，建议使用 ref）</p>
<h4 id="使用-ref-获取-dom-元素" tabindex="-1"> 使用 ref 获取 DOM 元素</h4>
<p>vue 在每个组件的引用中(this)都添加了一个<code>$refs</code>的属性，这个属性默认指向一个空对象，若开发者需要获取某个 DOM 元素，可以为该 DOM 元素添加属性 <code>ref=”name1”</code>，则可以使用 <code>this.$refs.name1</code> 获取该 DOM 元素的引用。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span> <span>ref</span><span><span>=</span><span>"</span>myh1<span>"</span></span><span>></span></span><span>lalala</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    methods: {
        getRefs() {
            console.log(this.$refs.myh1);
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="使用-ref-引用组件实例" tabindex="-1"> 使用 ref 引用组件实例</h4>
<div><pre><code><span>&lt;</span><span>!</span><span>--</span> 给组件添加属性 ref <span>--</span><span>></span>
<span><span><span>&lt;</span>my-counter</span> <span>ref</span><span><span>=</span><span>"</span>counterRef<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$refs<span>.</span>counterRef<span>)</span><span>;</span>
<span>this</span><span>.</span>$refs<span>.</span>counterRef<span>.</span><span>add</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="要引用的对象还没有渲染怎么办-使用-nexttick-callback-方法" tabindex="-1"> 要引用的对象还没有渲染怎么办？使用 $.nextTick(callback) 方法</h4>
<p>组件的 <code>$nextTick(cb)</code> 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>inputVisible<span>"</span></span> <span>ref</span><span><span>=</span><span>"</span>ipt<span>"</span></span><span>></span></span><span>
&lt;button v-else @click="showInput">展示input输入框</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>

methods: </span><span>{</span>
    <span>showInput</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>inputVisible <span>=</span> <span>true</span><span>;</span>
        <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>$refs<span>.</span>ipt<span>.</span><span>focus</span><span>(</span><span>)</span><span>;</span> <span>// 若不使用 $nextTick 则找不到这个 ipt</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span><span>
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="动态组件" tabindex="-1"> 动态组件</h3>
<div><p>相关信息</p>
<p>动态组件指的是动态切换组件的显示和隐藏。vue 提供了一个内置的<code>&lt;component&gt;</code> 组件，专门用来实现组件的动态渲染。</p>
</div>
<ol>
<li><code>&lt;component&gt;</code> 是组件的占位符</li>
<li>通过 is 属性动态指定要渲染的组件名称</li>
<li><code>&lt;component is=”要渲染的组件的名称”&gt;&lt;/component&gt;</code></li>
</ol>
<h4 id="使用-keep-alive-保持组件状态" tabindex="-1"> 使用 keep-alive 保持组件状态</h4>
<p>使用<code>&lt;component&gt;</code>时，若切换成其他组件，则原本的组件将会被销毁，其状态无法保持，可以使用<code>&lt;keep-alive&gt;</code>标签将<code>&lt;component&gt;</code>进行包裹，以保持切换走的组件的状态。</p>
<div><pre><code><span><span><span>&lt;</span>keep-alive</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>component</span> <span>:is</span><span><span>=</span><span>"</span>comName<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>keep-alive</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="插槽" tabindex="-1"> 插槽</h3>
<div><p>相关信息</p>
<p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望用户指定的部分</strong>定义为插槽。</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/vZewR9.png" alt="vZewR9" loading="lazy"></p>
<p>可以把插槽认为是组件封装期间，为用户预留的<strong>内容的占位符</strong>。</p>
<h4 id="插槽的基础用法" tabindex="-1"> 插槽的基础用法</h4>
<p>在封装组件时，可以通过<code>&lt;slot&gt;</code>元素定义插槽，在使用时组件标签包裹的内容将会插入到插槽中。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是组件MyCom1的第一个p标签</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>slot</span><span>></span></span><span><span><span>&lt;/</span>slot</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是组件MyCom1的第二个p标签</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span><span>MyCom1</span></span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是用户自定义的内容</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
</span><span><span><span>&lt;/</span><span>MyCom1</span></span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>若没有定义插槽，则组件包裹的任何内容都会被丢弃。</p>
</div>
<h4 id="插槽的后备内容" tabindex="-1"> 插槽的后备内容</h4>
<p>通过<code>&lt;slot&gt;</code>元素定义插槽时，可以在其中定义后备内容，若用户未提供自定义内容，则显示后备内容。</p>
<h4 id="具名插槽" tabindex="-1"> 具名插槽</h4>
<p>如果在封装组件时需要预留多个插槽节点，则需要为每个<code>&lt;slot&gt;</code>插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/nWdPi4.png" alt="nWdPi4" loading="lazy"></p>
<div><p>相关信息</p>
<p>没有 name 名称的插槽会有隐含的名称叫做“default”</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/eGacvB.png" alt="eGacvB" loading="lazy"></p>
<div><p>相关信息</p>
<p><code>v-slot:</code>可以简写为<code>#</code>，即<code>v-slot:header</code> → <code>#header</code></p>
</div>
<h4 id="作用域插槽" tabindex="-1"> 作用域插槽</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/I0YDN5.png" alt="I0YDN5" loading="lazy"></p>
<p>省略了插槽的 props 属性的介绍，有缘再见吧。</p>
<h3 id="自定义指令" tabindex="-1"> 自定义指令</h3>
<p>vue 官方提供了 v-for, v-model 等常用的内置指令。除此之外，vue 还允许开发者自定义指令。</p>
<p>我想省略了 orz。</p>
<h2 id="vue-路由" tabindex="-1"> vue 路由</h2>
<h3 id="前端路由的概念与原理" tabindex="-1"> 前端路由的概念与原理</h3>
<p>路由就是<strong>对应关系</strong>。路由分为两大类：</p>
<ol>
<li>后端路由：后端路由指的是<strong>请求方法、请求地址</strong>与<strong>function 处理函数</strong>之间的<strong>对应关系</strong>。</li>
<li>前端路由：前端路由指的是<strong>Hash 地址</strong>与<strong>组件</strong>之间的<strong>对应关系</strong>。</li>
</ol>
<div><p>相关信息</p>
<p>在 SPA 中，web 网站只有唯一的一个 HTML 页面，<strong>所有组件的展示与切换</strong>都在这为一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</div>
<h4 id="前端路由的工作方式" tabindex="-1"> 前端路由的工作方式</h4>
<ol>
<li>用户点击了页面上的路由地址</li>
<li>导致了 URL 地址栏中的 Hash 值发生了变化</li>
<li>前端路由监听到了 Hash 地址的变化</li>
<li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HbwSnR.png" alt="HbwSnR" loading="lazy"></p>
<h4 id="实现简易的前端路由" tabindex="-1"> 实现简易的前端路由</h4>
<ol>
<li>导入并注册 MyHome、MyMovie、MyAbout 三个组件：</li>
</ol>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>components</span><span>:</span> <span>{</span>
    MyHome<span>,</span>
    MyMovie<span>,</span>
    MyAbout<span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>通过<code>&lt;component&gt;</code>标签的 is 属性，动态切换要显示的组件：</li>
</ol>
<div><pre><code><span><span><span>&lt;</span>component</span> <span>:is</span><span><span>=</span><span>"</span>comName<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>comName</span><span>:</span> <span>'my-home'</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li>在组件的结构中声明如下 3 个<code>&lt;a&gt;</code>连接，通过点击不同的<code>&lt;a&gt;</code>连接，切换浏览器地址栏中的 Hash 值：</li>
</ol>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/home<span>"</span></span><span>></span></span><span>Home</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/movie<span>"</span></span><span>></span></span><span>Movie</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/about<span>"</span></span><span>></span></span><span>About</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="4">
<li>在 created 生命周期函数中监听浏览器地址栏中 Hash 地址的变化，动态切换要展示的组件的名称：</li>
</ol>
<div><pre><code><span>created</span><span>(</span><span>)</span> <span>{</span>
    window<span>.</span><span>onhashchange</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>switch</span> <span>(</span>location<span>.</span>hash<span>)</span> <span>{</span>
            <span>case</span> <span>'#/home'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-home'</span><span>,</span>
                <span>break</span>
            <span>case</span> <span>'#/movie'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-movie'</span><span>,</span>
                <span>break</span>
            <span>case</span> <span>'#/about'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-about'</span><span>,</span>
                <span>break</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="vue-router-的基本使用" tabindex="-1"> vue-router 的基本使用</h3>
<div><p>相关信息</p>
<p>vue-router 是 vue 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p>
</div>
<ul>
<li>vue-router 3.x：对应 vue2.x ：<a href="https://router.vuejs.org/zh" target="_blank" rel="noopener noreferrer">https://router.vuejs.org/zh</a></li>
<li>vue-router 4.x：对应 vue 3.x ：<a href="https://next.router.vuejs.org" target="_blank" rel="noopener noreferrer">https://next.router.vuejs.org</a></li>
</ul>
<h4 id="vue-router4-x-的基本使用步骤" tabindex="-1"> vue-router4.x 的基本使用步骤</h4>
<ul>
<li>
<p><strong>在项目中安装 vue-router</strong></p>
<div><pre><code>npm install vue<span>-</span>router@next <span>-</span><span>S</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong>定义路由组件</strong>
就是定义自己的组件，如 MyHome.vue, MyMovie.vue, MyAbout.vue</p>
</li>
<li>
<p><strong>声明路由链接与占位符</strong>
可以使用<code>&lt;router-link&gt;</code>标签来声明路由链接，并使用<code>&lt;router-view&gt;</code>标签来声明路由占位符。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> App 组件 </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
  &lt;!-- 声明路由链接 -->
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/home<span>"</span></span><span>></span></span><span>首页</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span> &lt;!-- 不需要加井号啦 -->
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/movie<span>"</span></span><span>></span></span><span>电影</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span><span>关于</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>

  &lt;!-- 声明路由占位符 -->
  </span><span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>创建路由模块</strong>
在项目中创建 router.js 路由模块，在其中按照如下 4 个步骤创建并得到路由的实例对象：</p>
<ol>
<li>从 vue-router 中按需导入两个方法</li>
<li>导入需要使用路由控制的组件</li>
<li>创建路由实例对象</li>
<li>向外共享路由实例对象</li>
<li>在 main.js 中导入并挂载路由模块</li>
</ol>
<div><pre><code><span>import</span> <span>{</span> createRouter<span>,</span> createWebHashHistory <span>}</span> <span>from</span> <span>'vue-router'</span>  <span>// 1.</span>

<span>import</span> MyHome <span>from</span> <span>'./MyHome.vue'</span>  <span>// 2.</span>
<span>import</span> MyMovie <span>from</span> <span>'./MyMovie.vue'</span>
<span>import</span> MyAbout <span>from</span> <span>'./MyAbout.vue'</span>

<span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>  <span>// 3.</span>
  <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
  <span>routes</span><span>:</span> <span>[</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>

<span>export</span> <span>default</span> router<span>;</span>  <span>// 4.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>导出并挂载路由模块</p>
<div><pre><code><span>// main.js</span>
<span>// ...</span>
<span>import</span> router <span>from</span> <span>"./router"</span><span>;</span>
<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>)</span><span>;</span> <span>// 5.</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<h3 id="vue-router-的高级用法" tabindex="-1"> vue-router 的高级用法</h3>
<h4 id="路由重定向" tabindex="-1"> 路由重定向</h4>
<div><p>相关信息</p>
<p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C，从而展示特定的组件页面。</p>
</div>
<p>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>  <span>// 3.</span>
    <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
    <span>routes</span><span>:</span> <span>[</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="为激活的路由链接设置高亮样式" tabindex="-1"> 为激活的路由链接设置高亮样式</h4>
<ol>
<li>
<p><strong>默认的高亮 class 类</strong>：被激活的路由链接，默认会应用一个叫做 router-link-active 的类名。开发者可以使用此类名选择器，为激活的路由链接设置高亮样式：</p>
<div><pre><code><span>/* index.css */</span>
<span>.router-link-active</span> <span>{</span>
  <span>background-color</span><span>:</span> red<span>;</span>
  <span>color</span><span>:</span> white<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>自定义路由高亮的 class 类</strong>：开发者可以基于 linkActiveClass 属性，自定义路由链接被激活时所应用的类名：</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>
 <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
 <span>linkActiveClass</span><span>:</span> <span>'router-active'</span><span>,</span>
 <span>routes</span><span>:</span> <span>[</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h4 id="嵌套路由" tabindex="-1"> 嵌套路由</h4>
<p>通过路由实现组件的嵌套展示，叫做嵌套路由。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/um5ec9.png" alt="um5ec9" loading="lazy"></p>
<ol>
<li>
<p>声明子路由链接和子路由占位符（声明在子组件内部即可）</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>MyAbout 组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>

    </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about/tab1<span>"</span></span><span>></span></span><span>Tab1</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about/tab2<span>"</span></span><span>></span></span><span>Tab2</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>

    </span><span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>在父路由规则中，通过 children 属性嵌套声明子路由规则</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>
 <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
 <span>linkActiveClass</span><span>:</span> <span>'router-active'</span><span>,</span>
 <span>routes</span><span>:</span> <span>[</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
     <span>{</span>
         <span>path</span><span>:</span> <span>'/about'</span><span>,</span>
         <span>component</span><span>:</span> MyAbout<span>,</span>
         <span>**</span>redirect<span>:</span> <span>'/about/tab1'</span><span>,</span><span>**</span> <span>// 访问 /about 时就直接显示 tab1</span>
         <span>**</span>children<span>:</span> <span>[</span>
             <span>{</span> <span>path</span><span>:</span> <span>'tab1'</span><span>,</span> <span>component</span><span>:</span> Tab1 <span>}</span><span>,</span><span>**</span> <span>// 访问 /about/tab1 时展示 Tab1</span>
             <span>**</span><span>{</span> <span>path</span><span>:</span> <span>'tab2'</span><span>,</span> <span>component</span><span>:</span> Tab2 <span>}</span><span>,</span>
         <span>]</span><span>,</span><span>**</span>
     <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h4 id="动态路由匹配" tabindex="-1"> 动态路由匹配</h4>
<div><p>相关信息</p>
<p>动态路由指的是：把 Hash 地址中的<strong>可变部分</strong>定义为<strong>参数项</strong>，从而提高路由规则的可复用性。</p>
</div>
<p>在 vue-router 中使用英文的冒号（:）来定义路由的参数：</p>
<div><pre><code><span>{</span> <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>

<span>{</span> <span>path</span><span>:</span> <span>'/movie/1'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
<span>{</span> <span>path</span><span>:</span> <span>'/movie/2'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
<span>{</span> <span>path</span><span>:</span> <span>'/movie/3'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>使用 <code>$route.params</code> 对象获取动态匹配的参数值。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> id：</span><span>{</span><span>{</span> $route<span>.</span>params<span>.</span>id <span>}</span><span>}</span><span> </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用 <code>props</code> 接收路由参数，需要在路由规则中开启：</p>
<div><pre><code><span>{</span> <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span> <span>component</span><span>:</span> Movie<span>,</span> <span>**</span>props<span>:</span> <span>true</span><span>**</span> <span>}</span>

<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> id：</span><span>{</span><span>{</span> id <span>}</span><span>}</span><span> </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span>export</span> <span>default</span> <span>{</span>
    <span>name</span><span>:</span> <span>'MyMovie'</span><span>,</span>
    <span>props</span><span>:</span> <span>[</span><span>'id'</span><span>]</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="编程式导航" tabindex="-1"> 编程式导航</h4>
<div><p>相关信息</p>
<p>编程式导航 vs 声明式导航：通过调用 API（调用 location.href）实现导航的方式叫做编程式导航，而通过点击链接（a 标签）实现导航的方式称为声明式导航。</p>
</div>
<p><strong>vue-router 中的编程式导航 API</strong></p>
<ul>
<li>this.$router.push(’hash 地址’)：跳转到指定的 hash 地址</li>
<li>this.$router.go(数值 n)：实现导航历史的前进、后退（-1）</li>
</ul>
<div><pre><code><span>gotoMovie</span><span>(</span><span>id</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>$router<span>.</span><span>push</span><span>(</span><span><span>`</span><span>/movie/</span><span><span>${</span>id<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h4 id="命名路由" tabindex="-1"> 命名路由</h4>
<p>通过 name 属性为路由规则定义名称的方式，叫做命名路由：</p>
<div><pre><code><span>{</span>
    <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span>
    <span>name</span><span>:</span> <span>'mov'</span><span>,</span>
    <span>component</span><span>:</span> Movie<span>,</span>
    <span>props</span><span>:</span> <span>true</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：命名路由的 name 值不能重复。</p>
<p>使用命名路由可以在<code>&lt;router-link&gt;</code>中直接使用其名称，而不用显示地写 hash 地址：</p>
<div><pre><code><span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>"</span>{ name: 'mov', params: { id: 3 } }<span>"</span></span><span>></span></span><span>go to Movie</span><span><span><span>&lt;/</span>router-link</span><span>></span></span>

<span>this</span><span>.</span>$router<span>.</span><span>push</span><span>(</span><span>{</span>
    <span>name</span><span>:</span> <span>'mov'</span><span>,</span>
    <span>params</span><span>:</span> <span>{</span> <span>id</span><span>:</span> <span>3</span> <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="导航守卫" tabindex="-1"> 导航守卫</h4>
<p>导航守卫可以控制路由的访问权限。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/iSrYhO.png" alt="iSrYhO" loading="lazy"></p>
<h3 id="如何声明全局导航守卫" tabindex="-1"> 如何声明全局导航守卫</h3>
<p><strong>全局导航守卫</strong>会<strong>拦截每个路由规则</strong>，从而对每个路由进行<strong>访问权限</strong>的控制。可以按照如下的方式定义全局导航守卫：</p>
<div><pre><code><span>// 创建路由实例对象</span>
<span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span> <span>...</span> <span>}</span><span>)</span>

<span>// 调用路由实例对象的 beforeEach 函数，声明“全局前置守卫”</span>
<span>// fn 必须是一个函数，每次拦截到路由的请求，都会调用 fn 进行处理</span>
<span>// 因此 fn 叫做 “守卫方法”</span>
router<span>.</span><span>beforeEach</span><span>(</span>fn<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="守卫方法的-3-个参数" tabindex="-1"> 守卫方法的 3 个参数</h4>
<p>全局导航守卫的守卫方法中接收 3 个形参，格式为：</p>
<div><pre><code>router<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>// to 目标路由对象</span>
  <span>// from 当前导航要离开的路由对象</span>
  <span>// next 时一个函数，表示放行</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>如果不接收第 3 个形参，则默认允许用户访问每一个路由。如果接收了 next 形参，则必须调用 next()函数，否则不允许用户访问该路由。</p>
</div>
<p>next 函数的 3 种调用方式：</p>
<ul>
<li>直接放行：next()</li>
<li>强制其停留在当前页面：next(false)</li>
<li>强制其跳转到登录页面：next(’/login’)</li>
</ul>
<h4 id="结合-token-控制后台主页的访问权限" tabindex="-1"> 结合 token 控制后台主页的访问权限</h4>
<div><pre><code>router<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> token <span>=</span> localStorage<span>.</span><span>getItem</span><span>(</span><span>"token"</span><span>)</span><span>;</span> <span>// 1. 读取 token</span>
  <span>if</span> <span>(</span>to<span>.</span>path <span>===</span> <span>"/main"</span> <span>&amp;&amp;</span> <span>!</span>token<span>)</span> <span>{</span>
    <span>// 2. 想要访问“后台主页”，且 token 不存在</span>
    <span>// next(false);  // 3.1 不允许跳转</span>
    <span>next</span><span>(</span><span>"/login"</span><span>)</span><span>;</span> <span>// 3.2 强制跳转到“登录页面”</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>next</span><span>(</span><span>)</span><span>;</span> <span>// 3.3 直接放行，允许访问“后台主页”</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="vue-项目的创建" tabindex="-1"> vue 项目的创建</h2>
<h3 id="如何快速创建-vue-的-spa-项目" tabindex="-1"> 如何快速创建 vue 的 SPA 项目</h3>
<ol>
<li>基于 vite 创建 SPA 项目
<ul>
<li>仅支持 3.x</li>
<li>不基于 webpack</li>
<li>速度快</li>
<li>小而巧</li>
</ul>
</li>
<li>给予 vue-cli 创建 SPA 项目
<ul>
<li>支持 2.x 与 3.x</li>
<li>基于 webpack</li>
<li>较慢</li>
<li>大而全</li>
</ul>
</li>
</ol>
<div><pre><code><span>npm</span> init vite-app code1  <span># 创建一个vite项目，命名为code1</span>
<span>cd</span> code1
<span>npm</span> <span>install</span>  <span># 安装依赖包</span>
<span>npm</span> run dev  <span># 启动项目</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="vite-的基本使用" tabindex="-1"> vite 的基本使用</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/ZG3kP3.png" alt="ZG3kP3" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yITax7.png" alt="yITax7" loading="lazy"></p>
<h4 id="vite-项目的运行流程" tabindex="-1"> vite 项目的运行流程</h4>
<p>在工程化的项目中，vue 要做的事情很单纯：通过 <code>main.js</code> 把 <code>App.vue</code> 渲染到 <code>index.html</code> 的指定区域中。</p>
<p>其中：</p>
<ol>
<li><code>App.vue</code> 用来编写待渲染的模板结构</li>
<li><code>index.html</code> 中需要预留一个 <code>el</code> 区域</li>
<li><code>main.js</code> 把 <code>App.vue</code> 渲染到了 <code>index.html</code> 所预留的区域中</li>
</ol>
<h4 id="app-vue" tabindex="-1"> App.vue</h4>
<div><pre><code><span>// 需要使用&lt;template>标签把组件包围</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>hello world</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h4 id="main-js" tabindex="-1"> main.js</h4>
<div><pre><code><span>// 1. 按需导入 createApp 函数</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>// 2. 导入待渲染的 App.vue 组件</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>// 3. 调用 createApp 函数，创建 SPA 应用的实例</span>
<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

<span>// 4. 调用 mount() 把 App 组件的模版结构，渲染到指定的 el 区域中</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><a href="/code/frontend/vue_todos.html">Todos - Vite 项目案例</a></p>
<h3 id="vue-cli-的使用" tabindex="-1"> vue-cli 的使用</h3>
<p><a href="http://cli.vuejs.org/zh" target="_blank" rel="noopener noreferrer">Vue CLI</a></p>
<h4 id="基于-vue-ui-创建-vue-项目" tabindex="-1"> 基于 vue ui 创建 vue 项目</h4>
<ol>
<li>运行 <code>vue ui</code> 命令，自动在浏览器中打开创建项目的可视化面板。</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CALMwI.png" alt="CALMwI" loading="lazy"></p>
<ol start="2">
<li>填写项目名称</li>
<li>在预设页面选择手动配置项目</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHZnib.png" alt="xHZnib" height="300" loading="lazy"></p>
<ol start="4">
<li>在功能页面勾选需要安装的功能</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/rwl84Y.png" alt="rwl84Y" loading="lazy"></p>
<ol start="5">
<li>在配置页面勾选 vue 的版本和需要的预处理器</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/cl0cMR.png" alt="cl0cMR" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WSUYun.png" alt="WSUYun" loading="lazy"></p>
<h4 id="基于命令行创建-vue-项目" tabindex="-1"> 基于命令行创建 vue 项目</h4>
<div><pre><code>vue create my<span>-</span>project
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="vue-组件库" tabindex="-1"> vue 组件库</h2>
<h3 id="什么是-vue-组件库" tabindex="-1"> 什么是 vue 组件库</h3>
<p>在实际开发中，前端开发者可以把自己封装的.vue 组件整理、打包、并发布为 npm 的包，从而供其他人下载和使用。这种可以直接下载并在项目中使用的现成组件，就叫做 vue 组件库。</p>
<h3 id="vue-组件库与-bootstrap-的区别" tabindex="-1"> vue 组件库与 bootstrap 的区别</h3>
<ul>
<li>bootstrap 只提供了纯粹的原材料（css 样式、HTML 结构以及 JS 特效），需要由开发者做进一步的组装和改造。</li>
<li>vue 组件库是遵循 vue 语法、高度定制的现成组件，开箱即用的。</li>
</ul>
<h3 id="最常用的-vue-组件库" tabindex="-1"> 最常用的 vue 组件库</h3>
<ul>
<li>PC 端
<ul>
<li>Element UI</li>
<li>View UI</li>
</ul>
</li>
<li>移动端
<ul>
<li>Mint UI</li>
<li>Vant</li>
</ul>
</li>
</ul>
<h3 id="element-ui" tabindex="-1"> Element UI</h3>
<div><p>提示</p>
<p>是由饿了么前端团队开源的一套 PC 端 vue 组件库。</p>
</div>
<ul>
<li>vue2 使用旧版的 Element UI</li>
<li>vue3 使用新版的 <a href="https://element-plus.gitee.io/zh-CN/guide/design.html" target="_blank" rel="noopener noreferrer">Element Plus</a></li>
</ul>
<h4 id="安装" tabindex="-1"> 安装</h4>
<div><pre><code>npm install element<span>-</span>plus <span>--</span>save
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="引入-element-ui" tabindex="-1"> 引入 element-ui</h4>
<ul>
<li>完整引入：操作简单，但体积过大</li>
<li>按需引入：操作复杂，优化体积</li>
</ul>
<h5 id="完整引入" tabindex="-1"> 完整引入</h5>
<div><pre><code><span>// main.ts</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> ElementPlus <span>from</span> <span>"element-plus"</span><span>;</span>
<span>import</span> <span>"element-plus/dist/index.css"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span>ElementPlus<span>)</span><span>;</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="按需引入" tabindex="-1"> 按需引入</h5>
<p>自动导入（推荐）</p>
<div><pre><code>npm install <span>-</span><span>D</span> unplugin<span>-</span>vue<span>-</span>components unplugin<span>-</span>auto<span>-</span><span>import</span>

<span>// webpack.config.js</span>
<span>const</span> AutoImport <span>=</span> <span>require</span><span>(</span><span>'unplugin-auto-import/webpack'</span><span>)</span>
<span>const</span> Components <span>=</span> <span>require</span><span>(</span><span>'unplugin-vue-components/webpack'</span><span>)</span>
<span>const</span> <span>{</span> ElementPlusResolver <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'unplugin-vue-components/resolvers'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// ...</span>
  <span>plugins</span><span>:</span> <span>[</span>
    <span>AutoImport</span><span>(</span><span>{</span>
      <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
    <span>}</span><span>)</span><span>,</span>
    <span>Components</span><span>(</span><span>{</span>
      <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
    <span>}</span><span>)</span><span>,</span>
  <span>]</span><span>,</span>
<span>}</span>

<span>**</span><span>// 或者对于vue-cli项目，修改vue.config.js**</span>
<span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"@vue/cli-service"</span><span>)</span><span>;</span>

<span>const</span> AutoImport <span>=</span> <span>require</span><span>(</span><span>"unplugin-auto-import/webpack"</span><span>)</span><span>;</span>
<span>const</span> Components <span>=</span> <span>require</span><span>(</span><span>"unplugin-vue-components/webpack"</span><span>)</span><span>;</span>
<span>const</span> <span>{</span> ElementPlusResolver <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"unplugin-vue-components/resolvers"</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>configureWebpack</span><span>:</span> <span>{</span>
    <span>plugins</span><span>:</span> <span>[</span>
      <span>AutoImport</span><span>(</span><span>{</span>
        <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
      <span>}</span><span>)</span><span>,</span>
      <span>Components</span><span>(</span><span>{</span>
        <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
      <span>}</span><span>)</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>手动导入（不推荐就不写啦）</p>
<h2 id="axios-vue" tabindex="-1"> axios+vue</h2>
<ul>
<li>axios 回调函数中的 <code>this</code> 已经改变，无法访问到 <code>data</code> 中数据</li>
<li>把 <code>this</code> 保存起来，回调函数中直接使用保存的 <code>this</code> 即可</li>
</ul>
<div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>joke</span><span>:</span> <span>"lala"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>getJoke</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>var</span> that <span>=</span> <span>this</span><span>;</span> <span>// 这里先保存this，在回调函数中this将会变化</span>
      axios<span>.</span><span>get</span><span>(</span><span>"https://autumnfish.cn/api/joke"</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
        that<span>.</span>joke <span>=</span> response<span>.</span>data<span>;</span> <span>// 这里的this已经变化，使用事先保存的that</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="配置全局-axios" tabindex="-1"> 配置全局 axios</h3>
<p>vue2.x</p>
<div><pre><code><span>// main.js</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> App <span>from</span> <span>'./App.vue'</span>
<span>import</span> router <span>from</span> <span>'./router'</span>
<span>import</span> store <span>from</span> <span>'./store'</span>

<span>import</span> <span>"@picocss/pico/css/pico.min.css"</span>

Vue<span>.</span>config<span>.</span>productionTip <span>=</span> <span>false</span>

<span>**</span><span>// 全局配置axios</span>
<span>import</span> axios <span>from</span> <span>"axios"</span><span>;</span>
axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>'http://localhost:8080'</span><span>;</span>
<span>Vue</span><span>.</span>prototype<span>.</span>$axios <span>=</span> axios<span>;</span><span>**</span>

<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  router<span>,</span>
  store<span>,</span>
  <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span>
<span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span><span>'#app'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="解决跨域问题" tabindex="-1"> 解决跨域问题</h3>
<ul>
<li>使用一个代理服务器来解决跨域问题（这个代理服务器部署在 vue 相同的端口）</li>
<li>将 baseURL 改为 vue 项目的运行地址，因此不存在跨域</li>
<li>当 vue 发现请求的接口不存在，把请求转交给 proxy 代理</li>
<li>代理把请求的根路径替换为 devServer.proxy 属性的值，发起真正的请求</li>
<li>代理把请求到的数据，转发给 axios</li>
</ul>
<div><pre><code><span>**</span>axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>'http://localhost:8080'</span><span>;</span>  <span>// baseURL设置为vue的服务器地址**</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>// vue.config.js</span>
<span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'@vue/cli-service'</span><span>)</span>
module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>**</span>devServer<span>:</span> <span>{</span>
    <span>proxy</span><span>:</span> <span>{</span>
      <span>'/api'</span><span>:</span> <span>{</span>
        <span>target</span><span>:</span> <span>'http://localhost:9012'</span><span>,</span>  <span>// 这里才是真正的api域名</span>
        <span>changeOrigin</span><span>:</span> <span>true</span><span>,</span>
        <span>pathRewrite</span><span>:</span><span>{</span>  <span>// 路径重写，</span>
          <span>'^/api'</span><span>:</span> <span>'/api'</span>  <span>// 把 /api 替换成 /api，也就是不替换！</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>**</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1Ku8ff.png" alt="1Ku8ff" loading="lazy"></p>
<h2 id="部署-vue-项目到-docker" tabindex="-1"> 部署 vue 项目到 docker</h2>
<p><a href="https://cli.vuejs.org/guide/deployment.html#docker-nginx" target="_blank" rel="noopener noreferrer">Deployment | Vue CLI</a></p>
<h2 id="设置-https" tabindex="-1"> 设置 HTTPS</h2>
<p>vue.config.js</p>
<div><pre><code><span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"@vue/cli-service"</span><span>)</span><span>;</span>
module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>devServer</span><span>:</span> <span>{</span>
    <span>https</span><span>:</span> <span>{</span>
      <span>cert</span><span>:</span> <span>"/Users/timpcfan/cert/localhost.pem"</span><span>,</span>
      <span>key</span><span>:</span> <span>"/Users/timpcfan/cert/localhost-key.pem"</span><span>,</span>
    <span>}</span><span>,</span>
    <span>proxy</span><span>:</span> <span>{</span>
      <span>"/api"</span><span>:</span> <span>{</span>
        <span>target</span><span>:</span> <span>"https://localhost:9012"</span><span>,</span>
        <span>changeOrigin</span><span>:</span> <span>true</span><span>,</span>
        <span>pathRewrite</span><span>:</span> <span>{</span>
          <span>// 路径重写，</span>
          <span>"^/api"</span><span>:</span> <span>"/api"</span><span>,</span> <span>// 把 /api 替换成 /api</span>
        <span>}</span><span>,</span>
      <span>}</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="问题收集" tabindex="-1"> 问题收集</h2>
<h3 id="props-属性是只读的不能使用-v-model-怎么办" tabindex="-1"> props 属性是只读的不能使用 v-model 怎么办？</h3>
<p><a href="https://b23.tv/P8YRl6W" target="_blank" rel="noopener noreferrer">https://b23.tv/P8YRl6W</a></p>
<p>把它转存到 data 中，data 中的数据是可读可写的。</p>
<h2 id="案例收集" tabindex="-1"> 案例收集</h2>
<h3 id="计数器" tabindex="-1"> 计数器</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>基础</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      &lt;button @click="sub">-</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-text</span><span><span>=</span><span>"</span>count<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span>
      &lt;button @click="add">+</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          count: 0,
        },
        methods: {
          add: function () {
            if (this.count &lt; 10) {
              this.count++;
            } else {
              alert("已达到最大值");
            }
          },
          sub: function () {
            if (this.count > 0) {
              this.count--;
            } else {
              alert("已达到最小值");
            }
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="图片切换" tabindex="-1"> 图片切换</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>图片切换</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-text</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span>&lt;button @click="nextImg">NEXT</span><span><span><span>&lt;/</span>button</span><span>></span></span><span><span><span>&lt;</span>br</span> <span>/></span></span><span>
      </span><span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>"</span>imgList[curIdx]<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          title: "",
          curIdx: 0,
          imgList: [
            "https://images.unsplash.com/photo-1546508428-f76b668cc812?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1222&amp;q=80",
            "https://images.unsplash.com/photo-1546417492-0e81e5e9d161?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80",
            "https://images.unsplash.com/photo-1546884680-a1de22e94d50?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80",
            "https://images.unsplash.com/photo-1544946632-b73cacef16ad?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1332&amp;q=80",
            "https://images.unsplash.com/photo-1548561711-73eae96ad48d?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=991&amp;q=80",
            "https://images.unsplash.com/photo-1545557800-740d9fe3524a?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80",
            "https://images.unsplash.com/photo-1540202404-d0c7fe46a087?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1333&amp;q=80",
            "https://images.unsplash.com/photo-1548604303-af502df13131?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80",
          ],
        },
        methods: {
          nextImg: function () {
            this.curIdx = (this.curIdx + 1) % this.imgList.length;
            console.log(this.curIdx);
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="记事本" tabindex="-1"> 记事本</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>记事本</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>记事本</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
      &lt;input type="text" v-model="taskName" @keyup.enter="addTask" />
      </span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item, idx) in taskList<span>"</span></span><span>></span></span><span>
          </span><span>{</span><span>{</span>idx<span>+</span><span>1</span><span>}</span><span>}</span><span>. </span><span>{</span><span>{</span>item<span>}</span><span>}</span><span>&lt;button @click="removeTask(idx)">x</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
        </span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-if</span><span><span>=</span><span>"</span>taskList.length>0<span>"</span></span>
        <span>></span></span><span>{</span><span>{</span>taskList<span>.</span>length<span>}</span><span>}</span><span> items left
        &lt;button @click="clearAll">Clear</span><span><span><span>&lt;/</span>button</span><span>></span></span><span><span><span>&lt;/</span>span</span>
      <span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          taskName: "",
          taskList: [],
        },
        methods: {
          addTask: function () {
            this.taskList.push(this.taskName);
            this.taskName = "";
          },
          removeTask: function (id) {
            this.taskList.splice(id, 1);
          },
          clearAll: function () {
            this.taskList = [];
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" type="image/png"/>
    </item>
    <item>
      <title>前端工程化与Webpack</title>
      <link>https://timpcfan.site/code/frontend/webpack.html</link>
      <guid>https://timpcfan.site/code/frontend/webpack.html</guid>
      <source url="https://timpcfan.site/rss.xml">前端工程化与Webpack</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 03 Oct 2022 12:48:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前端工程化" tabindex="-1"> 前端工程化</h2>
<div><p>前端工程化的四个「现代化」</p>
<ul>
<li>模块化（js 的模块化，css 的模块化，资源的模块化）</li>
<li>组件化（复用现有的 UI 结构，样式，行为）</li>
<li>规范化（目录结构的画风，编码规范化，接口规范化，文本规范化， Git 分支管理）</li>
<li>自动化（自动化构建，自动部署，自动化测试）</li>
</ul>
</div>
<h3 id="什么是前端开发工程化" tabindex="-1"> 什么是前端开发工程化？</h3>
<p>在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</p>
<p>企业中的 Vue 项目和 React 项目，都是基于工程化的方式开发的。</p>
<h3 id="前端工程化的解决方案" tabindex="-1"> 前端工程化的解决方案</h3>
<p>目前流行的：</p>
<ul>
<li><a href="http://www.webpackjs.com" target="_blank" rel="noopener noreferrer">webpack</a></li>
<li><a href="http://zh.parceljs.org" target="_blank" rel="noopener noreferrer">parcel</a></li>
</ul>
<h2 id="webpack" tabindex="-1"> webpack</h2>
<div><p>提示</p>
<p>webpack 是前端项目工程化的具体解决方案，它提供了友好的<strong>前端模块化开发</strong>支持，以及<strong>代码压缩混淆</strong>、<strong>处理浏览器端 JavaScript 的兼容性</strong>、<strong>性能优化</strong>等强大的功能。</p>
</div>
<h3 id="创建一个-npm-的项目" tabindex="-1"> 创建一个 npm 的项目</h3>
<div><pre><code><span>npm</span> init <span>-y</span>  <span># 生成配置文件package.json</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="在项目中安装-webpack" tabindex="-1"> 在项目中安装 webpack</h3>
<div><pre><code><span>npm</span> i webpack@5.42.1 webpack-cli@4.7.2 <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中，<code>-D</code> 表示 <code>--save-dev</code>，将安装的包写入 <code>devDependencies</code> 中，表示开发时才会被利用到。默认为 <code>-S</code> 表示 <code>--save</code> ，将安装的包写入 <code>depedencies</code> 中，表示在开发以及生产环境中都会被用到。</p>
<h3 id="在项目中配置-webpack" tabindex="-1"> 在项目中配置 webpack</h3>
<ol>
<li>在项目根目录中，创建名为 <code>webpack.config.js</code> 的 webpack 配置文件，并初始化如下的基本配置：</li>
</ol>
<div><pre><code><span>// 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 代表 webpack 运行的模式，可选值为 development、production</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>在 <code>package.json</code> 的 <code>scripts</code> 节点下，新增 dev 脚本如下：</li>
</ol>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
	<span>"dev"</span><span>:</span> <span>"webpack"</span><span>,</span>  <span>// script 节点下的脚本，可以通过 npm run 执行，例如 npm run dev</span>
  <span>"build"</span><span>:</span> <span>"webpack --mode=production"</span>  <span>// 生产模式打包</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li>在终端中运行 <code>npm run dev</code> 命令，启动 webpack 进行项目的打包构建</li>
</ol>
<div><p>提示</p>
<p>webpack 会将所有依赖的 js 文件都整合到一个 main.js 文件中，在 html 中应该直接引用整合后的 main.js 文件。</p>
</div>
<h3 id="webpack-中的默认约定" tabindex="-1"> webpack 中的默认约定</h3>
<p>在 webpack4.x 和 5.x 的版本中，有如下的默认约定：</p>
<ol>
<li>默认的打包入口文件为：src→index.js</li>
<li>默认的输出文件路径为：dist→main.js</li>
</ol>
<div><p>提示</p>
<p>注：可在 <code>webpack.config.js</code> 中修改打包的默认约定</p>
<p>通过 entry 节点指定打包的入口，通过 output 节点指定打包的出口。</p>
</div>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>"path"</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>entry</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"src/index.js"</span><span>)</span><span>,</span>
  <span>output</span><span>:</span> <span>{</span>
    <span>path</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"dist"</span><span>)</span><span>,</span>
    <span>filename</span><span>:</span> <span>"main.js"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="webpack-插件的使用" tabindex="-1"> webpack 插件的使用</h2>
<h3 id="一些常用的插件" tabindex="-1"> 一些常用的插件</h3>
<ol>
<li><strong>webpack-dev-server</strong>
<ul>
<li>每当修改了源代码，webpack 会自动进行项目的打包和构建</li>
</ul>
</li>
<li><strong>html-webpack-plugin</strong>
<ul>
<li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定义 index.html 页面的内容</li>
<li>插件生成的 html 页面中会自动注入了打包的 main.js 文件</li>
</ul>
</li>
</ol>
<h3 id="如何使用webpack-dev-server" tabindex="-1"> 如何使用<strong>webpack-dev-server</strong></h3>
<p>安装</p>
<div><pre><code><span>npm</span> i webpack-dev-server <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>修改 <code>package.json</code> 中的 <code>scripts</code> 的 <code>dev</code> 命令如下：</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
  <span>"dev"</span><span>:</span> <span>"webpack **serve**"</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>再次运行 <code>npm run dev</code> 命令，重新进行项目的打包</p>
<p>在浏览器中访问：<a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a> 地址，查看自动打包效果</p>
<div><p>一些坑</p>
<ul>
<li>该插件自动打包生成的 js 文件是存储在内存中的，因此在物理磁盘路径下无法看见</li>
<li>该插件生成的 js 文件默认的位置是项目的根目录</li>
</ul>
</div>
<h3 id="如何使用-html-webpack-plugin" tabindex="-1"> 如何使用 html-webpack-plugin</h3>
<div><p>相关信息</p>
<p>为什么要用 html-webpack-plugin？</p>
<p>使用上面的插件时，访问 http://localhost:8080 地址，默认是打开根目录，但实际的项目入口在 src 文件夹中，因此希望将 src 文件夹中的 index.html 复制一份到根目录下，使得可以直接访问。</p>
</div>
<p>安装</p>
<div><pre><code><span>npm</span> i html-webpack-plugin <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>配置</p>
<div><pre><code><span>// 1. 导入 HTML 插件</span>
<span>const</span> HtmlPlugin <span>=</span> <span>require</span><span>(</span><span>"html-webpack-plugin"</span><span>)</span><span>;</span>

<span>// 2. 创建 HTML 插件的实例对象</span>
<span>const</span> htmlPlugin <span>=</span> <span>new</span> <span>HtmlPlugin</span><span>(</span><span>{</span>
  <span>template</span><span>:</span> <span>"./src/index.html"</span><span>,</span> <span>// 指定原文件的路径</span>
  <span>filename</span><span>:</span> <span>"./index.html"</span><span>,</span> <span>// 指定生成文件的路径</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>plugins</span><span>:</span> <span>[</span>htmlPlugin<span>]</span><span>,</span> <span>// 3. 通过 plugins 节点，使 htmlPlugin 插件生效</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>启动时自动打开浏览器</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>devServer</span><span>:</span> <span>{</span>
    <span>open</span><span>:</span> <span>true</span><span>,</span> <span>// 自动打开浏览器</span>
    <span>host</span><span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 实时打包使用的主机地址</span>
    <span>port</span><span>:</span> <span>8080</span><span>,</span> <span>//实时打包使用的端口号</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div>
<h3 id="webpack-中的-loader" tabindex="-1"> webpack 中的 loader</h3>
<div><p>提示</p>
<p>webpack 默认只能处理.js 文件，当遇到其他文件时它会寻找有没有对应的 loader 能够进行处理。例如，在处理 css 文件时，需要安装处理 css 文件的 loader。</p>
</div>
<p>安装 loader：</p>
<div><pre><code><span>npm</span> i style-loader css-loader <span>-D</span>
<span>npm</span> i less-loader - D  <span># 若要处理less文件</span>
<span>npm</span> i url-loader file-loader <span>-D</span> <span># 若要处理图片</span>
<span>npm</span> i babel-loader @babel/core @babel/plugin-proposal-decorators <span>-D</span> <span># 处理高级js语法</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>在 <code>webpack.config.js</code> 的 <code>module-&gt;rules</code> 数组中，添加 loader 规则如下：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>module</span><span>:</span> <span>{</span>
    <span>// 所有第三方文件模块匹配规则</span>
    <span>rules</span><span>:</span> <span>[</span>
      <span>// 文件后缀名的匹配规则</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"style-loader"</span><span>,</span> <span>"css-loader"</span><span>]</span> <span>}</span><span>,</span> <span>// 允许在js中使用 import 'xxx.css' 的方式导入css</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.less$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"style-loader"</span><span>,</span> <span>"css-loader"</span><span>,</span> <span>"less-loader"</span><span>]</span> <span>}</span><span>,</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.jpg|png|gif$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"url-loader?limit=20000"</span><span>]</span> <span>}</span><span>,</span> <span>// 处理图片，小于等于20000字节的会被转换成base64，否则为地址</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.js$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>"babel-loader"</span><span>,</span> <span>exclude</span><span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span> <span>}</span><span>,</span> <span>// 处理高级js语法，node_modules中的第三方包不需要被打包</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中， <code>test</code> 表示匹配的文件类型，<code>use</code> 表示对应要调用的 loader</p>
<div><p>注意</p>
<ul>
<li>use 数组中指定的 loader 顺序是固定的</li>
<li>多个 loader 的调用顺序是：<strong>从后往前调用</strong></li>
</ul>
</div>
<h4 id="配置-babel-loader" tabindex="-1"> 配置 babel-loader</h4>
<p>不想看了，省略！</p>
<p>要创建一个 <code>babel.config.js</code> 文件</p>
<h3 id="自动清理-dist-目录" tabindex="-1"> 自动清理 dist 目录</h3>
<p>包：clean-webpack-plugin</p>
<p>使用方法：<a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h3 id="解决-source-map-的问题" tabindex="-1"> 解决 Source Map 的问题</h3>
<div><p>提示</p>
<p>由于 webpack 会进行混淆代码，因此运行时报错的行号可能与源代码的行号不一致，可以使用下面的方法来保持一致：</p>
</div>
<p>在配置文件中添加：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"devlopment"</span><span>,</span>
  <span>devtool</span><span>:</span> <span>"eval-source-map"</span><span>,</span> <span>// this!</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>考虑到安全原因，建议使用折衷的 <code>nonsources-source-map</code></p>
</div>
<h3 id="符号的定义" tabindex="-1"> @符号的定义</h3>
<div><p>提示</p>
<p>import 时，若使用相对路径会使得代码非常繁琐，可以使用@符号代表 src 目录的绝对路径，从外往里指定路径。</p>
</div>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>resolve</span><span>:</span> <span>{</span>
    <span>alias</span><span>:</span> <span>{</span>
      <span>"@"</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"src"</span><span>)</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python异步I/O与协程</title>
      <link>https://timpcfan.site/code/language/python/python-asyncio.html</link>
      <guid>https://timpcfan.site/code/language/python/python-asyncio.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python异步I/O与协程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>注意</p>
<p>这里实际上就是官方文档的搬运，非常不完整，建议直接看<a href="https://docs.python.org/zh-cn/3.10/library/asyncio.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2 id="asyncio-—-异步-i-o-协程" tabindex="-1"> asyncio — 异步 I/O &amp; 协程</h2>
<p>协程运行的原理见： <a href="/code/language/python/python-concurrent.html#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81">协程的原理以及代码</a></p>
<p>asyncio 是用来编写  <strong>并发</strong>  代码的库，使用  <strong>async/await</strong>  语法。</p>
<p>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。</p>
<p>asyncio 往往是构建 IO 密集型和高层级  <strong>结构化</strong>  网络代码的最佳选择。</p>
<p>asyncio 提供一组  <strong>高层级</strong> API 用于:</p>
<ul>
<li>并发地  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">运行 Python 协程</a>  并对其执行过程实现完全控制;</li>
<li>执行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">网络 IO 和 IPC</a>;</li>
<li>控制  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程</a>;</li>
<li>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列</a>  实现分布式任务;</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio-sync" target="_blank" rel="noopener noreferrer">同步</a>  并发代码;</li>
</ul>
<p>此外，还有一些  <strong>低层级</strong> API 以支持  <em>库和框架的开发者</em>  实现:</p>
<ul>
<li>创建和管理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio-event-loop" target="_blank" rel="noopener noreferrer">事件循环</a>，以提供异步 API 用于  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.create_server" target="_blank" rel="noopener noreferrer">网络化</a>, 运行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec" target="_blank" rel="noopener noreferrer">子进程</a>，处理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler" target="_blank" rel="noopener noreferrer">OS 信号</a>  等等;</li>
<li>使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-protocol.html#asyncio-transports-protocols" target="_blank" rel="noopener noreferrer">transports</a>  实现高效率协议;</li>
<li>通过 async/await 语法  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio-futures" target="_blank" rel="noopener noreferrer">桥接</a>  基于回调的库和代码。</li>
</ul>
<h2 id="协程与任务" tabindex="-1"> 协程与任务 <sup></sup></h2>
<h3 id="协程" tabindex="-1"> 协程</h3>
<p>通过 async/await 关键字来定义的协程是一种被推荐的编写异步程序的方式。</p>
<p>下面的代码定义并运行了一个协程：</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> asyncio

<span>>></span><span>></span> <span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'hello'</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'world'</span><span>)</span>

<span>>></span><span>></span> asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
hello
world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：简单地调用一个协程并不会使其被调度执行。</p>
<div><pre><code><span>>></span><span>></span> main<span>(</span><span>)</span>
<span>&lt;</span>coroutine <span>object</span> main at <span>0x1053bb7c8</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>要正在运行一个协程，asyncio 提供了三种主要机制：</p>
<ol>
<li>
<p><code>asyncio.run()</code> 函数用来运行最高层级的入口点 “main()” 函数</p>
</li>
<li>
<p><code>await</code> 一个协程。以下代码会在等待 1 秒后打印“hello”，然后等待 2 秒后打印“world”。（await 一个协程会让其开始运行，并等待其完成）</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> time

<span>async</span> <span>def</span> <span>say_after</span><span>(</span>delay<span>,</span> what<span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span>delay<span>)</span>
    <span>print</span><span>(</span>what<span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span>
    <span>await</span> say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># started at 17:13:52</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:13:55</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><code>asyncio.create_task()</code> 函数用来并发运行作为 asyncio 任务的多个协程。（create_task()之后会使任务出于就绪状态随时准备运行，而 await task 则是等待这个任务运行完成）</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    task1 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span><span>)</span>

    task2 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span># Wait until both tasks are completed (should take</span>
    <span># around 2 seconds.)</span>
    <span>await</span> task1
    <span>await</span> task2

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span># 比上面的要快1秒，因为两个task是同时运行的</span>
<span># started at 17:14:32</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:14:34</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h3 id="可等待对象-awaitable-objects" tabindex="-1"> 可等待对象 awaitable objects</h3>
<p>如果一个对象可以在 await 语句中使用，那么它就是 awaitable 对象。许多 asyncio API 都被设计为接受 awaitable 对象。</p>
<p>可等待 对象有三种主要类型：协程（Coroutine）、任务（Task）、Future。</p>
<h3 id="协程-1" tabindex="-1"> 协程</h3>
<p>Python 协程属于可等待对象，因此可以在其他协程中被等待：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Nothing happens if we just call "nested()".</span>
    <span># A coroutine object is created but not awaited,</span>
    <span># so it *won't run at all*.</span>
    nested<span>(</span><span>)</span>  <span># 这个不会运行，只是单纯返回了一个coroutine对象</span>

    <span># Let's do it differently now and await it:</span>
    <span>print</span><span>(</span><span>await</span> nested<span>(</span><span>)</span><span>)</span>  <span># will print "42".  # 这里会运行，因为有await</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>重要</strong></p>
<p>在本文档中 &quot;协程&quot; 可用来表示两个紧密关联的概念:</p>
<ul>
<li><em>协程函数</em>: 定义形式为  <code>[async def](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def)</code>  的函数;</li>
<li><em>协程对象</em>: 调用  <em>协程函数</em>  所返回的对象。</li>
</ul>
<h3 id="任务" tabindex="-1"> 任务</h3>
<p>Task 被用来 “并行地” 调度协程。</p>
<p>当一个协程通过 asyncio.create_task() 等函数被封装为了一个 Task，该协程会被自动调度执行：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule nested() to run soon concurrently</span>
    <span># with "main()".</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>nested<span>(</span><span>)</span><span>)</span>  <span># 这里 task 就开始运行了</span>

    <span># "task" can now be used to cancel "nested()", or</span>
    <span># can simply be awaited to wait until it is complete:</span>
    <span>await</span> task  <span># 这里只是单纯地等待其运行完</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="futures" tabindex="-1"> Futures</h3>
<p>Future 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p>
<p>在 asyncio 中需要 Future 对象以便允许 async/await 使用基于回调的代码。</p>
<p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p>
<p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象：</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> function_that_returns_a_future_object<span>(</span><span>)</span>

    <span># this is also valid:</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        function_that_returns_a_future_object<span>(</span><span>)</span><span>,</span>
        some_python_coroutine<span>(</span><span>)</span>
    <span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>一个很好的返回对象的低层级函数的示例是：loop.run_in_executor()</p>
<h3 id="运行-asyncio-程序" tabindex="-1"> 运行 asyncio 程序</h3>
<p><code>asyncio.run(coro, *, debug=False)</code></p>
<p>执行 coro 并返回结果。</p>
<p>吃函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。</p>
<p>但有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 debug 为 True，事件循环将以调试模式运行。</p>
<p>此函数<strong>总是会创建一个新的事件循环</strong>并在结束时关闭之。它应当用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'hello'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="创建任务" tabindex="-1"> 创建任务</h3>
<p><code>asyncio.create_task(coro, *, name=None)</code></p>
<p>将 coro 封装为一个 Task 并调度其执行。返回 Task 对象。</p>
<p>name 不为 None 时，它将使用 Task.set_name() 来设为任务的名称。</p>
<p>该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。</p>
<div><p>相关信息</p>
<p>需要保存这个方法返回值 Task 的引用，因为 event_loop 中只会保存一个弱引用，如果不保存引用，可能这个协程没有被执行完毕就被垃圾回收给清理了。</p>
</div>
<div><pre><code>background_tasks <span>=</span> <span>set</span><span>(</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>some_coro<span>(</span>param<span>=</span>i<span>)</span><span>)</span>

    <span># Add task to the set. This creates a strong reference.</span>
    background_tasks<span>.</span>add<span>(</span>task<span>)</span>

    <span># To prevent keeping references to finished tasks forever,</span>
    <span># make each task remove its own reference from the set after</span>
    <span># completion:</span>
    task<span>.</span>add_done_callback<span>(</span>background_tasks<span>.</span>discard<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="休眠" tabindex="-1"> 休眠</h3>
<p><code>coroutine asyncio.sleep(delay, result=None)</code></p>
<p>阻塞 delay 指定的秒数。</p>
<p>如果指定了 result，则当协程完成时 result 其返回给调用者。</p>
<p>sleep() 总是会挂起当前任务，以允许其他任务运行。</p>
<p>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行。 这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</p>
<p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> datetime

<span>async</span> <span>def</span> <span>display_date</span><span>(</span><span>)</span><span>:</span>
    loop <span>=</span> asyncio<span>.</span>get_running_loop<span>(</span><span>)</span>
    end_time <span>=</span> loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>5.0</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>)</span>
        <span>if</span> <span>(</span>loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>1.0</span><span>)</span> <span>>=</span> end_time<span>:</span>
            <span>break</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>

asyncio<span>.</span>run<span>(</span>display_date<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="并发运行任务" tabindex="-1"> 并发运行任务</h3>
<p><code>awaitable asyncio.gather(*aws, return_exceptions=False)</code></p>
<p><em>并发</em> 运行 aws 序列中的 可等待对象。</p>
<p>如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务调度。</p>
<p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而层的列表。结果值的顺序与 aws 中可等待对象的<strong>顺序一致</strong>。</p>
<p>如果 return_exceptions 为 False，所引发的首个异常会立即传播给等待 gather() 的任务。aws 序列中的其他可等待对象 <strong>不会被取消</strong> 并继续运行。</p>
<p>如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<p>如果 gather() 被取消，所有被提交（尚未完成）的可等待对象也会 被取消。</p>
<p>如果 aws 序列中的任一 Task 或 Future 对象 被取消，它将被当作引发了 CancelledError 一样处理 — 在此情况下 gather() 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>factorial</span><span>(</span>name<span>,</span> number<span>)</span><span>:</span>
    f <span>=</span> <span>1</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> number <span>+</span> <span>1</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: Compute factorial(</span><span><span>{</span>number<span>}</span></span><span>), currently i=</span><span><span>{</span>i<span>}</span></span><span>..."</span></span><span>)</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        f <span>*=</span> i
    <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: factorial(</span><span><span>{</span>number<span>}</span></span><span>) = </span><span><span>{</span>f<span>}</span></span><span>"</span></span><span>)</span>
    <span>return</span> f

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule three calls *concurrently*:</span>
    L <span>=</span> <span>await</span> asyncio<span>.</span>gather<span>(</span>
        factorial<span>(</span><span>"A"</span><span>,</span> <span>2</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"B"</span><span>,</span> <span>3</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"C"</span><span>,</span> <span>4</span><span>)</span><span>,</span>
    <span>)</span>
    <span>print</span><span>(</span>L<span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     Task A: Compute factorial(2), currently i=2...</span>
<span>#     Task B: Compute factorial(3), currently i=2...</span>
<span>#     Task C: Compute factorial(4), currently i=2...</span>
<span>#     Task A: factorial(2) = 2</span>
<span>#     Task B: Compute factorial(3), currently i=3...</span>
<span>#     Task C: Compute factorial(4), currently i=3...</span>
<span>#     Task B: factorial(3) = 6</span>
<span>#     Task C: Compute factorial(4), currently i=4...</span>
<span>#     Task C: factorial(4) = 24</span>
<span>#     [2, 6, 24]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>如果  <em>return_exceptions</em>  为 False，则在 gather() 被标记为已完成后取消它将不会取消任何已提交的可等待对象。 例如，在将一个异常传播给调用者之后，gather 可被标记为已完成，因此，在从 gather 捕获一个（由可等待对象所引发的）异常之后调用  <code>gather.cancel()</code>  将不会取消任何其他可等待对象。</p>
</div>
<h3 id="屏蔽取消操作" tabindex="-1"> 屏蔽取消操作</h3>
<p><code>awaitable asyncio.shield(aw)</code></p>
<p>保护一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  防止其被  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p>以下语句:</p>
<p><code>res = **await** shield(something())</code></p>
<p>相当于:</p>
<p><code>res = **await** something()</code></p>
<p><em>不同之处</em>  在于如果包含它的协程被取消，在  <code>something()</code>  中运行的任务不会被取消。从  <code>something()</code>  的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 &quot;await&quot; 表达式仍然会引发<a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>。</p>
<h3 id="超时" tabindex="-1"> 超时</h3>
<p><code>coroutine asyncio.wait_for(aw, timeout)</code></p>
<p>等待  <em>aw</em> <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  完成，指定 timeout 秒数后超时。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p><em>timeout</em>  可以为  <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果  <em>timeout</em>  为  <code>None</code>，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>.</p>
<p>要避免任务  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>，可以加上  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener noreferrer">shield()</a>。</p>
<p>此函数将等待直到 Future 确实被取消，所以总等待时间可能超过  <em>timeout</em>。 如果在取消期间发生了异常，异常将会被传播。</p>
<p>如果等待被取消，则  <em>aw</em>  指定的对象也会被取消。</p>
<div><pre><code><span>async</span> <span>def</span> <span>eternity</span><span>(</span><span>)</span><span>:</span>
    <span># Sleep for one hour</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>3600</span><span>)</span>
    <span>print</span><span>(</span><span>'yay!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Wait for at most 1 second</span>
    <span>try</span><span>:</span>
        <span>await</span> asyncio<span>.</span>wait_for<span>(</span>eternity<span>(</span><span>)</span><span>,</span> timeout<span>=</span><span>1.0</span><span>)</span>
    <span>except</span> asyncio<span>.</span>TimeoutError<span>:</span>
        <span>print</span><span>(</span><span>'timeout!'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     timeout!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="简单等待" tabindex="-1"> 简单等待</h3>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  并进入阻塞状态直到满足  <em>return_when</em>  所指定的条件。</p>
<p><em>aws</em>  可迭代对象必须不为空。</p>
<p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p>
<p>用法：</p>
<p><code>done, pending = **await** asyncio.wait(aws)</code></p>
<p>如指定  <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p>
<p>请注意此函数不会引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p>
<p><em>return_when</em>  指定此函数应在何时返回。它必须为以下常数之一:</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIRST_COMPLETED</td>
<td>函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于  ALL_COMPLETED。</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td>函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody>
</table>
<p><code>asyncio.as_completed(aws, *, timeout=None)</code></p>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>。 返回一个协程的迭代器。 所返回的每个协程可被等待以从剩余的可等待对象的可迭代对象中获得最早的下一个结果。</p>
<p>如果在所有 Future 对象完成前发生超时则将引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。</p>
<div><pre><code><span>for</span> coro <span>in</span> as_completed<span>(</span>aws<span>)</span><span>:</span>
    earliest_result <span>=</span> <span>await</span> coro
    <span># ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="在线程中运行" tabindex="-1"> 在线程中运行</h3>
<p><code>coroutine asyncio.to_thread(func, /, *args, **kwargs)</code></p>
<p>在不同的线程中异步地运行函数  <em>func</em>。</p>
<p>向此函数提供的任何 *args 和 **kwargs 会被直接传给  *func*。 并且，当前  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#contextvars.Context" target="_blank" rel="noopener noreferrer">contextvars.Context</a>  会被传播，允许在不同的线程中访问来自事件循环的上下文变量。</p>
<p>返回一个可被等待以获取  <em>func</em>  的最终结果的协程。</p>
<p>这个协程函数主要是用于执行在其他情况下会阻塞事件循环的 IO 密集型函数/方法。 例如:</p>
<div><pre><code><span>def</span> <span>blocking_io</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"start blocking_io at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>
    <span># Note that time.sleep() can be replaced with any blocking</span>
    <span># IO-bound operation, such as file operations.</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"blocking_io complete at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        asyncio<span>.</span>to_thread<span>(</span>blocking_io<span>)</span><span>,</span>
        asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span># started main at 19:50:53</span>
<span># start blocking_io at 19:50:53</span>
<span># blocking_io complete at 19:50:54</span>
<span># finished main at 19:50:54</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在任何协程中直接调用  blocking_io() 将会在调用期间阻塞事件循环，导致额外的 1 秒运行时间。 而通过改用  asyncio.to_thread()，我们可以在不同的线程中运行它从而不会阻塞事件循环。</p>
<h3 id="跨线程调度" tabindex="-1"> 跨线程调度</h3>
<p><code>asyncio.run_coroutine_threadsafe(coro, loop)</code></p>
<p>向指定事件循环提交一个协程。（线程安全）</p>
<p>返回一个  <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener noreferrer">concurrent.futures.Future</a>  以等待来自其他 OS 线程的结果。</p>
<p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p>
<div><pre><code><span># Create a coroutine</span>
coro <span>=</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>,</span> result<span>=</span><span>3</span><span>)</span>

<span># Submit the coroutine to a given loop</span>
future <span>=</span> asyncio<span>.</span>run_coroutine_threadsafe<span>(</span>coro<span>,</span> loop<span>)</span>

<span># Wait for the result with an optional timeout argument</span>
<span>assert</span> future<span>.</span>result<span>(</span>timeout<span>)</span> <span>==</span> <span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p>
<div><pre><code><span>try</span><span>:</span>
    result <span>=</span> future<span>.</span>result<span>(</span>timeout<span>)</span>
<span>except</span> concurrent<span>.</span>futures<span>.</span>TimeoutError<span>:</span>
    <span>print</span><span>(</span><span>'The coroutine took too long, cancelling the task...'</span><span>)</span>
    future<span>.</span>cancel<span>(</span><span>)</span>
<span>except</span> Exception <span>as</span> exc<span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine raised an exception: </span><span><span>{</span>exc<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine returned: </span><span><span>{</span>result<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>参见  <a href="https://docs.python.org/zh-cn/3/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener noreferrer">concurrency and multithreading</a>  部分的文档。</p>
<p>不同与其他 asyncio 函数，此函数要求显式地传入  <em>loop</em>  参数。</p>
<h3 id="内省" tabindex="-1"> 内省</h3>
<p><code>asyncio.**current_task**(*loop=None*)</code></p>
<p>返回当前运行的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  实例，如果没有正在运行的任务则返回  <code>None</code>。
如果  <em>loop</em>  为  <code>None</code>  则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<p><code>asyncio.**all_tasks**(*loop=None*)</code></p>
<p>返回事件循环所运行的未完成的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  对象的集合。
如果  <em>loop</em>  为  <code>None</code>，则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<h3 id="task-对象" tabindex="-1"> Task 对象</h3>
<p><code>class asyncio.Task(coro, *, loop=None, name=None)</code></p>
<p>一个与  <code>[Future 类似](https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future)</code>  的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程</a>。非线程安全。</p>
<p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象  <em>完成</em>，被打包的协程将恢复执行。</p>
<p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p>
<p>使用高层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数来创建 Task 对象，也可用低层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener noreferrer">loop.create_task()</a>  或  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener noreferrer">ensure_future()</a>  函数。不建议手动实例化 Task 对象。</p>
<p>要取消一个正在运行的 Task 对象可使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">cancel()</a>  方法。调用此方法将使该 Task 对象抛出一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener noreferrer">cancelled()</a>  可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常并且确实被取消，该方法将返回  <code>True</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">asyncio.Task</a>  从  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener noreferrer">Future</a>  继承了其除  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener noreferrer">Future.set_result()</a>  和  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener noreferrer">Future.set_exception()</a>  以外的所有 API。</p>
<p>Task 对象支持  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#module-contextvars" target="_blank" rel="noopener noreferrer">contextvars</a>  模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p>
<ul>
<li>cancel(msg=None)：取消任务，这将抛出 CancelledError</li>
<li>done()：如果 Task 对象已完成，则返回 true</li>
<li>result()：返回 Task 的结果</li>
<li>add_done_callback(callback, *, context=None)：添加一个回调，在 Task 完成时调用。</li>
</ul>
<h2 id="stream-流" tabindex="-1"> Stream 流 <sup></sup></h2>
<p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p>
<h3 id="stream-函数" tabindex="-1"> Stream 函数</h3>
<ul>
<li>open_connection</li>
<li>start_server</li>
</ul>
<h3 id="unix-套接字-socket" tabindex="-1"> Unix 套接字（Socket）</h3>
<ul>
<li>open_unix_connection</li>
<li>start_unix_server</li>
</ul>
<h3 id="streamreader-与-streamwriter" tabindex="-1"> StreamReader 与 StreamWriter</h3>
<h3 id="例子-echo-服务器与客户端" tabindex="-1"> 例子：echo 服务器与客户端</h3>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>handle_echo</span><span>(</span>reader<span>,</span> writer<span>)</span><span>:</span>
    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    message <span>=</span> data<span>.</span>decode<span>(</span><span>)</span>
    addr <span>=</span> writer<span>.</span>get_extra_info<span>(</span><span>'peername'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Received </span><span><span>{</span>message<span>!r</span><span>}</span></span><span> from </span><span><span>{</span>addr<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>data<span>)</span>
    <span>await</span> writer<span>.</span>drain<span>(</span><span>)</span>

    <span>print</span><span>(</span><span>"Close the connection"</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> <span>await</span> asyncio<span>.</span>start_server<span>(</span>
        handle_echo<span>,</span> <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    addrs <span>=</span> <span>', '</span><span>.</span>join<span>(</span><span>str</span><span>(</span>sock<span>.</span>getsockname<span>(</span><span>)</span><span>)</span> <span>for</span> sock <span>in</span> server<span>.</span>sockets<span>)</span>
    <span>print</span><span>(</span><span><span>f'Serving on </span><span><span>{</span>addrs<span>}</span></span><span>'</span></span><span>)</span>

    <span>async</span> <span>with</span> server<span>:</span>
        <span>await</span> server<span>.</span>serve_forever<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>tcp_echo_client</span><span>(</span>message<span>)</span><span>:</span>
    reader<span>,</span> writer <span>=</span> <span>await</span> asyncio<span>.</span>open_connection<span>(</span>
        <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    <span>print</span><span>(</span><span><span>f'Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>message<span>.</span>encode<span>(</span><span>)</span><span>)</span>

    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'Received: </span><span><span>{</span>data<span>.</span>decode<span>(</span><span>)</span><span>!r</span><span>}</span></span><span>'</span></span><span>)</span>

    <span>print</span><span>(</span><span>'Close the connection'</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>tcp_echo_client<span>(</span><span>'Hello World!'</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="同步原语" tabindex="-1"> 同步原语 <sup></sup></h2>
<p>asyncio 同步原语被设计为与  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>  模块的类似，但有两个关键注意事项:</p>
<ul>
<li>asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>)；</li>
<li>这些同步原语的方法不接受  <em>timeout</em>  参数；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数来执行带有超时的操作。</li>
</ul>
<p>asyncio 具有下列基本同步原语:</p>
<h3 id="lock" tabindex="-1"> Lock</h3>
<p><code>class asyncio.Lock</code></p>
<p>实现一个用于 asyncio 任务的互斥锁。 非线程安全。</p>
<p>asyncio 锁可被用来保证对共享资源的独占访问。</p>
<p>使用 Lock 的推荐方式是通过  <code>[async with](https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with)</code>  语句:</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>async</span> <span>with</span> lock<span>:</span>
    <span># access shared state</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这等价于：</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>await</span> lock<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
    <span># access shared state</span>
<span>finally</span><span>:</span>
    lock<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine acquire()</code></p>
<p>获取锁。
此方法会等待直至锁为  <em>unlocked</em>，将其设为  <em>locked</em>  并返回  <code>True</code>。
当有一个以上的协程在  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Lock.acquire" target="_blank" rel="noopener noreferrer">acquire()</a>  中被阻塞则会等待解锁，最终只有一个协程会被执行。
锁的获取是  <em>公平的</em>: 被执行的协程将是第一个开始等待锁的协程。</p>
<p><code>release()</code></p>
<p>释放锁。</p>
<p>当锁为  <em>locked</em>  时，将其设为  <em>unlocked</em>  并返回。</p>
<p>如果锁为  <em>unlocked</em>，则会引发  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" target="_blank" rel="noopener noreferrer">RuntimeError</a>。</p>
<p><code>locked()</code></p>
<p>如果锁为  <em>locked</em>  则返回  <code>True</code>。</p>
<h3 id="event" tabindex="-1"> Event</h3>
<p><code>class asyncio.Event</code></p>
<p>事件对象。 该对象不是线程安全的。</p>
<p>asyncio 事件可被用来通知多个 asyncio 任务已经有事件发生。</p>
<p>Event 对象会管理一个内部旗标，可通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法将其设为  <em>true</em>  并通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.clear" target="_blank" rel="noopener noreferrer">clear()</a>  方法将其重设为  <em>false</em>。 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  方法会阻塞直至该旗标被设为  <em>true</em>。 该旗标初始时会被设为  <em>false</em>。</p>
<div><pre><code><span>async</span> <span>def</span> <span>waiter</span><span>(</span>event<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'waiting for it ...'</span><span>)</span>
    <span>await</span> event<span>.</span>wait<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>'... got it!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create an Event object.</span>
    event <span>=</span> asyncio<span>.</span>Event<span>(</span><span>)</span>

    <span># Spawn a Task to wait until 'event' is set.</span>
    waiter_task <span>=</span> asyncio<span>.</span>create_task<span>(</span>waiter<span>(</span>event<span>)</span><span>)</span>

    <span># Sleep for 1 second and set the event.</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    event<span>.</span><span>set</span><span>(</span><span>)</span>

    <span># Wait until the waiter task is finished.</span>
    <span>await</span> waiter_task

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine wait()</code></p>
<p>等待直至事件被设置。</p>
<p>如果事件已被设置，则立即返回  <code>True</code>。 否则将阻塞直至另一个任务调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>。</p>
<p><code>set()</code></p>
<p>设置事件。</p>
<p>所有等待事件被设置的任务将被立即唤醒。</p>
<p><code>clear()</code></p>
<p>清空（取消设置）事件。</p>
<p>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  进行等待的任务现在将会阻塞直至  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法被再次调用。</p>
<p><code>is_set()</code></p>
<p>如果事件已被设置则返回  <code>True</code>。</p>
<h3 id="condition" tabindex="-1"> Condition</h3>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition" target="_blank" rel="noopener noreferrer">https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition</a></p>
<h3 id="semaphore" tabindex="-1"> Semaphore</h3>
<h3 id="boundedsemaphore" tabindex="-1"> BoundedSemaphore</h3>
<h2 id="队列集合" tabindex="-1"> 队列集合 <sup></sup></h2>
<p>asyncio 队列被设计成与  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a>  模块类似。尽管 asyncio 队列不是线程安全的，但是他们是被设计专用于 async/await 代码。</p>
<p>注意 asyncio 的队列没有  <em>timeout</em>  形参；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数为队列添加超时操作。</p>
<p>参见下面的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#examples" target="_blank" rel="noopener noreferrer">Examples</a>  部分。</p>
<h3 id="queue" tabindex="-1"> Queue</h3>
<p><code>class asyncio.Queue(maxsize=0)</code></p>
<p>FIFO 队列</p>
<p>如果  <em>maxsize</em>  小于等于零，则队列尺寸是无限的。如果是大于  <code>0</code>  的整数，则当队列达到  <em>maxsize</em>  时， <code>await put()</code>  将阻塞至某个元素被  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.get" target="_blank" rel="noopener noreferrer">get()</a>  取出。</p>
<p>不像标准库中的并发型  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a> ，队列的尺寸一直是已知的，可以通过调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.qsize" target="_blank" rel="noopener noreferrer">qsize()</a>  方法返回。</p>
<ul>
<li>maxsize</li>
<li>empty()</li>
<li>full()</li>
<li>coroutine join()</li>
<li>get_nowait() 不阻塞的出队</li>
<li>coroutine join() 阻塞至队列中所有的元素都被接收和处理完毕。
<ul>
<li>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费协程调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.task_done" target="_blank" rel="noopener noreferrer">task_done()</a>表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.join" target="_blank" rel="noopener noreferrer">join()</a>阻塞被解除。</li>
</ul>
</li>
<li>coroutine put(item)</li>
<li>put_nowait(item) 不阻塞的入队</li>
<li>qsize()</li>
<li>task_done() 表明前面排队的任务已经完成，即 get 出来的元素相关操作已经完成。</li>
</ul>
<h3 id="优先级队列" tabindex="-1"> 优先级队列</h3>
<p><code>class asyncio.PriorityQueue</code></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue" target="_blank" rel="noopener noreferrer">Queue</a>  的变体；按优先级顺序取出条目 (最小的先取出)。</p>
<p>条目通常是  <code>(priority_number, data)</code>  形式的元组。</p>
<h3 id="后进先出队列" tabindex="-1"> <strong>后进先出队列</strong></h3>
<p><code>class asyncio.LifoQueue</code></p>
<h3 id="例子" tabindex="-1"> 例子</h3>
<div><pre><code><span>import</span> asyncio
<span>import</span> random
<span>import</span> time

<span>async</span> <span>def</span> <span>worker</span><span>(</span>name<span>,</span> queue<span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        <span># Get a "work item" out of the queue.</span>
        sleep_for <span>=</span> <span>await</span> queue<span>.</span>get<span>(</span><span>)</span>

        <span># Sleep for the "sleep_for" seconds.</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span>sleep_for<span>)</span>

        <span># Notify the queue that the "work item" has been processed.</span>
        queue<span>.</span>task_done<span>(</span><span>)</span>

        <span>print</span><span>(</span><span><span>f'</span><span><span>{</span>name<span>}</span></span><span> has slept for </span><span><span>{</span>sleep_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create a queue that we will use to store our "workload".</span>
    queue <span>=</span> asyncio<span>.</span>Queue<span>(</span><span>)</span>

    <span># Generate random timings and put them into the queue.</span>
    total_sleep_time <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>20</span><span>)</span><span>:</span>
        sleep_for <span>=</span> random<span>.</span>uniform<span>(</span><span>0.05</span><span>,</span> <span>1.0</span><span>)</span>
        total_sleep_time <span>+=</span> sleep_for
        queue<span>.</span>put_nowait<span>(</span>sleep_for<span>)</span>

    <span># Create three worker tasks to process the queue concurrently.</span>
    tasks <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>worker<span>(</span><span><span>f'worker-</span><span><span>{</span>i<span>}</span></span><span>'</span></span><span>,</span> queue<span>)</span><span>)</span>
        tasks<span>.</span>append<span>(</span>task<span>)</span>

    <span># Wait until the queue is fully processed.</span>
    started_at <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span>
    <span>await</span> queue<span>.</span>join<span>(</span><span>)</span>
    total_slept_for <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span> <span>-</span> started_at

    <span># Cancel our worker tasks.</span>
    <span>for</span> task <span>in</span> tasks<span>:</span>
        task<span>.</span>cancel<span>(</span><span>)</span>
    <span># Wait until all worker tasks are cancelled.</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span><span>*</span>tasks<span>,</span> return_exceptions<span>=</span><span>True</span><span>)</span>

    <span>print</span><span>(</span><span>'===='</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'3 workers slept in parallel for </span><span><span>{</span>total_slept_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>
    <span>print</span><span>(</span><span><span>f'total expected sleep time: </span><span><span>{</span>total_sleep_time<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="事件循环" tabindex="-1"> 事件循环 <sup></sup></h2>
<h3 id="前言" tabindex="-1"> <strong>前言</strong></h3>
<p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p>
<p>应用开发者通常应当使用高层级的 asyncio 函数，例如  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener noreferrer">asyncio.run()</a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p>
<h2 id="高层级-api-索引" tabindex="-1"> 高层级 API 索引 <sup></sup></h2>
<p>这个页面列举了所有能用于 async/wait 的高层级 asyncio API 集。</p>
<h3 id="任务-1" tabindex="-1"> 任务</h3>
<p>运行异步程序，创建 Task 对象，等待多件事运行超时的公共集。</p>
<table>
<thead>
<tr>
<th>run()</th>
<th>创建事件循环，运行一个协程，关闭事件循环。</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_task()</td>
<td>启动一个 asyncio 的 Task 对象。</td>
</tr>
<tr>
<td>await sleep()</td>
<td>休眠几秒。</td>
</tr>
<tr>
<td>await gather()</td>
<td>并发执行所有事件的调度和等待。</td>
</tr>
<tr>
<td>await wait_for()</td>
<td>有超时控制的运行。</td>
</tr>
<tr>
<td>await shield()</td>
<td>屏蔽取消操作</td>
</tr>
<tr>
<td>await wait()</td>
<td>完成情况的监控器</td>
</tr>
<tr>
<td>current_task()</td>
<td>返回当前 Task 对象</td>
</tr>
<tr>
<td>all_tasks()</td>
<td>返回事件循环中所有的 task 对象。</td>
</tr>
<tr>
<td>Task</td>
<td>Task 对象</td>
</tr>
<tr>
<td>to_thread()</td>
<td>在不同的 OS 线程中异步地运行一个函数。</td>
</tr>
<tr>
<td>run_coroutine_threadsafe()</td>
<td>从其他 OS 线程中调度一个协程。</td>
</tr>
<tr>
<td>for in as_completed()</td>
<td>用  for  循环监控完成情况。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-gather" target="_blank" rel="noopener noreferrer">使用 asyncio.gather() 并行运行</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-waitfor" target="_blank" rel="noopener noreferrer">使用 asyncio.wait_for() 强制超时</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">撤销协程</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-sleep" target="_blank" rel="noopener noreferrer">asyncio.sleep() 的用法</a>.</li>
<li>请主要参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程与任务文档</a>.</li>
</ul>
<h3 id="队列集" tabindex="-1"> <strong>队列集</strong></h3>
<p>队列集被用于多个异步 Task 对象的运行调度，实现连接池以及发布/订阅模式。</p>
<table>
<thead>
<tr>
<th>Queue</th>
<th>先进先出队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>PriorityQueue</td>
<td>优先级队列。</td>
</tr>
<tr>
<td>LifoQueue</td>
<td>后进先出队列。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-example-queue-dist" target="_blank" rel="noopener noreferrer">使用 asyncio.Queue 在多个并发任务间分配工作量</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列集文档</a>.</li>
</ul>
<h3 id="子进程集" tabindex="-1"> 子进程集</h3>
<p>用于生成子进程和运行 shell 命令的工具包。</p>
<table>
<thead>
<tr>
<th>await create_subprocess_exec()</th>
<th>创建一个子进程。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await create_subprocess_shell()</td>
<td>运行一个 shell 命令。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-example-subprocess-shell" target="_blank" rel="noopener noreferrer">执行一个 shell 命令</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程 APIs</a>  相关文档.</li>
</ul>
<h3 id="流" tabindex="-1"> 流</h3>
<p>用于网络 IO 处理的高级 API 集。</p>
<table>
<thead>
<tr>
<th>await open_connection()</th>
<th>建立一个 TCP 连接。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await open_unix_connection()</td>
<td>建立一个 Unix socket 连接。</td>
</tr>
<tr>
<td>await start_server()</td>
<td>启动 TCP 服务。</td>
</tr>
<tr>
<td>await start_unix_server()</td>
<td>启动一个 Unix 套接字服务。</td>
</tr>
<tr>
<td>StreamReader</td>
<td>接收网络数据的高级 async/await 对象。</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>发送网络数据的高级 async/await 对象。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-example-stream" target="_blank" rel="noopener noreferrer">TCP 客户端样例</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">streams APIs</a>  文档。</li>
</ul>
<h3 id="同步" tabindex="-1"> <strong>同步</strong></h3>
<p>能被用于 Task 对象集的，类似线程的同步基元组件。</p>
<table>
<thead>
<tr>
<th>Lock</th>
<th>互斥锁。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event</td>
<td>事件对象。</td>
</tr>
<tr>
<td>Condition</td>
<td>条件对象</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量</td>
</tr>
<tr>
<td>BoundedSemaphore</td>
<td>有界的信号量。</td>
</tr>
</tbody>
</table>
<h3 id="异常" tabindex="-1"> <strong>异常</strong></h3>
<table>
<thead>
<tr>
<th>asyncio.TimeoutError</th>
<th>类似  wait_for()  等函数在超时时候被引发。请注意  asyncio.TimeoutError  与内建异常  TimeoutError  无关。</th>
</tr>
</thead>
<tbody>
<tr>
<td>asyncio.CancelledError</td>
<td>当一个 Task 对象被取消的时候被引发。请参阅  Task.cancel()。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">在取消请求发生的运行代码中如何处理 CancelledError 异常</a>.</li>
<li>请参阅完整的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio-exceptions" target="_blank" rel="noopener noreferrer">asyncio 专用异常</a>  列表.</li>
</ul>
<h2 id="关于-never-awaited-协程" tabindex="-1"> 关于 never-awaited 协程</h2>
<p>当协程函数被调用而不是被等待时 (即执行  <code>coro()</code>  而不是  <code>await coro()</code>) 或者协程没有通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  被排入计划日程，asyncio 将会发出一条  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeWarning" target="_blank" rel="noopener noreferrer">RuntimeWarning</a>:</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"never scheduled"</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    test<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># test.py:7: RuntimeWarning: coroutine 'test' was never awaited</span>
<span>#  test()</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通常的修复方法是 <code>await</code> 协程或者调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数:</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> test<span>(</span><span>)</span>  <span># 开始运行并等待完成</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>test<span>(</span><span>)</span><span>)</span>  <span># 开始运行</span>
        <span>await</span> task  <span># 等待完成</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html" target="_blank" rel="noopener noreferrer">协程与任务</a> </p>
</li>
<li id="footnote2"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html" target="_blank" rel="noopener noreferrer">Stream 流</a> </p>
</li>
<li id="footnote3"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html" target="_blank" rel="noopener noreferrer">同步原语</a> </p>
</li>
<li id="footnote4"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html" target="_blank" rel="noopener noreferrer">队列集合</a> </p>
</li>
<li id="footnote5"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html" target="_blank" rel="noopener noreferrer">事件循环</a> </p>
</li>
<li id="footnote6"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-api-index.html" target="_blank" rel="noopener noreferrer">高层级 API 索引</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Python二分查找 - bisect</title>
      <link>https://timpcfan.site/code/language/python/python-bisect.html</link>
      <guid>https://timpcfan.site/code/language/python/python-bisect.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python二分查找 - bisect</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="二分查找模块-bisect" tabindex="-1"> 二分查找模块 bisect</h2>
<p><code>bisect_left(a, x, lo=0, hi=len(a))</code></p>
<p>相当于 left_bound，返回目标值的左侧边界，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最左侧索引</li>
<li>解读 2：a 中小于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于等于 x 的最小元素索引</li>
</ul>
<hr>
<p><code>bisect_right(a, x, lo=0, hi=len(a))</code></p>
<p><code>bisect(a, x, lo=0, hi=len(a))</code></p>
<p>⚠️ 不相当于 right_bound，返回目标值的右侧边界+1，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最右侧索引</li>
<li>解读 2：a 中小于等于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于 x 的最小元素索引（返回的索引位置的值肯定不等于 x！！！</li>
</ul>
<hr>
<p><code>insort_left(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_left(a, x, lo, hi), x)</p>
<hr>
<p><code>insort_right(a, x, lo=0, hi=len(a))</code>
<code>insort(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_right(a, x, lo, hi), x)</p>
<hr>
<div><pre><code><span>#idx 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>
a <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>]</span>

<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>3</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>3</span><span>)</span>  <span># bisect(a, 3)</span>
<span>8</span>
<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python3-10-之后的版本新增参数-key" tabindex="-1"> python3.10 之后的版本新增参数 key</h2>
<p>类似 sort 的 key 参数，可以指定搜索时使用的具体的键</p>
<p>例子：</p>
<div><pre><code><span># leetcode #875</span>
<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>minEatingSpeed</span><span>(</span>self<span>,</span> piles<span>:</span> List<span>[</span><span>int</span><span>]</span><span>,</span> h<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>def</span> <span>canEatAll</span><span>(</span>k<span>)</span><span>:</span>
            <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                <span>return</span> <span>False</span>
            cost_time <span>=</span> <span>0</span>
            <span>for</span> pile <span>in</span> piles<span>:</span>
                cost_time <span>+=</span> math<span>.</span>ceil<span>(</span>pile <span>/</span> k<span>)</span>
            <span>return</span> cost_time <span>&lt;=</span> h
        <span>return</span> bisect_left<span>(</span><span>range</span><span>(</span><span>max</span><span>(</span>piles<span>)</span> <span>+</span> <span>1</span><span>)</span><span>,</span> <span>True</span><span>,</span> key<span>=</span>canEatAll<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>若使用这种方法解题，a 要包括所有的答案域，且如果使用 range，尽量使用 range(max_ans+1)的形式，若使用 range(min_ans, max_ans+1)，需要给返回的结果添加偏置 min_ans！</p>
</div>
<h2 id="在有序列表中搜索" tabindex="-1"> 在有序列表中搜索</h2>
<p>如何将 bisect 转换为一般的搜索方法：</p>
<div><pre><code><span>def</span> <span>index</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Locate the leftmost value exactly equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span> <span>and</span> a<span>[</span>i<span>]</span> <span>==</span> x<span>:</span>
        <span>return</span> i
    <span>raise</span> ValueError

<span>def</span> <span>find_lt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_le</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than or equal to x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_gt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost value greater than x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_ge</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost item greater than or equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python并发编程</title>
      <link>https://timpcfan.site/code/language/python/python-concurrent.html</link>
      <guid>https://timpcfan.site/code/language/python/python-concurrent.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python并发编程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="多进程程序例子" tabindex="-1"> 多进程程序例子</h2>
<div><pre><code><span>import</span> argparse
<span>import</span> redis
<span>from</span> tqdm <span>import</span> tqdm
<span>from</span> multiprocessing <span>import</span> Pool<span>,</span> Process

parser <span>=</span> argparse<span>.</span>ArgumentParser<span>(</span>description<span>=</span><span>'PyTorch MM Training'</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--port'</span><span>,</span> default<span>=</span><span>6379</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"port id"</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--file'</span><span>,</span> default<span>=</span><span>None</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"paths for train instances"</span><span>)</span>
args <span>=</span> parser<span>.</span>parse_args<span>(</span><span>)</span>

host <span>=</span> <span>'127.0.0.1'</span>
port <span>=</span> args<span>.</span>port

<span># r = redis.Redis(host=host, port=port)</span>

train_file <span>=</span> args<span>.</span><span>file</span>

<span>def</span> <span>worker_i</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>=</span><span>16</span><span>)</span><span>:</span>
    r <span>=</span> redis<span>.</span>Redis<span>(</span>host<span>=</span>host<span>,</span> port<span>=</span>port<span>)</span>
    k <span>=</span> <span>0</span>

    <span>if</span> i <span>==</span> <span>0</span><span>:</span>
        iter_ <span>=</span> tqdm<span>(</span><span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span><span>)</span>
    <span>else</span><span>:</span>
        iter_ <span>=</span> <span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span>

    <span>for</span> info <span>in</span> iter_<span>:</span>
        <span>if</span> k <span>%</span> nums <span>==</span> i<span>:</span> <span># 将多个任务分成nums份</span>
            r<span>.</span><span>set</span><span>(</span>k<span>,</span> info<span>.</span>strip<span>(</span><span>)</span><span>)</span>
        k <span>+=</span> <span>1</span>
process_list <span>=</span> <span>[</span><span>]</span>

nums <span>=</span> <span>8</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span>nums<span>)</span><span>:</span>
    p <span>=</span> Process<span>(</span>target<span>=</span>worker_i<span>,</span> args<span>=</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>)</span><span>)</span>
    p<span>.</span>start<span>(</span><span>)</span>
    process_list<span>.</span>append<span>(</span>p<span>)</span>

<span>for</span> i <span>in</span> process_list<span>:</span>
    p<span>.</span>join<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'写入完成'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python-中的三种并发编程方式" tabindex="-1"> Python 中的三种并发编程方式</h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" alt="tch30Z" loading="lazy"></p>
<h3 id="三种方式-多线程-thread-、多进程-process-、协程-coroutine" tabindex="-1"> 三种方式：多线程（Thread）、多进程（Process）、协程（Coroutine）</h3>
<h3 id="什么是-cpu-密集型计算、io-密集型计算" tabindex="-1"> 什么是 CPU 密集型计算、IO 密集型计算</h3>
<ul>
<li>CPU 密集型计算（CPU-bound）：
<ul>
<li>例如：压缩解压缩、加密解密</li>
</ul>
</li>
<li>IO 密集型计算（I/O bound）：
<ul>
<li>爬虫、文件处理等</li>
</ul>
</li>
</ul>
<h3 id="多线程、多进程、协程的对比" tabindex="-1"> 多线程、多进程、协程的对比</h3>
<ul>
<li>多进程 Process（multiprocessing）
<ul>
<li>优点：可以利用多核 CPU 并行运算</li>
<li>缺点：占用资源最多、可启动数目比线程少</li>
<li>适用于：CPU 密集型计算</li>
</ul>
</li>
<li>多线程 Thread（threading）
<ul>
<li>优点：相比进程，更轻量级、占用资源少</li>
<li>缺点：
<ul>
<li>相比进程：多线程只能并发执行，不能利用多 CPU（GIL）</li>
<li>相比协程：启动数目有限制，占用内存资源，有线程切换开销</li>
</ul>
</li>
<li>适用于：IO 密集型计算、同时允许的任务数目要求不多</li>
</ul>
</li>
<li>协程 Coroutine（asyncio）
<ul>
<li>优点：内存开销最少、启动协程数量最多</li>
<li>缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂</li>
<li>适用于：IO 密集型计算、需要超多任务运行、但有现成库支持的场景</li>
</ul>
</li>
</ul>
<h3 id="怎样根据任务选择对应技术" tabindex="-1"> 怎样根据任务选择对应技术</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UsvTjR.png" alt="UsvTjR" loading="lazy"></p>
<h2 id="全局解释器锁-gil-global-interpreter-lock" tabindex="-1"> 全局解释器锁 GIL（Global Interpreter Lock）</h2>
<p>Python 速度慢的两大原因：</p>
<ul>
<li>动态类型语言，边解释边执行</li>
<li>GIL，无法利用多核 CPU 并发执行</li>
</ul>
<p>全局解释器锁：</p>
<ul>
<li>是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。</li>
<li>即便在多核处理器上，使用 GIL 的解释器也<strong>只能允许同一时间执行一个线</strong>程。相比并发加速的 C++/JAVA 会慢很多。</li>
<li>原因详解
<ul>
<li>为了解决多线程之间数据完整性和状态同步问题。</li>
<li>Python 中对象的管理，维护了每个对象的引用计数，在多线程时，为了保证引用计数的一致性，使用了锁的机制。</li>
</ul>
</li>
</ul>
<p>怎样规避 GIL 带来的限制：</p>
<ul>
<li>那 Python 中的线程无法同时运行，为什么还要使用多线程机制呢？多线程机制在 Python 中依然是有用的，由于<strong>IO 密集型计算</strong>，因为 IO 期间，线程会释放 GIL，实现 CPU 和 IO 的并行，因此多线程用于 IO 密集型计算依然可以大幅提升速度。</li>
<li>使用 multiprocessing 的多进程机制实现并行计算、利用多核 CPU 优势。</li>
</ul>
<h2 id="python-多线程代码" tabindex="-1"> Python 多线程代码</h2>
<h3 id="直接创建线程" tabindex="-1"> 直接创建线程</h3>
<div><pre><code><span>import</span> threading

<span>def</span> <span>craw</span><span>(</span>url<span>)</span><span>:</span>  <span># 1. 准备一个函数</span>
	r <span>=</span> requests<span>.</span>get<span>(</span>url<span>)</span>
	<span>print</span><span>(</span><span>len</span><span>(</span>r<span>.</span>text<span>)</span><span>)</span>

<span>def</span> <span>multi_thread</span><span>(</span><span>)</span><span>:</span>
	threads <span>=</span> <span>[</span><span>]</span>  <span># 2. 准备一个线程list</span>
	<span>for</span> url <span>in</span> urls<span>:</span>
		threads<span>.</span>append<span>(</span>  <span># 3. 创建线程</span>
			threading<span>.</span>Thread<span>(</span>target<span>=</span>craw<span>,</span> args<span>=</span><span>(</span>url<span>,</span><span>)</span><span>)</span>
		<span>)</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>start<span>(</span><span>)</span>  <span># 4. 启动线程</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>join<span>(</span><span>)</span>  <span># 5. 等待结束</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="使用线程池threadpoolexecutor" tabindex="-1"> 使用线程池<strong>ThreadPoolExecutor</strong></h3>
<p>用法 1：使用 map 函数（所有任务一起提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		result <span>=</span> pool<span>.</span><span>map</span><span>(</span>craw<span>,</span> urls<span>)</span>
		<span># map的结果和入参的顺序对应的</span>
		<span>for</span> result <span>in</span> results<span>:</span>
				<span>print</span><span>(</span>result<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用法 2：future 模式，更强大（一个任务一个任务提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor<span>,</span> as_completed
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		<span># 使用 dict 可以知道future对应的入参</span>
		futures <span>=</span> <span>{</span>pool<span>.</span>submit<span>(</span>craw<span>,</span> url<span>)</span><span>:</span> url
								<span>for</span> url <span>in</span> urls<span>}</span>
		<span># 方式1: 结果仍然按顺序</span>
		<span>for</span> future<span>,</span> url <span>in</span> futures<span>.</span>items<span>(</span><span>)</span><span>:</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>

		<span># 方式2: 使用 as_completed 顺序是不定的</span>
		<span>for</span> future <span>in</span> as_completed<span>(</span>futures<span>)</span><span>:</span>  <span># 注：字典的遍历是遍历key</span>
				url <span>=</span> futures<span>[</span>future<span>]</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p></p>
<h2 id="python-多进程代码" tabindex="-1"> Python 多进程代码</h2>
<p>多线程 threading 与多进程 multiprocessing 的代码对比</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oMERIi.png" alt="oMERIi" loading="lazy"></p>
<p>直接改个类名就能运行！</p>
<p>所以代码去看 </p>
<h3 id="多进程优雅退出" tabindex="-1"> 多进程优雅退出</h3>
<div><pre><code><span>import</span> ctypes
<span>import</span> time
<span>from</span> multiprocessing <span>import</span> Process<span>,</span> RawValue

<span>class</span> <span>CountdownTask</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running <span>=</span> RawValue<span>(</span>ctypes<span>.</span>c_bool<span>,</span> <span>True</span><span>)</span>
    <span>def</span> <span>terminate</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running<span>.</span>value <span>=</span> <span>False</span>
    <span>def</span> <span>run</span><span>(</span>self<span>,</span> n<span>)</span><span>:</span>
        <span>while</span> self<span>.</span>_running<span>.</span>value <span>and</span> n <span>></span> <span>0</span><span>:</span>
            <span>print</span><span>(</span><span>'T-minus'</span><span>,</span> n<span>)</span>
            n <span>-=</span> <span>1</span>
            time<span>.</span>sleep<span>(</span><span>5</span><span>)</span>

c <span>=</span> CountdownTask<span>(</span><span>)</span>
t <span>=</span> Process<span>(</span>target<span>=</span>c<span>.</span>run<span>,</span> args<span>=</span><span>(</span><span>10</span><span>,</span><span>)</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>
c<span>.</span>terminate<span>(</span><span>)</span> <span># Signal termination</span>
t<span>.</span>join<span>(</span><span>)</span> <span># Wait for actual termination (if needed)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="线程池原理" tabindex="-1"> 线程池原理</h2>
<h3 id="线程池的原理" tabindex="-1"> 线程池的原理</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/YPT9vT.png" alt="YPT9vT" loading="lazy"></p>
<h3 id="特点" tabindex="-1"> 特点</h3>
<ul>
<li>使用任务队列</li>
<li>可重用线程</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>提升性能：减少创建终止线程开销，重用线程资源</li>
<li>适用场景：突发性大量请求、但任务处理时间较短</li>
<li>防御功能：避免系统因为创建线程过多导致负荷过大</li>
<li>代码优势：简洁方便</li>
</ul>
<h2 id="协程的原理以及代码" tabindex="-1"> 协程的原理以及代码</h2>
<p><a href="https://www.bilibili.com/video/BV1bK411A7tV?p=11" target="_blank" rel="noopener noreferrer">【2021 最新版】Python 并发编程实战，用多线程、多进程、多协程加速程序运行_哔哩哔哩_bilibili</a></p>
<h3 id="协程的原理" tabindex="-1"> 协程的原理</h3>
<p>协程：在<strong>单线程内</strong>实现并发</p>
<ul>
<li>核心原理：用一个超级循环（其实就是 while true）循环，配合 IO 多路复用原理（IO 时 CPU 可以干其他事情）</li>
<li>于是在等待 IO 时，CPU 会同时开始计算下一个循环的 IO 前的部分，并开启多轮循环同时进行的局面</li>
<li>等待 IO 结束，CPU 将剩余部分的代码再一并执行</li>
</ul>
<p><strong>单线程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dFUEmJ.png" alt="dFUEmJ" loading="lazy"></p>
<p><strong>协程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OSigeS.png" alt="OSigeS" loading="lazy"></p>
<h3 id="协程的使用以及异步-io" tabindex="-1"> 协程的使用以及异步 IO</h3>
<div><pre><code><span>import</span> asyncio

<span># 获取事件循环（超级循环）</span>
loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>

<span># 定义协程</span>
<span>async</span> <span>def</span> <span>myfunc</span><span>(</span>url<span>)</span><span>:</span>
		<span>await</span> get_url<span>(</span>url<span>)</span>

<span># 创建task列表</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>myfunc<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>

<span># 执行爬虫事件列表</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>关键字<strong>async</strong>：表示定义一个协程。</p>
<p>关键字<strong>await</strong>：表示后面的函数是一个异步 IO，并且不进行阻塞，而是直接在超级循环直接进入下一个任务的执行（当前任务放弃 CPU，下一个任务获得 CPU）。</p>
<div><p>注意</p>
<p>异步 IO 中依赖的库必须支持异步 IO 特性（这要求库在 IO 时不能阻塞，否则切换不到下一个任务了）</p>
</div>
<div><p>注意</p>
<p>requests 库不支持异步 IO，需要使用 aiohttp 库</p>
</div>
<p>例子：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
				<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
						result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
						<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所有的异步对象也需要使用 async 关键字来标注。</p>
<div><p>相关信息</p>
<p>协程与普通函数运行的不同点在于协程需要使用超级循环来进行调度。</p>
</div>
<h3 id="协程并发度的控制" tabindex="-1"> 协程并发度的控制</h3>
<p>可以使用  来进行控制：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

semaphore <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>
<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> semaphore<span>:</span>  <span># here</span>
				<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
						<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
								result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
								<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="信号量-semaphore" tabindex="-1"> 信号量 Semaphore</h2>
<div><p>相关信息</p>
<p>信号量一般用于访问有限数量的共享资源。</p>
</div>
<p>信号量是一个<strong>同步对象</strong>，用于保持在 0 至指定最大值之间的一个计数器。</p>
<ul>
<li>当线程完成一次对改 semaphore 对象的等待（wait）时，该计数器减一</li>
<li>当线程完成一次对改 semaphore 对象的释放（release）时，该计数器加一</li>
<li>当计数器为 0 时，线程等待该 semaphore 对象不再能成功直到该 semaphore 对象变成 signaled 状态（阻塞）
<ul>
<li>计数器大于 0，为 signaled 状态</li>
<li>计数器等于 0，为 nonsignaled 状态</li>
</ul>
</li>
</ul>
<div><pre><code><span># 方法一：使用with</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>async</span> <span>with</span> sem<span>:</span>
		<span># work with shared resource</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># 方法二：手动acquire、release</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>await</span> sem<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
		<span># work with shared resource</span>
<span>finally</span><span>:</span>
		sem<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" type="image/png"/>
    </item>
    <item>
      <title>Python常用数据结构</title>
      <link>https://timpcfan.site/code/language/python/python-data-structures.html</link>
      <guid>https://timpcfan.site/code/language/python/python-data-structures.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python常用数据结构</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="列表-list" tabindex="-1"> 列表 list</h2>
<h3 id="列表方法" tabindex="-1"> 列表方法</h3>
<ul>
<li>list.append(obj)</li>
<li>list.count(obj)</li>
<li>list.extend(seq)</li>
<li>list.index(obj)</li>
<li>list.insert(index, obj)</li>
<li>list.pop([index=-1])</li>
<li>list.remove(obj)</li>
<li>list.reverse()</li>
<li>list.sort(cmp=None, key=None, reverse=False)</li>
</ul>
<h3 id="列表脚本操作符" tabindex="-1"> 列表脚本操作符</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>['Hi!'] * 4</td>
<td>['Hi!', 'Hi!', 'Hi!', 'Hi!']</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<h3 id="列表截取" tabindex="-1"> 列表截取</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>'Taobao'</td>
<td>读取列表中第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>'Runoob'</td>
<td>读取列表中倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td>['Runoob', 'Taobao']</td>
<td>从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<h2 id="双向队列-deque" tabindex="-1"> 双向队列 deque</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>deque<span>(</span><span>[</span>iterable<span>[</span><span>,</span> maxlen<span>]</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>注意</p>
<p>若当作一个<strong>单向队列</strong>，append(x) 与 popleft() 才是一对。。。</p>
<ul>
<li>若当作一个<strong>栈</strong>，append(x)与 pop()就是一对</li>
</ul>
</div>
<h3 id="方法" tabindex="-1"> 方法</h3>
<ul>
<li>append(x) 添加到右侧</li>
<li>appendleft(x) 添加到左侧</li>
<li>pop() 从右侧出队</li>
<li>popleft() 从左侧出队</li>
<li>clear()</li>
<li>copy()</li>
<li>count(x)</li>
<li>extend(iter)</li>
<li>extendleft(iter)</li>
<li>index(x[, start[, stop]])</li>
<li>insert(i, x)</li>
<li>remove(x) 删除从左到右的第一个 x</li>
<li>reverse()</li>
<li>rotate(n=1)</li>
<li>maxlen</li>
</ul>
<h3 id="recipes" tabindex="-1"> Recipes</h3>
<h4 id="_1-用于实现-tail-程序" tabindex="-1"> 1. 用于实现 tail 程序</h4>
<div><pre><code><span>def</span> <span>tail</span><span>(</span>filename<span>,</span> n<span>=</span><span>10</span><span>)</span><span>:</span>
    <span>'Return the last n lines of a file'</span>
    <span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> f<span>:</span>
        <span>return</span> deque<span>(</span>f<span>,</span> n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>设置 maxlen=n，可以实现保留文本最后 n 行的功能。</p>
<h4 id="_2-用于维持一个定长的近期添加元素序列" tabindex="-1"> 2. 用于维持一个定长的近期添加元素序列</h4>
<div><pre><code><span>def</span> <span>moving_average</span><span>(</span>iterable<span>,</span> n<span>=</span><span>3</span><span>)</span><span>:</span>
    <span># moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0</span>
    <span># http://en.wikipedia.org/wiki/Moving_average</span>
    it <span>=</span> <span>iter</span><span>(</span>iterable<span>)</span>
    d <span>=</span> deque<span>(</span>itertools<span>.</span>islice<span>(</span>it<span>,</span> n<span>-</span><span>1</span><span>)</span><span>)</span>
    d<span>.</span>appendleft<span>(</span><span>0</span><span>)</span>
    s <span>=</span> <span>sum</span><span>(</span>d<span>)</span>
    <span>for</span> elem <span>in</span> it<span>:</span>
        s <span>+=</span> elem <span>-</span> d<span>.</span>popleft<span>(</span><span>)</span>
        d<span>.</span>append<span>(</span>elem<span>)</span>
        <span>yield</span> s <span>/</span> n
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_3-实现一个-round-robin-scheduler" tabindex="-1"> 3. 实现一个 round-robin scheduler</h4>
<div><pre><code><span>def</span> <span>roundrobin</span><span>(</span><span>*</span>iterables<span>)</span><span>:</span>
    <span>"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
    iterators <span>=</span> deque<span>(</span><span>map</span><span>(</span><span>iter</span><span>,</span> iterables<span>)</span><span>)</span>
    <span>while</span> iterators<span>:</span>
        <span>try</span><span>:</span>
            <span>while</span> <span>True</span><span>:</span>
                <span>yield</span> <span>next</span><span>(</span>iterators<span>[</span><span>0</span><span>]</span><span>)</span>
                iterators<span>.</span>rotate<span>(</span><span>-</span><span>1</span><span>)</span>
        <span>except</span> StopIteration<span>:</span>
            <span># Remove an exhausted iterator.</span>
            iterators<span>.</span>popleft<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_4-删除第-n-个元素" tabindex="-1"> 4. 删除第 n 个元素</h4>
<p>可以使用 rotate(n)来轻松删除第 n 个元素</p>
<div><pre><code><span>def</span> <span>delete_nth</span><span>(</span>d<span>,</span> n<span>)</span><span>:</span>
    d<span>.</span>rotate<span>(</span><span>-</span>n<span>)</span>
    d<span>.</span>popleft<span>(</span><span>)</span>
    d<span>.</span>rotate<span>(</span>n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="最小堆-heapq" tabindex="-1"> 最小堆 heapq</h2>
<p><strong>函 数</strong>                                                        <strong>描 述</strong></p>
<p>heappush(heap, x)                                将 x 压入堆中</p>
<p>heappop(heap)                                      从堆中弹出最小的元素</p>
<p>heapify(heap)                                         让列表具备堆特征</p>
<p>heapreplace(heap, x)                            弹出最小的元素，并将 x 压入堆中</p>
<p>nlargest(n, iter, key=None)                                      返回 iter 中 n 个最大的元素</p>
<p>nsmallest(n, iter, key=None)                                   返回 iter 中 n 个最小的元素</p>
<p>merge(*iters, key=None, reverse=False) 合并多个有序列表形成单独一个有序列表</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> heapq <span>import</span> <span>*</span>
<span>>></span><span>></span> <span>from</span> random <span>import</span> shuffle
<span>>></span><span>></span> data <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
<span>>></span><span>></span> shuffle<span>(</span>data<span>)</span>
<span>>></span><span>></span> heap <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> <span>for</span> n <span>in</span> data<span>:</span>
<span>.</span><span>.</span><span>.</span> heappush<span>(</span>heap<span>,</span> n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>]</span>
<span>>></span><span>></span> heappush<span>(</span>heap<span>,</span> <span>0.5</span><span>)</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>0.5</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="python-如何实现最大堆" tabindex="-1"> <strong>python 如何实现最大堆？</strong></h3>
<div><pre><code><span># 最简单的方案就是，给你的堆的元素加一个值，使值逆序排列。以下是示例代码。</span>
<span>import</span> heapq
sss <span>=</span> <span>'abecgfidhjk'</span>
ll <span>=</span> <span>list</span><span>(</span>sss<span>)</span>
heapq<span>.</span>heapify<span>(</span>ll<span>)</span>
<span>print</span><span>(</span>ll<span>)</span>
<span># ['a', 'b', 'e', 'c', 'g', 'f', 'i', 'd', 'h', 'j', 'k']</span>
<span># 此时若想得到大顶堆</span>
newl <span>=</span> <span>[</span><span>(</span><span>-</span>i<span>,</span> ll<span>[</span>i<span>]</span><span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>ll<span>)</span><span>)</span><span>]</span>
<span>#print(newl)</span>
heapq<span>.</span>heapify<span>(</span>newl<span>)</span>
<span># 此时已经按照第一个值变成了小顶堆，即变成了逆序</span>
max_heap <span>=</span> <span>list</span><span>(</span><span>)</span>
<span>while</span> newl<span>:</span>
    _<span>,</span> s <span>=</span> heapq<span>.</span>heappop<span>(</span>newl<span>)</span>
    max_heap<span>.</span>append<span>(</span>s<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="计数器-counter" tabindex="-1"> 计数器 Counter</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>Counter<span>(</span><span>[</span>iterable<span>-</span><span>or</span><span>-</span>mapping<span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Counter 是一个 dict 的子类，存着每个元素出现的次数，若访问不存在的元素会返回 0。</p>
<div><pre><code>c <span>=</span> Counter<span>(</span><span>)</span>                           <span># a new, empty counter</span>
c <span>=</span> Counter<span>(</span><span>'gallahad'</span><span>)</span>                 <span># a new counter from an iterable</span>
c <span>=</span> Counter<span>(</span><span>{</span><span>'red'</span><span>:</span> <span>4</span><span>,</span> <span>'blue'</span><span>:</span> <span>2</span><span>}</span><span>)</span>      <span># a new counter from a mapping</span>
c <span>=</span> Counter<span>(</span>cats<span>=</span><span>4</span><span>,</span> dogs<span>=</span><span>8</span><span>)</span>             <span># a new counter from keyword args</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>直接以字典的方式去访问 Counter</p>
<div><pre><code>c<span>[</span><span>'cats'</span><span>]</span>         <span># return 4</span>
c<span>[</span><span>'cats'</span><span>]</span> <span>+=</span> <span>1</span>    <span># add one more cat</span>
c<span>[</span><span>'pigs'</span><span>]</span>         <span># missing value will return 0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>elements()</strong> 返回一个 iterator 根据每个元素的数量来访问所有元素（会忽略数量为 0 或负的元素）</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>c<span>.</span>elements<span>(</span><span>)</span><span>)</span>
<span>[</span><span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'b'</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>*<strong>*most_common**</strong>([<em>n</em>]) 返回一个 tuple 列表，包含按元素数量排序的最常见的元素列表</p>
<div><pre><code><span>>></span><span>></span> Counter<span>(</span><span>'abracadabra'</span><span>)</span><span>.</span>most_common<span>(</span><span>3</span><span>)</span>
<span>[</span><span>(</span><span>'a'</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>(</span><span>'b'</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>(</span><span>'r'</span><span>,</span> <span>2</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>*<strong>*subtract**</strong>([<em>iterable-or-mapping</em>]) 两个 Counter 可以相减</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>3</span><span>,</span> d<span>=</span><span>4</span><span>)</span>
<span>>></span><span>></span> c<span>.</span>subtract<span>(</span>d<span>)</span>
<span>>></span><span>></span> c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>0</span><span>,</span> <span>'c'</span><span>:</span> <span>-</span><span>3</span><span>,</span> <span>'d'</span><span>:</span> <span>-</span><span>6</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>*<strong>*fromkeys**</strong>(<em>iterable</em>) 没有对 Counter 实现该方法（dict 的类方法，用于根据 dict 的键生成一个新的 dict）</p>
<p>*<strong>*update**</strong>([<em>iterable-or-mapping</em>]) 与 dict 的 update 一样</p>
<p>其他的一些操作：</p>
<div><pre><code><span>sum</span><span>(</span>c<span>.</span>values<span>(</span><span>)</span><span>)</span>                 <span># total of all counts</span>
c<span>.</span>clear<span>(</span><span>)</span>                       <span># reset all counts</span>
<span>list</span><span>(</span>c<span>)</span>                         <span># list unique elements</span>
<span>set</span><span>(</span>c<span>)</span>                          <span># convert to a set</span>
<span>dict</span><span>(</span>c<span>)</span>                         <span># convert to a regular dictionary</span>
c<span>.</span>items<span>(</span><span>)</span>                       <span># convert to a list of (elem, cnt) pairs</span>
Counter<span>(</span><span>dict</span><span>(</span>list_of_pairs<span>)</span><span>)</span>    <span># convert from a list of (elem, cnt) pairs</span>
c<span>.</span>most_common<span>(</span><span>)</span><span>[</span><span>:</span><span>-</span>n<span>-</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]</span>       <span># n least common elements</span>
<span>+</span>c                              <span># remove zero and negative counts</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>3</span><span>,</span> b<span>=</span><span>1</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>)</span>
<span>>></span><span>></span> c <span>+</span> d                       <span># add two counters together:  c[x] + d[x]</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>4</span><span>,</span> <span>'b'</span><span>:</span> <span>3</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>-</span> d                       <span># subtract (keeping only positive counts)</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>&amp;</span> d                       <span># intersection:  min(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>1</span><span>,</span> <span>'b'</span><span>:</span> <span>1</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>|</span> d                       <span># union:  max(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>2</span><span>}</span><span>)</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>2</span><span>,</span> b<span>=</span><span>-</span><span>4</span><span>)</span>
<span>>></span><span>></span> <span>+</span>c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> <span>-</span>c
Counter<span>(</span><span>{</span><span>'b'</span><span>:</span> <span>4</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="随机队列-randomizedqueue" tabindex="-1"> 随机队列 RandomizedQueue</h2>
<div><p>相关信息</p>
<p>自创数据结构，在工作中使用</p>
</div>
<div><pre><code><span>class</span> <span>RandomizedQueue</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> _iter<span>=</span><span>[</span><span>]</span><span>)</span><span>:</span>
        self<span>.</span>arr <span>=</span> <span>[</span><span>*</span>_iter<span>]</span>
    <span>def</span> <span>append</span><span>(</span>self<span>,</span> val<span>)</span><span>:</span>
        self<span>.</span>arr<span>.</span>append<span>(</span>val<span>)</span>
    <span>def</span> <span>remove</span><span>(</span>self<span>,</span> idx<span>)</span><span>:</span>
        <span>if</span> idx <span>>=</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>:</span>
            <span>return</span>
        r <span>=</span> self<span>.</span>arr<span>[</span>idx<span>]</span>
        self<span>.</span>arr<span>[</span>idx<span>]</span> <span>=</span> self<span>.</span>arr<span>[</span><span>-</span><span>1</span><span>]</span>  <span># 将最后一个元素移动到删除的元素位置</span>
        self<span>.</span>arr<span>.</span>pop<span>(</span><span>)</span>
        <span>return</span> r
    <span>def</span> <span>getRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        <span>return</span> self<span>.</span>arr<span>[</span><span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span><span>]</span>
    <span>def</span> <span>popRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        idx <span>=</span> <span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span>
        <span>return</span> self<span>.</span>remove<span>(</span>idx<span>)</span>
    <span>def</span> <span>__len__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>入队：O(1)</li>
<li>获取随机元素：O(1)</li>
<li>随机出队：O(1)</li>
<li>删除指定位置的元素：O(1)</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>