<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://timpcfan.site/rss.xml" rel="self" type="application/rss+xml"/>
    <title>TrystanLei</title>
    <link>https://timpcfan.site/</link>
    <description>积累点滴，汇聚成溪。</description>
    <language>zh-CN</language>
    <pubDate>Mon, 03 Oct 2022 01:10:25 GMT</pubDate>
    <lastBuildDate>Mon, 03 Oct 2022 01:10:25 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>笔记</category>
    <category>API</category>
    <category>转载</category>
    <item>
      <title>Python异步I/O与协程</title>
      <link>https://timpcfan.site/code/language/python/python-asyncio.html</link>
      <guid>https://timpcfan.site/code/language/python/python-asyncio.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python异步I/O与协程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>注意</p>
<p>这里实际上就是官方文档的搬运，非常不完整，建议直接看<a href="https://docs.python.org/zh-cn/3.10/library/asyncio.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2 id="asyncio-—-异步-i-o-协程" tabindex="-1"> asyncio — 异步 I/O &amp; 协程</h2>
<p>协程运行的原理见： <a href="/code/language/python/python-concurrent.html#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81">协程的原理以及代码</a></p>
<p>asyncio 是用来编写  <strong>并发</strong>  代码的库，使用  <strong>async/await</strong>  语法。</p>
<p>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。</p>
<p>asyncio 往往是构建 IO 密集型和高层级  <strong>结构化</strong>  网络代码的最佳选择。</p>
<p>asyncio 提供一组  <strong>高层级</strong> API 用于:</p>
<ul>
<li>并发地  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">运行 Python 协程</a>  并对其执行过程实现完全控制;</li>
<li>执行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">网络 IO 和 IPC</a>;</li>
<li>控制  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程</a>;</li>
<li>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列</a>  实现分布式任务;</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio-sync" target="_blank" rel="noopener noreferrer">同步</a>  并发代码;</li>
</ul>
<p>此外，还有一些  <strong>低层级</strong> API 以支持  <em>库和框架的开发者</em>  实现:</p>
<ul>
<li>创建和管理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio-event-loop" target="_blank" rel="noopener noreferrer">事件循环</a>，以提供异步 API 用于  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.create_server" target="_blank" rel="noopener noreferrer">网络化</a>, 运行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec" target="_blank" rel="noopener noreferrer">子进程</a>，处理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler" target="_blank" rel="noopener noreferrer">OS 信号</a>  等等;</li>
<li>使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-protocol.html#asyncio-transports-protocols" target="_blank" rel="noopener noreferrer">transports</a>  实现高效率协议;</li>
<li>通过 async/await 语法  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio-futures" target="_blank" rel="noopener noreferrer">桥接</a>  基于回调的库和代码。</li>
</ul>
<h2 id="协程与任务" tabindex="-1"> 协程与任务 <sup></sup></h2>
<h3 id="协程" tabindex="-1"> 协程</h3>
<p>通过 async/await 关键字来定义的协程是一种被推荐的编写异步程序的方式。</p>
<p>下面的代码定义并运行了一个协程：</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> asyncio

<span>>></span><span>></span> <span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'hello'</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'world'</span><span>)</span>

<span>>></span><span>></span> asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
hello
world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：简单地调用一个协程并不会使其被调度执行。</p>
<div><pre><code><span>>></span><span>></span> main<span>(</span><span>)</span>
<span>&lt;</span>coroutine <span>object</span> main at <span>0x1053bb7c8</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>要正在运行一个协程，asyncio 提供了三种主要机制：</p>
<ol>
<li>
<p><code>asyncio.run()</code> 函数用来运行最高层级的入口点 “main()” 函数</p>
</li>
<li>
<p><code>await</code> 一个协程。以下代码会在等待 1 秒后打印“hello”，然后等待 2 秒后打印“world”。（await 一个协程会让其开始运行，并等待其完成）</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> time

<span>async</span> <span>def</span> <span>say_after</span><span>(</span>delay<span>,</span> what<span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span>delay<span>)</span>
    <span>print</span><span>(</span>what<span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span>
    <span>await</span> say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># started at 17:13:52</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:13:55</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><code>asyncio.create_task()</code> 函数用来并发运行作为 asyncio 任务的多个协程。（create_task()之后会使任务出于就绪状态随时准备运行，而 await task 则是等待这个任务运行完成）</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    task1 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span><span>)</span>

    task2 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span># Wait until both tasks are completed (should take</span>
    <span># around 2 seconds.)</span>
    <span>await</span> task1
    <span>await</span> task2

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span># 比上面的要快1秒，因为两个task是同时运行的</span>
<span># started at 17:14:32</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:14:34</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h3 id="可等待对象-awaitable-objects" tabindex="-1"> 可等待对象 awaitable objects</h3>
<p>如果一个对象可以在 await 语句中使用，那么它就是 awaitable 对象。许多 asyncio API 都被设计为接受 awaitable 对象。</p>
<p>可等待 对象有三种主要类型：协程（Coroutine）、任务（Task）、Future。</p>
<h3 id="协程-1" tabindex="-1"> 协程</h3>
<p>Python 协程属于可等待对象，因此可以在其他协程中被等待：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Nothing happens if we just call "nested()".</span>
    <span># A coroutine object is created but not awaited,</span>
    <span># so it *won't run at all*.</span>
    nested<span>(</span><span>)</span>  <span># 这个不会运行，只是单纯返回了一个coroutine对象</span>

    <span># Let's do it differently now and await it:</span>
    <span>print</span><span>(</span><span>await</span> nested<span>(</span><span>)</span><span>)</span>  <span># will print "42".  # 这里会运行，因为有await</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>重要</strong></p>
<p>在本文档中 &quot;协程&quot; 可用来表示两个紧密关联的概念:</p>
<ul>
<li><em>协程函数</em>: 定义形式为  <code>[async def](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def)</code>  的函数;</li>
<li><em>协程对象</em>: 调用  <em>协程函数</em>  所返回的对象。</li>
</ul>
<h3 id="任务" tabindex="-1"> 任务</h3>
<p>Task 被用来 “并行地” 调度协程。</p>
<p>当一个协程通过 asyncio.create_task() 等函数被封装为了一个 Task，该协程会被自动调度执行：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule nested() to run soon concurrently</span>
    <span># with "main()".</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>nested<span>(</span><span>)</span><span>)</span>  <span># 这里 task 就开始运行了</span>

    <span># "task" can now be used to cancel "nested()", or</span>
    <span># can simply be awaited to wait until it is complete:</span>
    <span>await</span> task  <span># 这里只是单纯地等待其运行完</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="futures" tabindex="-1"> Futures</h3>
<p>Future 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p>
<p>在 asyncio 中需要 Future 对象以便允许 async/await 使用基于回调的代码。</p>
<p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p>
<p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象：</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> function_that_returns_a_future_object<span>(</span><span>)</span>

    <span># this is also valid:</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        function_that_returns_a_future_object<span>(</span><span>)</span><span>,</span>
        some_python_coroutine<span>(</span><span>)</span>
    <span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>一个很好的返回对象的低层级函数的示例是：loop.run_in_executor()</p>
<h3 id="运行-asyncio-程序" tabindex="-1"> 运行 asyncio 程序</h3>
<p><code>asyncio.run(coro, *, debug=False)</code></p>
<p>执行 coro 并返回结果。</p>
<p>吃函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。</p>
<p>但有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 debug 为 True，事件循环将以调试模式运行。</p>
<p>此函数<strong>总是会创建一个新的事件循环</strong>并在结束时关闭之。它应当用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'hello'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="创建任务" tabindex="-1"> 创建任务</h3>
<p><code>asyncio.create_task(coro, *, name=None)</code></p>
<p>将 coro 封装为一个 Task 并调度其执行。返回 Task 对象。</p>
<p>name 不为 None 时，它将使用 Task.set_name() 来设为任务的名称。</p>
<p>该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。</p>
<div><p>相关信息</p>
<p>需要保存这个方法返回值 Task 的引用，因为 event_loop 中只会保存一个弱引用，如果不保存引用，可能这个协程没有被执行完毕就被垃圾回收给清理了。</p>
</div>
<div><pre><code>background_tasks <span>=</span> <span>set</span><span>(</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>some_coro<span>(</span>param<span>=</span>i<span>)</span><span>)</span>

    <span># Add task to the set. This creates a strong reference.</span>
    background_tasks<span>.</span>add<span>(</span>task<span>)</span>

    <span># To prevent keeping references to finished tasks forever,</span>
    <span># make each task remove its own reference from the set after</span>
    <span># completion:</span>
    task<span>.</span>add_done_callback<span>(</span>background_tasks<span>.</span>discard<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="休眠" tabindex="-1"> 休眠</h3>
<p><code>coroutine asyncio.sleep(delay, result=None)</code></p>
<p>阻塞 delay 指定的秒数。</p>
<p>如果指定了 result，则当协程完成时 result 其返回给调用者。</p>
<p>sleep() 总是会挂起当前任务，以允许其他任务运行。</p>
<p>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行。 这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</p>
<p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> datetime

<span>async</span> <span>def</span> <span>display_date</span><span>(</span><span>)</span><span>:</span>
    loop <span>=</span> asyncio<span>.</span>get_running_loop<span>(</span><span>)</span>
    end_time <span>=</span> loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>5.0</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>)</span>
        <span>if</span> <span>(</span>loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>1.0</span><span>)</span> <span>>=</span> end_time<span>:</span>
            <span>break</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>

asyncio<span>.</span>run<span>(</span>display_date<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="并发运行任务" tabindex="-1"> 并发运行任务</h3>
<p><code>awaitable asyncio.gather(*aws, return_exceptions=False)</code></p>
<p><em>并发</em> 运行 aws 序列中的 可等待对象。</p>
<p>如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务调度。</p>
<p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而层的列表。结果值的顺序与 aws 中可等待对象的<strong>顺序一致</strong>。</p>
<p>如果 return_exceptions 为 False，所引发的首个异常会立即传播给等待 gather() 的任务。aws 序列中的其他可等待对象 <strong>不会被取消</strong> 并继续运行。</p>
<p>如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<p>如果 gather() 被取消，所有被提交（尚未完成）的可等待对象也会 被取消。</p>
<p>如果 aws 序列中的任一 Task 或 Future 对象 被取消，它将被当作引发了 CancelledError 一样处理 — 在此情况下 gather() 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>factorial</span><span>(</span>name<span>,</span> number<span>)</span><span>:</span>
    f <span>=</span> <span>1</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> number <span>+</span> <span>1</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: Compute factorial(</span><span><span>{</span>number<span>}</span></span><span>), currently i=</span><span><span>{</span>i<span>}</span></span><span>..."</span></span><span>)</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        f <span>*=</span> i
    <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: factorial(</span><span><span>{</span>number<span>}</span></span><span>) = </span><span><span>{</span>f<span>}</span></span><span>"</span></span><span>)</span>
    <span>return</span> f

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule three calls *concurrently*:</span>
    L <span>=</span> <span>await</span> asyncio<span>.</span>gather<span>(</span>
        factorial<span>(</span><span>"A"</span><span>,</span> <span>2</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"B"</span><span>,</span> <span>3</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"C"</span><span>,</span> <span>4</span><span>)</span><span>,</span>
    <span>)</span>
    <span>print</span><span>(</span>L<span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     Task A: Compute factorial(2), currently i=2...</span>
<span>#     Task B: Compute factorial(3), currently i=2...</span>
<span>#     Task C: Compute factorial(4), currently i=2...</span>
<span>#     Task A: factorial(2) = 2</span>
<span>#     Task B: Compute factorial(3), currently i=3...</span>
<span>#     Task C: Compute factorial(4), currently i=3...</span>
<span>#     Task B: factorial(3) = 6</span>
<span>#     Task C: Compute factorial(4), currently i=4...</span>
<span>#     Task C: factorial(4) = 24</span>
<span>#     [2, 6, 24]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>如果  <em>return_exceptions</em>  为 False，则在 gather() 被标记为已完成后取消它将不会取消任何已提交的可等待对象。 例如，在将一个异常传播给调用者之后，gather 可被标记为已完成，因此，在从 gather 捕获一个（由可等待对象所引发的）异常之后调用  <code>gather.cancel()</code>  将不会取消任何其他可等待对象。</p>
</div>
<h3 id="屏蔽取消操作" tabindex="-1"> 屏蔽取消操作</h3>
<p><code>awaitable asyncio.shield(aw)</code></p>
<p>保护一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  防止其被  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p>以下语句:</p>
<p><code>res = **await** shield(something())</code></p>
<p>相当于:</p>
<p><code>res = **await** something()</code></p>
<p><em>不同之处</em>  在于如果包含它的协程被取消，在  <code>something()</code>  中运行的任务不会被取消。从  <code>something()</code>  的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 &quot;await&quot; 表达式仍然会引发<a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>。</p>
<h3 id="超时" tabindex="-1"> 超时</h3>
<p><code>coroutine asyncio.wait_for(aw, timeout)</code></p>
<p>等待  <em>aw</em> <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  完成，指定 timeout 秒数后超时。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p><em>timeout</em>  可以为  <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果  <em>timeout</em>  为  <code>None</code>，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>.</p>
<p>要避免任务  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>，可以加上  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener noreferrer">shield()</a>。</p>
<p>此函数将等待直到 Future 确实被取消，所以总等待时间可能超过  <em>timeout</em>。 如果在取消期间发生了异常，异常将会被传播。</p>
<p>如果等待被取消，则  <em>aw</em>  指定的对象也会被取消。</p>
<div><pre><code><span>async</span> <span>def</span> <span>eternity</span><span>(</span><span>)</span><span>:</span>
    <span># Sleep for one hour</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>3600</span><span>)</span>
    <span>print</span><span>(</span><span>'yay!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Wait for at most 1 second</span>
    <span>try</span><span>:</span>
        <span>await</span> asyncio<span>.</span>wait_for<span>(</span>eternity<span>(</span><span>)</span><span>,</span> timeout<span>=</span><span>1.0</span><span>)</span>
    <span>except</span> asyncio<span>.</span>TimeoutError<span>:</span>
        <span>print</span><span>(</span><span>'timeout!'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     timeout!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="简单等待" tabindex="-1"> 简单等待</h3>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  并进入阻塞状态直到满足  <em>return_when</em>  所指定的条件。</p>
<p><em>aws</em>  可迭代对象必须不为空。</p>
<p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p>
<p>用法：</p>
<p><code>done, pending = **await** asyncio.wait(aws)</code></p>
<p>如指定  <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p>
<p>请注意此函数不会引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p>
<p><em>return_when</em>  指定此函数应在何时返回。它必须为以下常数之一:</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIRST_COMPLETED</td>
<td>函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于  ALL_COMPLETED。</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td>函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody>
</table>
<p><code>asyncio.as_completed(aws, *, timeout=None)</code></p>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>。 返回一个协程的迭代器。 所返回的每个协程可被等待以从剩余的可等待对象的可迭代对象中获得最早的下一个结果。</p>
<p>如果在所有 Future 对象完成前发生超时则将引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。</p>
<div><pre><code><span>for</span> coro <span>in</span> as_completed<span>(</span>aws<span>)</span><span>:</span>
    earliest_result <span>=</span> <span>await</span> coro
    <span># ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="在线程中运行" tabindex="-1"> 在线程中运行</h3>
<p><code>coroutine asyncio.to_thread(func, /, *args, **kwargs)</code></p>
<p>在不同的线程中异步地运行函数  <em>func</em>。</p>
<p>向此函数提供的任何 *args 和 **kwargs 会被直接传给  *func*。 并且，当前  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#contextvars.Context" target="_blank" rel="noopener noreferrer">contextvars.Context</a>  会被传播，允许在不同的线程中访问来自事件循环的上下文变量。</p>
<p>返回一个可被等待以获取  <em>func</em>  的最终结果的协程。</p>
<p>这个协程函数主要是用于执行在其他情况下会阻塞事件循环的 IO 密集型函数/方法。 例如:</p>
<div><pre><code><span>def</span> <span>blocking_io</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"start blocking_io at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>
    <span># Note that time.sleep() can be replaced with any blocking</span>
    <span># IO-bound operation, such as file operations.</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"blocking_io complete at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        asyncio<span>.</span>to_thread<span>(</span>blocking_io<span>)</span><span>,</span>
        asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span># started main at 19:50:53</span>
<span># start blocking_io at 19:50:53</span>
<span># blocking_io complete at 19:50:54</span>
<span># finished main at 19:50:54</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在任何协程中直接调用  blocking_io() 将会在调用期间阻塞事件循环，导致额外的 1 秒运行时间。 而通过改用  asyncio.to_thread()，我们可以在不同的线程中运行它从而不会阻塞事件循环。</p>
<h3 id="跨线程调度" tabindex="-1"> 跨线程调度</h3>
<p><code>asyncio.run_coroutine_threadsafe(coro, loop)</code></p>
<p>向指定事件循环提交一个协程。（线程安全）</p>
<p>返回一个  <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener noreferrer">concurrent.futures.Future</a>  以等待来自其他 OS 线程的结果。</p>
<p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p>
<div><pre><code><span># Create a coroutine</span>
coro <span>=</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>,</span> result<span>=</span><span>3</span><span>)</span>

<span># Submit the coroutine to a given loop</span>
future <span>=</span> asyncio<span>.</span>run_coroutine_threadsafe<span>(</span>coro<span>,</span> loop<span>)</span>

<span># Wait for the result with an optional timeout argument</span>
<span>assert</span> future<span>.</span>result<span>(</span>timeout<span>)</span> <span>==</span> <span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p>
<div><pre><code><span>try</span><span>:</span>
    result <span>=</span> future<span>.</span>result<span>(</span>timeout<span>)</span>
<span>except</span> concurrent<span>.</span>futures<span>.</span>TimeoutError<span>:</span>
    <span>print</span><span>(</span><span>'The coroutine took too long, cancelling the task...'</span><span>)</span>
    future<span>.</span>cancel<span>(</span><span>)</span>
<span>except</span> Exception <span>as</span> exc<span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine raised an exception: </span><span><span>{</span>exc<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine returned: </span><span><span>{</span>result<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>参见  <a href="https://docs.python.org/zh-cn/3/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener noreferrer">concurrency and multithreading</a>  部分的文档。</p>
<p>不同与其他 asyncio 函数，此函数要求显式地传入  <em>loop</em>  参数。</p>
<h3 id="内省" tabindex="-1"> 内省</h3>
<p><code>asyncio.**current_task**(*loop=None*)</code></p>
<p>返回当前运行的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  实例，如果没有正在运行的任务则返回  <code>None</code>。
如果  <em>loop</em>  为  <code>None</code>  则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<p><code>asyncio.**all_tasks**(*loop=None*)</code></p>
<p>返回事件循环所运行的未完成的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  对象的集合。
如果  <em>loop</em>  为  <code>None</code>，则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<h3 id="task-对象" tabindex="-1"> Task 对象</h3>
<p><code>class asyncio.Task(coro, *, loop=None, name=None)</code></p>
<p>一个与  <code>[Future 类似](https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future)</code>  的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程</a>。非线程安全。</p>
<p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象  <em>完成</em>，被打包的协程将恢复执行。</p>
<p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p>
<p>使用高层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数来创建 Task 对象，也可用低层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener noreferrer">loop.create_task()</a>  或  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener noreferrer">ensure_future()</a>  函数。不建议手动实例化 Task 对象。</p>
<p>要取消一个正在运行的 Task 对象可使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">cancel()</a>  方法。调用此方法将使该 Task 对象抛出一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener noreferrer">cancelled()</a>  可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常并且确实被取消，该方法将返回  <code>True</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">asyncio.Task</a>  从  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener noreferrer">Future</a>  继承了其除  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener noreferrer">Future.set_result()</a>  和  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener noreferrer">Future.set_exception()</a>  以外的所有 API。</p>
<p>Task 对象支持  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#module-contextvars" target="_blank" rel="noopener noreferrer">contextvars</a>  模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p>
<ul>
<li>cancel(msg=None)：取消任务，这将抛出 CancelledError</li>
<li>done()：如果 Task 对象已完成，则返回 true</li>
<li>result()：返回 Task 的结果</li>
<li>add_done_callback(callback, *, context=None)：添加一个回调，在 Task 完成时调用。</li>
</ul>
<h2 id="stream-流" tabindex="-1"> Stream 流 <sup></sup></h2>
<p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p>
<h3 id="stream-函数" tabindex="-1"> Stream 函数</h3>
<ul>
<li>open_connection</li>
<li>start_server</li>
</ul>
<h3 id="unix-套接字-socket" tabindex="-1"> Unix 套接字（Socket）</h3>
<ul>
<li>open_unix_connection</li>
<li>start_unix_server</li>
</ul>
<h3 id="streamreader-与-streamwriter" tabindex="-1"> StreamReader 与 StreamWriter</h3>
<h3 id="例子-echo-服务器与客户端" tabindex="-1"> 例子：echo 服务器与客户端</h3>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>handle_echo</span><span>(</span>reader<span>,</span> writer<span>)</span><span>:</span>
    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    message <span>=</span> data<span>.</span>decode<span>(</span><span>)</span>
    addr <span>=</span> writer<span>.</span>get_extra_info<span>(</span><span>'peername'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Received </span><span><span>{</span>message<span>!r</span><span>}</span></span><span> from </span><span><span>{</span>addr<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>data<span>)</span>
    <span>await</span> writer<span>.</span>drain<span>(</span><span>)</span>

    <span>print</span><span>(</span><span>"Close the connection"</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> <span>await</span> asyncio<span>.</span>start_server<span>(</span>
        handle_echo<span>,</span> <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    addrs <span>=</span> <span>', '</span><span>.</span>join<span>(</span><span>str</span><span>(</span>sock<span>.</span>getsockname<span>(</span><span>)</span><span>)</span> <span>for</span> sock <span>in</span> server<span>.</span>sockets<span>)</span>
    <span>print</span><span>(</span><span><span>f'Serving on </span><span><span>{</span>addrs<span>}</span></span><span>'</span></span><span>)</span>

    <span>async</span> <span>with</span> server<span>:</span>
        <span>await</span> server<span>.</span>serve_forever<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>tcp_echo_client</span><span>(</span>message<span>)</span><span>:</span>
    reader<span>,</span> writer <span>=</span> <span>await</span> asyncio<span>.</span>open_connection<span>(</span>
        <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    <span>print</span><span>(</span><span><span>f'Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>message<span>.</span>encode<span>(</span><span>)</span><span>)</span>

    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'Received: </span><span><span>{</span>data<span>.</span>decode<span>(</span><span>)</span><span>!r</span><span>}</span></span><span>'</span></span><span>)</span>

    <span>print</span><span>(</span><span>'Close the connection'</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>tcp_echo_client<span>(</span><span>'Hello World!'</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="同步原语" tabindex="-1"> 同步原语 <sup></sup></h2>
<p>asyncio 同步原语被设计为与  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>  模块的类似，但有两个关键注意事项:</p>
<ul>
<li>asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>)；</li>
<li>这些同步原语的方法不接受  <em>timeout</em>  参数；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数来执行带有超时的操作。</li>
</ul>
<p>asyncio 具有下列基本同步原语:</p>
<h3 id="lock" tabindex="-1"> Lock</h3>
<p><code>class asyncio.Lock</code></p>
<p>实现一个用于 asyncio 任务的互斥锁。 非线程安全。</p>
<p>asyncio 锁可被用来保证对共享资源的独占访问。</p>
<p>使用 Lock 的推荐方式是通过  <code>[async with](https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with)</code>  语句:</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>async</span> <span>with</span> lock<span>:</span>
    <span># access shared state</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这等价于：</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>await</span> lock<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
    <span># access shared state</span>
<span>finally</span><span>:</span>
    lock<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine acquire()</code></p>
<p>获取锁。
此方法会等待直至锁为  <em>unlocked</em>，将其设为  <em>locked</em>  并返回  <code>True</code>。
当有一个以上的协程在  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Lock.acquire" target="_blank" rel="noopener noreferrer">acquire()</a>  中被阻塞则会等待解锁，最终只有一个协程会被执行。
锁的获取是  <em>公平的</em>: 被执行的协程将是第一个开始等待锁的协程。</p>
<p><code>release()</code></p>
<p>释放锁。</p>
<p>当锁为  <em>locked</em>  时，将其设为  <em>unlocked</em>  并返回。</p>
<p>如果锁为  <em>unlocked</em>，则会引发  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" target="_blank" rel="noopener noreferrer">RuntimeError</a>。</p>
<p><code>locked()</code></p>
<p>如果锁为  <em>locked</em>  则返回  <code>True</code>。</p>
<h3 id="event" tabindex="-1"> Event</h3>
<p><code>class asyncio.Event</code></p>
<p>事件对象。 该对象不是线程安全的。</p>
<p>asyncio 事件可被用来通知多个 asyncio 任务已经有事件发生。</p>
<p>Event 对象会管理一个内部旗标，可通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法将其设为  <em>true</em>  并通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.clear" target="_blank" rel="noopener noreferrer">clear()</a>  方法将其重设为  <em>false</em>。 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  方法会阻塞直至该旗标被设为  <em>true</em>。 该旗标初始时会被设为  <em>false</em>。</p>
<div><pre><code><span>async</span> <span>def</span> <span>waiter</span><span>(</span>event<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'waiting for it ...'</span><span>)</span>
    <span>await</span> event<span>.</span>wait<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>'... got it!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create an Event object.</span>
    event <span>=</span> asyncio<span>.</span>Event<span>(</span><span>)</span>

    <span># Spawn a Task to wait until 'event' is set.</span>
    waiter_task <span>=</span> asyncio<span>.</span>create_task<span>(</span>waiter<span>(</span>event<span>)</span><span>)</span>

    <span># Sleep for 1 second and set the event.</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    event<span>.</span><span>set</span><span>(</span><span>)</span>

    <span># Wait until the waiter task is finished.</span>
    <span>await</span> waiter_task

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine wait()</code></p>
<p>等待直至事件被设置。</p>
<p>如果事件已被设置，则立即返回  <code>True</code>。 否则将阻塞直至另一个任务调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>。</p>
<p><code>set()</code></p>
<p>设置事件。</p>
<p>所有等待事件被设置的任务将被立即唤醒。</p>
<p><code>clear()</code></p>
<p>清空（取消设置）事件。</p>
<p>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  进行等待的任务现在将会阻塞直至  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法被再次调用。</p>
<p><code>is_set()</code></p>
<p>如果事件已被设置则返回  <code>True</code>。</p>
<h3 id="condition" tabindex="-1"> Condition</h3>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition" target="_blank" rel="noopener noreferrer">https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition</a></p>
<h3 id="semaphore" tabindex="-1"> Semaphore</h3>
<h3 id="boundedsemaphore" tabindex="-1"> BoundedSemaphore</h3>
<h2 id="队列集合" tabindex="-1"> 队列集合 <sup></sup></h2>
<p>asyncio 队列被设计成与  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a>  模块类似。尽管 asyncio 队列不是线程安全的，但是他们是被设计专用于 async/await 代码。</p>
<p>注意 asyncio 的队列没有  <em>timeout</em>  形参；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数为队列添加超时操作。</p>
<p>参见下面的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#examples" target="_blank" rel="noopener noreferrer">Examples</a>  部分。</p>
<h3 id="queue" tabindex="-1"> Queue</h3>
<p><code>class asyncio.Queue(maxsize=0)</code></p>
<p>FIFO 队列</p>
<p>如果  <em>maxsize</em>  小于等于零，则队列尺寸是无限的。如果是大于  <code>0</code>  的整数，则当队列达到  <em>maxsize</em>  时， <code>await put()</code>  将阻塞至某个元素被  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.get" target="_blank" rel="noopener noreferrer">get()</a>  取出。</p>
<p>不像标准库中的并发型  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a> ，队列的尺寸一直是已知的，可以通过调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.qsize" target="_blank" rel="noopener noreferrer">qsize()</a>  方法返回。</p>
<ul>
<li>maxsize</li>
<li>empty()</li>
<li>full()</li>
<li>coroutine join()</li>
<li>get_nowait() 不阻塞的出队</li>
<li>coroutine join() 阻塞至队列中所有的元素都被接收和处理完毕。
<ul>
<li>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费协程调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.task_done" target="_blank" rel="noopener noreferrer">task_done()</a>表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.join" target="_blank" rel="noopener noreferrer">join()</a>阻塞被解除。</li>
</ul>
</li>
<li>coroutine put(item)</li>
<li>put_nowait(item) 不阻塞的入队</li>
<li>qsize()</li>
<li>task_done() 表明前面排队的任务已经完成，即 get 出来的元素相关操作已经完成。</li>
</ul>
<h3 id="优先级队列" tabindex="-1"> 优先级队列</h3>
<p><code>class asyncio.PriorityQueue</code></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue" target="_blank" rel="noopener noreferrer">Queue</a>  的变体；按优先级顺序取出条目 (最小的先取出)。</p>
<p>条目通常是  <code>(priority_number, data)</code>  形式的元组。</p>
<h3 id="后进先出队列" tabindex="-1"> <strong>后进先出队列</strong></h3>
<p><code>class asyncio.LifoQueue</code></p>
<h3 id="例子" tabindex="-1"> 例子</h3>
<div><pre><code><span>import</span> asyncio
<span>import</span> random
<span>import</span> time

<span>async</span> <span>def</span> <span>worker</span><span>(</span>name<span>,</span> queue<span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        <span># Get a "work item" out of the queue.</span>
        sleep_for <span>=</span> <span>await</span> queue<span>.</span>get<span>(</span><span>)</span>

        <span># Sleep for the "sleep_for" seconds.</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span>sleep_for<span>)</span>

        <span># Notify the queue that the "work item" has been processed.</span>
        queue<span>.</span>task_done<span>(</span><span>)</span>

        <span>print</span><span>(</span><span><span>f'</span><span><span>{</span>name<span>}</span></span><span> has slept for </span><span><span>{</span>sleep_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create a queue that we will use to store our "workload".</span>
    queue <span>=</span> asyncio<span>.</span>Queue<span>(</span><span>)</span>

    <span># Generate random timings and put them into the queue.</span>
    total_sleep_time <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>20</span><span>)</span><span>:</span>
        sleep_for <span>=</span> random<span>.</span>uniform<span>(</span><span>0.05</span><span>,</span> <span>1.0</span><span>)</span>
        total_sleep_time <span>+=</span> sleep_for
        queue<span>.</span>put_nowait<span>(</span>sleep_for<span>)</span>

    <span># Create three worker tasks to process the queue concurrently.</span>
    tasks <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>worker<span>(</span><span><span>f'worker-</span><span><span>{</span>i<span>}</span></span><span>'</span></span><span>,</span> queue<span>)</span><span>)</span>
        tasks<span>.</span>append<span>(</span>task<span>)</span>

    <span># Wait until the queue is fully processed.</span>
    started_at <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span>
    <span>await</span> queue<span>.</span>join<span>(</span><span>)</span>
    total_slept_for <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span> <span>-</span> started_at

    <span># Cancel our worker tasks.</span>
    <span>for</span> task <span>in</span> tasks<span>:</span>
        task<span>.</span>cancel<span>(</span><span>)</span>
    <span># Wait until all worker tasks are cancelled.</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span><span>*</span>tasks<span>,</span> return_exceptions<span>=</span><span>True</span><span>)</span>

    <span>print</span><span>(</span><span>'===='</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'3 workers slept in parallel for </span><span><span>{</span>total_slept_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>
    <span>print</span><span>(</span><span><span>f'total expected sleep time: </span><span><span>{</span>total_sleep_time<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="事件循环" tabindex="-1"> 事件循环 <sup></sup></h2>
<h3 id="前言" tabindex="-1"> <strong>前言</strong></h3>
<p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p>
<p>应用开发者通常应当使用高层级的 asyncio 函数，例如  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener noreferrer">asyncio.run()</a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p>
<h2 id="高层级-api-索引" tabindex="-1"> 高层级 API 索引 <sup></sup></h2>
<p>这个页面列举了所有能用于 async/wait 的高层级 asyncio API 集。</p>
<h3 id="任务-1" tabindex="-1"> 任务</h3>
<p>运行异步程序，创建 Task 对象，等待多件事运行超时的公共集。</p>
<table>
<thead>
<tr>
<th>run()</th>
<th>创建事件循环，运行一个协程，关闭事件循环。</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_task()</td>
<td>启动一个 asyncio 的 Task 对象。</td>
</tr>
<tr>
<td>await sleep()</td>
<td>休眠几秒。</td>
</tr>
<tr>
<td>await gather()</td>
<td>并发执行所有事件的调度和等待。</td>
</tr>
<tr>
<td>await wait_for()</td>
<td>有超时控制的运行。</td>
</tr>
<tr>
<td>await shield()</td>
<td>屏蔽取消操作</td>
</tr>
<tr>
<td>await wait()</td>
<td>完成情况的监控器</td>
</tr>
<tr>
<td>current_task()</td>
<td>返回当前 Task 对象</td>
</tr>
<tr>
<td>all_tasks()</td>
<td>返回事件循环中所有的 task 对象。</td>
</tr>
<tr>
<td>Task</td>
<td>Task 对象</td>
</tr>
<tr>
<td>to_thread()</td>
<td>在不同的 OS 线程中异步地运行一个函数。</td>
</tr>
<tr>
<td>run_coroutine_threadsafe()</td>
<td>从其他 OS 线程中调度一个协程。</td>
</tr>
<tr>
<td>for in as_completed()</td>
<td>用  for  循环监控完成情况。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-gather" target="_blank" rel="noopener noreferrer">使用 asyncio.gather() 并行运行</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-waitfor" target="_blank" rel="noopener noreferrer">使用 asyncio.wait_for() 强制超时</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">撤销协程</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-sleep" target="_blank" rel="noopener noreferrer">asyncio.sleep() 的用法</a>.</li>
<li>请主要参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程与任务文档</a>.</li>
</ul>
<h3 id="队列集" tabindex="-1"> <strong>队列集</strong></h3>
<p>队列集被用于多个异步 Task 对象的运行调度，实现连接池以及发布/订阅模式。</p>
<table>
<thead>
<tr>
<th>Queue</th>
<th>先进先出队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>PriorityQueue</td>
<td>优先级队列。</td>
</tr>
<tr>
<td>LifoQueue</td>
<td>后进先出队列。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-example-queue-dist" target="_blank" rel="noopener noreferrer">使用 asyncio.Queue 在多个并发任务间分配工作量</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列集文档</a>.</li>
</ul>
<h3 id="子进程集" tabindex="-1"> 子进程集</h3>
<p>用于生成子进程和运行 shell 命令的工具包。</p>
<table>
<thead>
<tr>
<th>await create_subprocess_exec()</th>
<th>创建一个子进程。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await create_subprocess_shell()</td>
<td>运行一个 shell 命令。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-example-subprocess-shell" target="_blank" rel="noopener noreferrer">执行一个 shell 命令</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程 APIs</a>  相关文档.</li>
</ul>
<h3 id="流" tabindex="-1"> 流</h3>
<p>用于网络 IO 处理的高级 API 集。</p>
<table>
<thead>
<tr>
<th>await open_connection()</th>
<th>建立一个 TCP 连接。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await open_unix_connection()</td>
<td>建立一个 Unix socket 连接。</td>
</tr>
<tr>
<td>await start_server()</td>
<td>启动 TCP 服务。</td>
</tr>
<tr>
<td>await start_unix_server()</td>
<td>启动一个 Unix 套接字服务。</td>
</tr>
<tr>
<td>StreamReader</td>
<td>接收网络数据的高级 async/await 对象。</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>发送网络数据的高级 async/await 对象。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-example-stream" target="_blank" rel="noopener noreferrer">TCP 客户端样例</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">streams APIs</a>  文档。</li>
</ul>
<h3 id="同步" tabindex="-1"> <strong>同步</strong></h3>
<p>能被用于 Task 对象集的，类似线程的同步基元组件。</p>
<table>
<thead>
<tr>
<th>Lock</th>
<th>互斥锁。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event</td>
<td>事件对象。</td>
</tr>
<tr>
<td>Condition</td>
<td>条件对象</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量</td>
</tr>
<tr>
<td>BoundedSemaphore</td>
<td>有界的信号量。</td>
</tr>
</tbody>
</table>
<h3 id="异常" tabindex="-1"> <strong>异常</strong></h3>
<table>
<thead>
<tr>
<th>asyncio.TimeoutError</th>
<th>类似  wait_for()  等函数在超时时候被引发。请注意  asyncio.TimeoutError  与内建异常  TimeoutError  无关。</th>
</tr>
</thead>
<tbody>
<tr>
<td>asyncio.CancelledError</td>
<td>当一个 Task 对象被取消的时候被引发。请参阅  Task.cancel()。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">在取消请求发生的运行代码中如何处理 CancelledError 异常</a>.</li>
<li>请参阅完整的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio-exceptions" target="_blank" rel="noopener noreferrer">asyncio 专用异常</a>  列表.</li>
</ul>
<h2 id="关于-never-awaited-协程" tabindex="-1"> 关于 never-awaited 协程</h2>
<p>当协程函数被调用而不是被等待时 (即执行  <code>coro()</code>  而不是  <code>await coro()</code>) 或者协程没有通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  被排入计划日程，asyncio 将会发出一条  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeWarning" target="_blank" rel="noopener noreferrer">RuntimeWarning</a>:</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"never scheduled"</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    test<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># test.py:7: RuntimeWarning: coroutine 'test' was never awaited</span>
<span>#  test()</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通常的修复方法是 <code>await</code> 协程或者调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数:</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> test<span>(</span><span>)</span>  <span># 开始运行并等待完成</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>test<span>(</span><span>)</span><span>)</span>  <span># 开始运行</span>
        <span>await</span> task  <span># 等待完成</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html" target="_blank" rel="noopener noreferrer">协程与任务</a> </p>
</li>
<li id="footnote2"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html" target="_blank" rel="noopener noreferrer">Stream 流</a> </p>
</li>
<li id="footnote3"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html" target="_blank" rel="noopener noreferrer">同步原语</a> </p>
</li>
<li id="footnote4"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html" target="_blank" rel="noopener noreferrer">队列集合</a> </p>
</li>
<li id="footnote5"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html" target="_blank" rel="noopener noreferrer">事件循环</a> </p>
</li>
<li id="footnote6"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-api-index.html" target="_blank" rel="noopener noreferrer">高层级 API 索引</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Python二分查找 - bisect</title>
      <link>https://timpcfan.site/code/language/python/python-bisect.html</link>
      <guid>https://timpcfan.site/code/language/python/python-bisect.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python二分查找 - bisect</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="二分查找模块-bisect" tabindex="-1"> 二分查找模块 bisect</h2>
<p><code>bisect_left(a, x, lo=0, hi=len(a))</code></p>
<p>相当于 left_bound，返回目标值的左侧边界，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最左侧索引</li>
<li>解读 2：a 中小于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于等于 x 的最小元素索引</li>
</ul>
<hr>
<p><code>bisect_right(a, x, lo=0, hi=len(a))</code></p>
<p><code>bisect(a, x, lo=0, hi=len(a))</code></p>
<p>⚠️ 不相当于 right_bound，返回目标值的右侧边界+1，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最右侧索引</li>
<li>解读 2：a 中小于等于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于 x 的最小元素索引（返回的索引位置的值肯定不等于 x！！！</li>
</ul>
<hr>
<p><code>insort_left(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_left(a, x, lo, hi), x)</p>
<hr>
<p><code>insort_right(a, x, lo=0, hi=len(a))</code>
<code>insort(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_right(a, x, lo, hi), x)</p>
<hr>
<div><pre><code><span>#idx 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>
a <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>]</span>

<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>3</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>3</span><span>)</span>  <span># bisect(a, 3)</span>
<span>8</span>
<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python3-10-之后的版本新增参数-key" tabindex="-1"> python3.10 之后的版本新增参数 key</h2>
<p>类似 sort 的 key 参数，可以指定搜索时使用的具体的键</p>
<p>例子：</p>
<div><pre><code><span># leetcode #875</span>
<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>minEatingSpeed</span><span>(</span>self<span>,</span> piles<span>:</span> List<span>[</span><span>int</span><span>]</span><span>,</span> h<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>def</span> <span>canEatAll</span><span>(</span>k<span>)</span><span>:</span>
            <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                <span>return</span> <span>False</span>
            cost_time <span>=</span> <span>0</span>
            <span>for</span> pile <span>in</span> piles<span>:</span>
                cost_time <span>+=</span> math<span>.</span>ceil<span>(</span>pile <span>/</span> k<span>)</span>
            <span>return</span> cost_time <span>&lt;=</span> h
        <span>return</span> bisect_left<span>(</span><span>range</span><span>(</span><span>max</span><span>(</span>piles<span>)</span> <span>+</span> <span>1</span><span>)</span><span>,</span> <span>True</span><span>,</span> key<span>=</span>canEatAll<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>若使用这种方法解题，a 要包括所有的答案域，且如果使用 range，尽量使用 range(max_ans+1)的形式，若使用 range(min_ans, max_ans+1)，需要给返回的结果添加偏置 min_ans！</p>
</div>
<h2 id="在有序列表中搜索" tabindex="-1"> 在有序列表中搜索</h2>
<p>如何将 bisect 转换为一般的搜索方法：</p>
<div><pre><code><span>def</span> <span>index</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Locate the leftmost value exactly equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span> <span>and</span> a<span>[</span>i<span>]</span> <span>==</span> x<span>:</span>
        <span>return</span> i
    <span>raise</span> ValueError

<span>def</span> <span>find_lt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_le</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than or equal to x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_gt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost value greater than x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_ge</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost item greater than or equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python并发编程</title>
      <link>https://timpcfan.site/code/language/python/python-concurrent.html</link>
      <guid>https://timpcfan.site/code/language/python/python-concurrent.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python并发编程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="多进程程序例子" tabindex="-1"> 多进程程序例子</h2>
<div><pre><code><span>import</span> argparse
<span>import</span> redis
<span>from</span> tqdm <span>import</span> tqdm
<span>from</span> multiprocessing <span>import</span> Pool<span>,</span> Process

parser <span>=</span> argparse<span>.</span>ArgumentParser<span>(</span>description<span>=</span><span>'PyTorch MM Training'</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--port'</span><span>,</span> default<span>=</span><span>6379</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"port id"</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--file'</span><span>,</span> default<span>=</span><span>None</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"paths for train instances"</span><span>)</span>
args <span>=</span> parser<span>.</span>parse_args<span>(</span><span>)</span>

host <span>=</span> <span>'127.0.0.1'</span>
port <span>=</span> args<span>.</span>port

<span># r = redis.Redis(host=host, port=port)</span>

train_file <span>=</span> args<span>.</span><span>file</span>

<span>def</span> <span>worker_i</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>=</span><span>16</span><span>)</span><span>:</span>
    r <span>=</span> redis<span>.</span>Redis<span>(</span>host<span>=</span>host<span>,</span> port<span>=</span>port<span>)</span>
    k <span>=</span> <span>0</span>

    <span>if</span> i <span>==</span> <span>0</span><span>:</span>
        iter_ <span>=</span> tqdm<span>(</span><span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span><span>)</span>
    <span>else</span><span>:</span>
        iter_ <span>=</span> <span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span>

    <span>for</span> info <span>in</span> iter_<span>:</span>
        <span>if</span> k <span>%</span> nums <span>==</span> i<span>:</span> <span># 将多个任务分成nums份</span>
            r<span>.</span><span>set</span><span>(</span>k<span>,</span> info<span>.</span>strip<span>(</span><span>)</span><span>)</span>
        k <span>+=</span> <span>1</span>
process_list <span>=</span> <span>[</span><span>]</span>

nums <span>=</span> <span>8</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span>nums<span>)</span><span>:</span>
    p <span>=</span> Process<span>(</span>target<span>=</span>worker_i<span>,</span> args<span>=</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>)</span><span>)</span>
    p<span>.</span>start<span>(</span><span>)</span>
    process_list<span>.</span>append<span>(</span>p<span>)</span>

<span>for</span> i <span>in</span> process_list<span>:</span>
    p<span>.</span>join<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'写入完成'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python-中的三种并发编程方式" tabindex="-1"> Python 中的三种并发编程方式</h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" alt="tch30Z" loading="lazy"></p>
<h3 id="三种方式-多线程-thread-、多进程-process-、协程-coroutine" tabindex="-1"> 三种方式：多线程（Thread）、多进程（Process）、协程（Coroutine）</h3>
<h3 id="什么是-cpu-密集型计算、io-密集型计算" tabindex="-1"> 什么是 CPU 密集型计算、IO 密集型计算</h3>
<ul>
<li>CPU 密集型计算（CPU-bound）：
<ul>
<li>例如：压缩解压缩、加密解密</li>
</ul>
</li>
<li>IO 密集型计算（I/O bound）：
<ul>
<li>爬虫、文件处理等</li>
</ul>
</li>
</ul>
<h3 id="多线程、多进程、协程的对比" tabindex="-1"> 多线程、多进程、协程的对比</h3>
<ul>
<li>多进程 Process（multiprocessing）
<ul>
<li>优点：可以利用多核 CPU 并行运算</li>
<li>缺点：占用资源最多、可启动数目比线程少</li>
<li>适用于：CPU 密集型计算</li>
</ul>
</li>
<li>多线程 Thread（threading）
<ul>
<li>优点：相比进程，更轻量级、占用资源少</li>
<li>缺点：
<ul>
<li>相比进程：多线程只能并发执行，不能利用多 CPU（GIL）</li>
<li>相比协程：启动数目有限制，占用内存资源，有线程切换开销</li>
</ul>
</li>
<li>适用于：IO 密集型计算、同时允许的任务数目要求不多</li>
</ul>
</li>
<li>协程 Coroutine（asyncio）
<ul>
<li>优点：内存开销最少、启动协程数量最多</li>
<li>缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂</li>
<li>适用于：IO 密集型计算、需要超多任务运行、但有现成库支持的场景</li>
</ul>
</li>
</ul>
<h3 id="怎样根据任务选择对应技术" tabindex="-1"> 怎样根据任务选择对应技术</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UsvTjR.png" alt="UsvTjR" loading="lazy"></p>
<h2 id="全局解释器锁-gil-global-interpreter-lock" tabindex="-1"> 全局解释器锁 GIL（Global Interpreter Lock）</h2>
<p>Python 速度慢的两大原因：</p>
<ul>
<li>动态类型语言，边解释边执行</li>
<li>GIL，无法利用多核 CPU 并发执行</li>
</ul>
<p>全局解释器锁：</p>
<ul>
<li>是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。</li>
<li>即便在多核处理器上，使用 GIL 的解释器也<strong>只能允许同一时间执行一个线</strong>程。相比并发加速的 C++/JAVA 会慢很多。</li>
<li>原因详解
<ul>
<li>为了解决多线程之间数据完整性和状态同步问题。</li>
<li>Python 中对象的管理，维护了每个对象的引用计数，在多线程时，为了保证引用计数的一致性，使用了锁的机制。</li>
</ul>
</li>
</ul>
<p>怎样规避 GIL 带来的限制：</p>
<ul>
<li>那 Python 中的线程无法同时运行，为什么还要使用多线程机制呢？多线程机制在 Python 中依然是有用的，由于<strong>IO 密集型计算</strong>，因为 IO 期间，线程会释放 GIL，实现 CPU 和 IO 的并行，因此多线程用于 IO 密集型计算依然可以大幅提升速度。</li>
<li>使用 multiprocessing 的多进程机制实现并行计算、利用多核 CPU 优势。</li>
</ul>
<h2 id="python-多线程代码" tabindex="-1"> Python 多线程代码</h2>
<h3 id="直接创建线程" tabindex="-1"> 直接创建线程</h3>
<div><pre><code><span>import</span> threading

<span>def</span> <span>craw</span><span>(</span>url<span>)</span><span>:</span>  <span># 1. 准备一个函数</span>
	r <span>=</span> requests<span>.</span>get<span>(</span>url<span>)</span>
	<span>print</span><span>(</span><span>len</span><span>(</span>r<span>.</span>text<span>)</span><span>)</span>

<span>def</span> <span>multi_thread</span><span>(</span><span>)</span><span>:</span>
	threads <span>=</span> <span>[</span><span>]</span>  <span># 2. 准备一个线程list</span>
	<span>for</span> url <span>in</span> urls<span>:</span>
		threads<span>.</span>append<span>(</span>  <span># 3. 创建线程</span>
			threading<span>.</span>Thread<span>(</span>target<span>=</span>craw<span>,</span> args<span>=</span><span>(</span>url<span>,</span><span>)</span><span>)</span>
		<span>)</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>start<span>(</span><span>)</span>  <span># 4. 启动线程</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>join<span>(</span><span>)</span>  <span># 5. 等待结束</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="使用线程池threadpoolexecutor" tabindex="-1"> 使用线程池<strong>ThreadPoolExecutor</strong></h3>
<p>用法 1：使用 map 函数（所有任务一起提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		result <span>=</span> pool<span>.</span><span>map</span><span>(</span>craw<span>,</span> urls<span>)</span>
		<span># map的结果和入参的顺序对应的</span>
		<span>for</span> result <span>in</span> results<span>:</span>
				<span>print</span><span>(</span>result<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用法 2：future 模式，更强大（一个任务一个任务提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor<span>,</span> as_completed
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		<span># 使用 dict 可以知道future对应的入参</span>
		futures <span>=</span> <span>{</span>pool<span>.</span>submit<span>(</span>craw<span>,</span> url<span>)</span><span>:</span> url
								<span>for</span> url <span>in</span> urls<span>}</span>
		<span># 方式1: 结果仍然按顺序</span>
		<span>for</span> future<span>,</span> url <span>in</span> futures<span>.</span>items<span>(</span><span>)</span><span>:</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>

		<span># 方式2: 使用 as_completed 顺序是不定的</span>
		<span>for</span> future <span>in</span> as_completed<span>(</span>futures<span>)</span><span>:</span>  <span># 注：字典的遍历是遍历key</span>
				url <span>=</span> futures<span>[</span>future<span>]</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p></p>
<h2 id="python-多进程代码" tabindex="-1"> Python 多进程代码</h2>
<p>多线程 threading 与多进程 multiprocessing 的代码对比</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oMERIi.png" alt="oMERIi" loading="lazy"></p>
<p>直接改个类名就能运行！</p>
<p>所以代码去看 </p>
<h3 id="多进程优雅退出" tabindex="-1"> 多进程优雅退出</h3>
<div><pre><code><span>import</span> ctypes
<span>import</span> time
<span>from</span> multiprocessing <span>import</span> Process<span>,</span> RawValue

<span>class</span> <span>CountdownTask</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running <span>=</span> RawValue<span>(</span>ctypes<span>.</span>c_bool<span>,</span> <span>True</span><span>)</span>
    <span>def</span> <span>terminate</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running<span>.</span>value <span>=</span> <span>False</span>
    <span>def</span> <span>run</span><span>(</span>self<span>,</span> n<span>)</span><span>:</span>
        <span>while</span> self<span>.</span>_running<span>.</span>value <span>and</span> n <span>></span> <span>0</span><span>:</span>
            <span>print</span><span>(</span><span>'T-minus'</span><span>,</span> n<span>)</span>
            n <span>-=</span> <span>1</span>
            time<span>.</span>sleep<span>(</span><span>5</span><span>)</span>

c <span>=</span> CountdownTask<span>(</span><span>)</span>
t <span>=</span> Process<span>(</span>target<span>=</span>c<span>.</span>run<span>,</span> args<span>=</span><span>(</span><span>10</span><span>,</span><span>)</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>
c<span>.</span>terminate<span>(</span><span>)</span> <span># Signal termination</span>
t<span>.</span>join<span>(</span><span>)</span> <span># Wait for actual termination (if needed)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="线程池原理" tabindex="-1"> 线程池原理</h2>
<h3 id="线程池的原理" tabindex="-1"> 线程池的原理</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/YPT9vT.png" alt="YPT9vT" loading="lazy"></p>
<h3 id="特点" tabindex="-1"> 特点</h3>
<ul>
<li>使用任务队列</li>
<li>可重用线程</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>提升性能：减少创建终止线程开销，重用线程资源</li>
<li>适用场景：突发性大量请求、但任务处理时间较短</li>
<li>防御功能：避免系统因为创建线程过多导致负荷过大</li>
<li>代码优势：简洁方便</li>
</ul>
<h2 id="协程的原理以及代码" tabindex="-1"> 协程的原理以及代码</h2>
<p><a href="https://www.bilibili.com/video/BV1bK411A7tV?p=11" target="_blank" rel="noopener noreferrer">【2021 最新版】Python 并发编程实战，用多线程、多进程、多协程加速程序运行_哔哩哔哩_bilibili</a></p>
<h3 id="协程的原理" tabindex="-1"> 协程的原理</h3>
<p>协程：在<strong>单线程内</strong>实现并发</p>
<ul>
<li>核心原理：用一个超级循环（其实就是 while true）循环，配合 IO 多路复用原理（IO 时 CPU 可以干其他事情）</li>
<li>于是在等待 IO 时，CPU 会同时开始计算下一个循环的 IO 前的部分，并开启多轮循环同时进行的局面</li>
<li>等待 IO 结束，CPU 将剩余部分的代码再一并执行</li>
</ul>
<p><strong>单线程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dFUEmJ.png" alt="dFUEmJ" loading="lazy"></p>
<p><strong>协程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OSigeS.png" alt="OSigeS" loading="lazy"></p>
<h3 id="协程的使用以及异步-io" tabindex="-1"> 协程的使用以及异步 IO</h3>
<div><pre><code><span>import</span> asyncio

<span># 获取事件循环（超级循环）</span>
loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>

<span># 定义协程</span>
<span>async</span> <span>def</span> <span>myfunc</span><span>(</span>url<span>)</span><span>:</span>
		<span>await</span> get_url<span>(</span>url<span>)</span>

<span># 创建task列表</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>myfunc<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>

<span># 执行爬虫事件列表</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>关键字<strong>async</strong>：表示定义一个协程。</p>
<p>关键字<strong>await</strong>：表示后面的函数是一个异步 IO，并且不进行阻塞，而是直接在超级循环直接进入下一个任务的执行（当前任务放弃 CPU，下一个任务获得 CPU）。</p>
<div><p>注意</p>
<p>异步 IO 中依赖的库必须支持异步 IO 特性（这要求库在 IO 时不能阻塞，否则切换不到下一个任务了）</p>
</div>
<div><p>注意</p>
<p>requests 库不支持异步 IO，需要使用 aiohttp 库</p>
</div>
<p>例子：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
				<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
						result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
						<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所有的异步对象也需要使用 async 关键字来标注。</p>
<div><p>相关信息</p>
<p>协程与普通函数运行的不同点在于协程需要使用超级循环来进行调度。</p>
</div>
<h3 id="协程并发度的控制" tabindex="-1"> 协程并发度的控制</h3>
<p>可以使用  来进行控制：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

semaphore <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>
<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> semaphore<span>:</span>  <span># here</span>
				<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
						<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
								result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
								<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="信号量-semaphore" tabindex="-1"> 信号量 Semaphore</h2>
<div><p>相关信息</p>
<p>信号量一般用于访问有限数量的共享资源。</p>
</div>
<p>信号量是一个<strong>同步对象</strong>，用于保持在 0 至指定最大值之间的一个计数器。</p>
<ul>
<li>当线程完成一次对改 semaphore 对象的等待（wait）时，该计数器减一</li>
<li>当线程完成一次对改 semaphore 对象的释放（release）时，该计数器加一</li>
<li>当计数器为 0 时，线程等待该 semaphore 对象不再能成功直到该 semaphore 对象变成 signaled 状态（阻塞）
<ul>
<li>计数器大于 0，为 signaled 状态</li>
<li>计数器等于 0，为 nonsignaled 状态</li>
</ul>
</li>
</ul>
<div><pre><code><span># 方法一：使用with</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>async</span> <span>with</span> sem<span>:</span>
		<span># work with shared resource</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># 方法二：手动acquire、release</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>await</span> sem<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
		<span># work with shared resource</span>
<span>finally</span><span>:</span>
		sem<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" type="image/png"/>
    </item>
    <item>
      <title>Python常用数据结构</title>
      <link>https://timpcfan.site/code/language/python/python-data-structures.html</link>
      <guid>https://timpcfan.site/code/language/python/python-data-structures.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python常用数据结构</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="列表-list" tabindex="-1"> 列表 list</h2>
<h3 id="列表方法" tabindex="-1"> 列表方法</h3>
<ul>
<li>list.append(obj)</li>
<li>list.count(obj)</li>
<li>list.extend(seq)</li>
<li>list.index(obj)</li>
<li>list.insert(index, obj)</li>
<li>list.pop([index=-1])</li>
<li>list.remove(obj)</li>
<li>list.reverse()</li>
<li>list.sort(cmp=None, key=None, reverse=False)</li>
</ul>
<h3 id="列表脚本操作符" tabindex="-1"> 列表脚本操作符</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>['Hi!'] * 4</td>
<td>['Hi!', 'Hi!', 'Hi!', 'Hi!']</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<h3 id="列表截取" tabindex="-1"> 列表截取</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>'Taobao'</td>
<td>读取列表中第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>'Runoob'</td>
<td>读取列表中倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td>['Runoob', 'Taobao']</td>
<td>从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<h2 id="双向队列-deque" tabindex="-1"> 双向队列 deque</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>deque<span>(</span><span>[</span>iterable<span>[</span><span>,</span> maxlen<span>]</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>注意</p>
<p>若当作一个<strong>单向队列</strong>，append(x) 与 popleft() 才是一对。。。</p>
<ul>
<li>若当作一个<strong>栈</strong>，append(x)与 pop()就是一对</li>
</ul>
</div>
<h3 id="方法" tabindex="-1"> 方法</h3>
<ul>
<li>append(x) 添加到右侧</li>
<li>appendleft(x) 添加到左侧</li>
<li>pop() 从右侧出队</li>
<li>popleft() 从左侧出队</li>
<li>clear()</li>
<li>copy()</li>
<li>count(x)</li>
<li>extend(iter)</li>
<li>extendleft(iter)</li>
<li>index(x[, start[, stop]])</li>
<li>insert(i, x)</li>
<li>remove(x) 删除从左到右的第一个 x</li>
<li>reverse()</li>
<li>rotate(n=1)</li>
<li>maxlen</li>
</ul>
<h3 id="recipes" tabindex="-1"> Recipes</h3>
<h4 id="_1-用于实现-tail-程序" tabindex="-1"> 1. 用于实现 tail 程序</h4>
<div><pre><code><span>def</span> <span>tail</span><span>(</span>filename<span>,</span> n<span>=</span><span>10</span><span>)</span><span>:</span>
    <span>'Return the last n lines of a file'</span>
    <span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> f<span>:</span>
        <span>return</span> deque<span>(</span>f<span>,</span> n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>设置 maxlen=n，可以实现保留文本最后 n 行的功能。</p>
<h4 id="_2-用于维持一个定长的近期添加元素序列" tabindex="-1"> 2. 用于维持一个定长的近期添加元素序列</h4>
<div><pre><code><span>def</span> <span>moving_average</span><span>(</span>iterable<span>,</span> n<span>=</span><span>3</span><span>)</span><span>:</span>
    <span># moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0</span>
    <span># http://en.wikipedia.org/wiki/Moving_average</span>
    it <span>=</span> <span>iter</span><span>(</span>iterable<span>)</span>
    d <span>=</span> deque<span>(</span>itertools<span>.</span>islice<span>(</span>it<span>,</span> n<span>-</span><span>1</span><span>)</span><span>)</span>
    d<span>.</span>appendleft<span>(</span><span>0</span><span>)</span>
    s <span>=</span> <span>sum</span><span>(</span>d<span>)</span>
    <span>for</span> elem <span>in</span> it<span>:</span>
        s <span>+=</span> elem <span>-</span> d<span>.</span>popleft<span>(</span><span>)</span>
        d<span>.</span>append<span>(</span>elem<span>)</span>
        <span>yield</span> s <span>/</span> n
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_3-实现一个-round-robin-scheduler" tabindex="-1"> 3. 实现一个 round-robin scheduler</h4>
<div><pre><code><span>def</span> <span>roundrobin</span><span>(</span><span>*</span>iterables<span>)</span><span>:</span>
    <span>"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
    iterators <span>=</span> deque<span>(</span><span>map</span><span>(</span><span>iter</span><span>,</span> iterables<span>)</span><span>)</span>
    <span>while</span> iterators<span>:</span>
        <span>try</span><span>:</span>
            <span>while</span> <span>True</span><span>:</span>
                <span>yield</span> <span>next</span><span>(</span>iterators<span>[</span><span>0</span><span>]</span><span>)</span>
                iterators<span>.</span>rotate<span>(</span><span>-</span><span>1</span><span>)</span>
        <span>except</span> StopIteration<span>:</span>
            <span># Remove an exhausted iterator.</span>
            iterators<span>.</span>popleft<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_4-删除第-n-个元素" tabindex="-1"> 4. 删除第 n 个元素</h4>
<p>可以使用 rotate(n)来轻松删除第 n 个元素</p>
<div><pre><code><span>def</span> <span>delete_nth</span><span>(</span>d<span>,</span> n<span>)</span><span>:</span>
    d<span>.</span>rotate<span>(</span><span>-</span>n<span>)</span>
    d<span>.</span>popleft<span>(</span><span>)</span>
    d<span>.</span>rotate<span>(</span>n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="最小堆-heapq" tabindex="-1"> 最小堆 heapq</h2>
<p><strong>函 数</strong>                                                        <strong>描 述</strong></p>
<p>heappush(heap, x)                                将 x 压入堆中</p>
<p>heappop(heap)                                      从堆中弹出最小的元素</p>
<p>heapify(heap)                                         让列表具备堆特征</p>
<p>heapreplace(heap, x)                            弹出最小的元素，并将 x 压入堆中</p>
<p>nlargest(n, iter, key=None)                                      返回 iter 中 n 个最大的元素</p>
<p>nsmallest(n, iter, key=None)                                   返回 iter 中 n 个最小的元素</p>
<p>merge(*iters, key=None, reverse=False) 合并多个有序列表形成单独一个有序列表</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> heapq <span>import</span> <span>*</span>
<span>>></span><span>></span> <span>from</span> random <span>import</span> shuffle
<span>>></span><span>></span> data <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
<span>>></span><span>></span> shuffle<span>(</span>data<span>)</span>
<span>>></span><span>></span> heap <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> <span>for</span> n <span>in</span> data<span>:</span>
<span>.</span><span>.</span><span>.</span> heappush<span>(</span>heap<span>,</span> n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>]</span>
<span>>></span><span>></span> heappush<span>(</span>heap<span>,</span> <span>0.5</span><span>)</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>0.5</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="python-如何实现最大堆" tabindex="-1"> <strong>python 如何实现最大堆？</strong></h3>
<div><pre><code><span># 最简单的方案就是，给你的堆的元素加一个值，使值逆序排列。以下是示例代码。</span>
<span>import</span> heapq
sss <span>=</span> <span>'abecgfidhjk'</span>
ll <span>=</span> <span>list</span><span>(</span>sss<span>)</span>
heapq<span>.</span>heapify<span>(</span>ll<span>)</span>
<span>print</span><span>(</span>ll<span>)</span>
<span># ['a', 'b', 'e', 'c', 'g', 'f', 'i', 'd', 'h', 'j', 'k']</span>
<span># 此时若想得到大顶堆</span>
newl <span>=</span> <span>[</span><span>(</span><span>-</span>i<span>,</span> ll<span>[</span>i<span>]</span><span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>ll<span>)</span><span>)</span><span>]</span>
<span>#print(newl)</span>
heapq<span>.</span>heapify<span>(</span>newl<span>)</span>
<span># 此时已经按照第一个值变成了小顶堆，即变成了逆序</span>
max_heap <span>=</span> <span>list</span><span>(</span><span>)</span>
<span>while</span> newl<span>:</span>
    _<span>,</span> s <span>=</span> heapq<span>.</span>heappop<span>(</span>newl<span>)</span>
    max_heap<span>.</span>append<span>(</span>s<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="计数器-counter" tabindex="-1"> 计数器 Counter</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>Counter<span>(</span><span>[</span>iterable<span>-</span><span>or</span><span>-</span>mapping<span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Counter 是一个 dict 的子类，存着每个元素出现的次数，若访问不存在的元素会返回 0。</p>
<div><pre><code>c <span>=</span> Counter<span>(</span><span>)</span>                           <span># a new, empty counter</span>
c <span>=</span> Counter<span>(</span><span>'gallahad'</span><span>)</span>                 <span># a new counter from an iterable</span>
c <span>=</span> Counter<span>(</span><span>{</span><span>'red'</span><span>:</span> <span>4</span><span>,</span> <span>'blue'</span><span>:</span> <span>2</span><span>}</span><span>)</span>      <span># a new counter from a mapping</span>
c <span>=</span> Counter<span>(</span>cats<span>=</span><span>4</span><span>,</span> dogs<span>=</span><span>8</span><span>)</span>             <span># a new counter from keyword args</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>直接以字典的方式去访问 Counter</p>
<div><pre><code>c<span>[</span><span>'cats'</span><span>]</span>         <span># return 4</span>
c<span>[</span><span>'cats'</span><span>]</span> <span>+=</span> <span>1</span>    <span># add one more cat</span>
c<span>[</span><span>'pigs'</span><span>]</span>         <span># missing value will return 0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>elements()</strong> 返回一个 iterator 根据每个元素的数量来访问所有元素（会忽略数量为 0 或负的元素）</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>c<span>.</span>elements<span>(</span><span>)</span><span>)</span>
<span>[</span><span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'b'</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>*<strong>*most_common**</strong>([<em>n</em>]) 返回一个 tuple 列表，包含按元素数量排序的最常见的元素列表</p>
<div><pre><code><span>>></span><span>></span> Counter<span>(</span><span>'abracadabra'</span><span>)</span><span>.</span>most_common<span>(</span><span>3</span><span>)</span>
<span>[</span><span>(</span><span>'a'</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>(</span><span>'b'</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>(</span><span>'r'</span><span>,</span> <span>2</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>*<strong>*subtract**</strong>([<em>iterable-or-mapping</em>]) 两个 Counter 可以相减</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>3</span><span>,</span> d<span>=</span><span>4</span><span>)</span>
<span>>></span><span>></span> c<span>.</span>subtract<span>(</span>d<span>)</span>
<span>>></span><span>></span> c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>0</span><span>,</span> <span>'c'</span><span>:</span> <span>-</span><span>3</span><span>,</span> <span>'d'</span><span>:</span> <span>-</span><span>6</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>*<strong>*fromkeys**</strong>(<em>iterable</em>) 没有对 Counter 实现该方法（dict 的类方法，用于根据 dict 的键生成一个新的 dict）</p>
<p>*<strong>*update**</strong>([<em>iterable-or-mapping</em>]) 与 dict 的 update 一样</p>
<p>其他的一些操作：</p>
<div><pre><code><span>sum</span><span>(</span>c<span>.</span>values<span>(</span><span>)</span><span>)</span>                 <span># total of all counts</span>
c<span>.</span>clear<span>(</span><span>)</span>                       <span># reset all counts</span>
<span>list</span><span>(</span>c<span>)</span>                         <span># list unique elements</span>
<span>set</span><span>(</span>c<span>)</span>                          <span># convert to a set</span>
<span>dict</span><span>(</span>c<span>)</span>                         <span># convert to a regular dictionary</span>
c<span>.</span>items<span>(</span><span>)</span>                       <span># convert to a list of (elem, cnt) pairs</span>
Counter<span>(</span><span>dict</span><span>(</span>list_of_pairs<span>)</span><span>)</span>    <span># convert from a list of (elem, cnt) pairs</span>
c<span>.</span>most_common<span>(</span><span>)</span><span>[</span><span>:</span><span>-</span>n<span>-</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]</span>       <span># n least common elements</span>
<span>+</span>c                              <span># remove zero and negative counts</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>3</span><span>,</span> b<span>=</span><span>1</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>)</span>
<span>>></span><span>></span> c <span>+</span> d                       <span># add two counters together:  c[x] + d[x]</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>4</span><span>,</span> <span>'b'</span><span>:</span> <span>3</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>-</span> d                       <span># subtract (keeping only positive counts)</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>&amp;</span> d                       <span># intersection:  min(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>1</span><span>,</span> <span>'b'</span><span>:</span> <span>1</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>|</span> d                       <span># union:  max(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>2</span><span>}</span><span>)</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>2</span><span>,</span> b<span>=</span><span>-</span><span>4</span><span>)</span>
<span>>></span><span>></span> <span>+</span>c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> <span>-</span>c
Counter<span>(</span><span>{</span><span>'b'</span><span>:</span> <span>4</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="随机队列-randomizedqueue" tabindex="-1"> 随机队列 RandomizedQueue</h2>
<div><p>相关信息</p>
<p>自创数据结构，在工作中使用</p>
</div>
<div><pre><code><span>class</span> <span>RandomizedQueue</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> _iter<span>=</span><span>[</span><span>]</span><span>)</span><span>:</span>
        self<span>.</span>arr <span>=</span> <span>[</span><span>*</span>_iter<span>]</span>
    <span>def</span> <span>append</span><span>(</span>self<span>,</span> val<span>)</span><span>:</span>
        self<span>.</span>arr<span>.</span>append<span>(</span>val<span>)</span>
    <span>def</span> <span>remove</span><span>(</span>self<span>,</span> idx<span>)</span><span>:</span>
        <span>if</span> idx <span>>=</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>:</span>
            <span>return</span>
        r <span>=</span> self<span>.</span>arr<span>[</span>idx<span>]</span>
        self<span>.</span>arr<span>[</span>idx<span>]</span> <span>=</span> self<span>.</span>arr<span>[</span><span>-</span><span>1</span><span>]</span>  <span># 将最后一个元素移动到删除的元素位置</span>
        self<span>.</span>arr<span>.</span>pop<span>(</span><span>)</span>
        <span>return</span> r
    <span>def</span> <span>getRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        <span>return</span> self<span>.</span>arr<span>[</span><span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span><span>]</span>
    <span>def</span> <span>popRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        idx <span>=</span> <span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span>
        <span>return</span> self<span>.</span>remove<span>(</span>idx<span>)</span>
    <span>def</span> <span>__len__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>入队：O(1)</li>
<li>获取随机元素：O(1)</li>
<li>随机出队：O(1)</li>
<li>删除指定位置的元素：O(1)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Python日志 - logging</title>
      <link>https://timpcfan.site/code/language/python/python-log.html</link>
      <guid>https://timpcfan.site/code/language/python/python-log.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python日志 - logging</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<div><pre><code><span>import</span> logging  <span># 引入logging模块</span>
<span>import</span> os<span>.</span>path
<span>import</span> time
<span># 第一步，创建一个logger</span>
logger <span>=</span> logging<span>.</span>getLogger<span>(</span><span>)</span>
logger<span>.</span>setLevel<span>(</span>logging<span>.</span>INFO<span>)</span>  <span># Log等级总开关</span>
<span># 第二步，创建一个handler，用于写入日志文件</span>
rq <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y%m%d%H%M'</span><span>,</span> time<span>.</span>localtime<span>(</span>time<span>.</span>time<span>(</span><span>)</span><span>)</span><span>)</span>
log_path <span>=</span> os<span>.</span>path<span>.</span>dirname<span>(</span>os<span>.</span>getcwd<span>(</span><span>)</span><span>)</span> <span>+</span> <span>'/Logs/'</span>
log_name <span>=</span> log_path <span>+</span> rq <span>+</span> <span>'.log'</span>
logfile <span>=</span> log_name
fh <span>=</span> logging<span>.</span>FileHandler<span>(</span>logfile<span>,</span> mode<span>=</span><span>'w'</span><span>)</span>
fh<span>.</span>setLevel<span>(</span>logging<span>.</span>DEBUG<span>)</span>  <span># 输出到file的log等级的开关</span>
<span># 第三步，定义handler的输出格式</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s"</span><span>)</span>
fh<span>.</span>setFormatter<span>(</span>formatter<span>)</span>
<span># 第四步，将logger添加到handler里面</span>
logger<span>.</span>addHandler<span>(</span>fh<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>记录日志：</p>
<div><pre><code><span># 日志</span>
logger<span>.</span>debug<span>(</span><span>'this is a logger debug message'</span><span>)</span>
logger<span>.</span>info<span>(</span><span>'this is a logger info message'</span><span>)</span>
logger<span>.</span>warning<span>(</span><span>'this is a logger warning message'</span><span>)</span>
logger<span>.</span>error<span>(</span><span>'this is a logger error message'</span><span>)</span>
logger<span>.</span>critical<span>(</span><span>'this is a logger critical message'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python字符数字之间的转换函数</title>
      <link>https://timpcfan.site/code/language/python/python-ordchr.html</link>
      <guid>https://timpcfan.site/code/language/python/python-ordchr.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python字符数字之间的转换函数</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x [,base ])</td>
<td>将 x 转换为一个整数</td>
</tr>
<tr>
<td>long(x [,base ])</td>
<td>将 x 转换为一个长整数</td>
</tr>
<tr>
<td>float(x )</td>
<td>将 x 转换到一个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象  x  转换为字符串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象  x  转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>用来计算在字符串中的有效 Python 表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列  s  转换为一个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列  s  转换为一个列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>unichr(x )</td>
<td>将一个整数转换为 Unicode 字符</td>
</tr>
<tr>
<td>bin(x)</td>
<td>将数字转换为二进制字符串</td>
</tr>
</tbody>
</table>
<div><pre><code><span>chr</span><span>(</span><span>65</span><span>)</span> <span>=</span> <span>'A'</span>
<span>ord</span><span>(</span><span>'A'</span><span>)</span> <span>=</span> <span>65</span>

<span>int</span><span>(</span><span>'2'</span><span>)</span> <span>=</span> <span>2</span>
<span>str</span><span>(</span><span>2</span><span>)</span> <span>=</span> <span>'2'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python排序 - sort</title>
      <link>https://timpcfan.site/code/language/python/python-sort.html</link>
      <guid>https://timpcfan.site/code/language/python/python-sort.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python排序 - sort</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<p>原文链接：<a href="https://docs.python.org/zh-cn/3.6/howto/sorting.html" target="_blank" rel="noopener noreferrer">Sorting HOW TO - Python 3.10.4 documentation</a></p>
<p>Python 列表内置的 list.sort()方法可以直接修改列表。另外 sorted()内置函数，可以传入迭代对象构建一个新的排序列表。</p>
<hr>
<p><strong><code>sorted</code></strong>(<em>iterable</em>, ***, <em>key=None</em>, *reverse=False*)</p>
<p>根据  <em>iterable</em>  中的项返回一个新的已排序列表。
具有两个可选参数，它们都必须指定为关键字参数。
<em>key</em>  指定带有单个参数的函数，用于从  <em>iterable</em>  的每个元素中提取用于比较的键 (例如  <code>key=str.lower</code>)。 默认值为  <code>None</code> (直接比较元素)。
<em>reverse</em>  为一个布尔值。 如果设为  <code>True</code>，则每个列表元素将按反向顺序比较进行排序。
使用  <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener noreferrer">functools.cmp_to_key()</a>  可将老式的  <em>cmp</em>  函数转换为  <em>key</em>  函数。
内置的  <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#sorted" target="_blank" rel="noopener noreferrer">sorted()</a>  确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<hr>
<h2 id="基本排序" tabindex="-1"> 基本排序</h2>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>]</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>

<span>>></span><span>></span> a <span>=</span> <span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>]</span>
<span>>></span><span>></span> a<span>.</span>sort<span>(</span><span>)</span>
<span>>></span><span>></span> a
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="key-函数" tabindex="-1"> key 函数</h2>
<p>可以使用一个函数来指定排序使用的键</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>"This is a test string from Andrew"</span><span>.</span>split<span>(</span><span>)</span><span>,</span> key<span>=</span><span>str</span><span>.</span>lower<span>)</span>
<span>[</span><span>'a'</span><span>,</span> <span>'Andrew'</span><span>,</span> <span>'from'</span><span>,</span> <span>'is'</span><span>,</span> <span>'string'</span><span>,</span> <span>'test'</span><span>,</span> <span>'This'</span><span>]</span>

<span>>></span><span>></span> student_tuples <span>=</span> <span>[</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span> <span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span><span>lambda</span> student<span>:</span> student<span>[</span><span>2</span><span>]</span><span>)</span>   <span># sort by age</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="operator-模块函数" tabindex="-1"> Operator 模块函数</h2>
<p>上面显示的键函数模式非常常见，因此 Python 提供了便利功能，使访问器功能更容易，更快捷。  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#module-operator" target="_blank" rel="noopener noreferrer">operator</a>  模块有  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.itemgetter" target="_blank" rel="noopener noreferrer">itemgetter()</a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.attrgetter" target="_blank" rel="noopener noreferrer">attrgetter()</a>  和  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.methodcaller" target="_blank" rel="noopener noreferrer">methodcaller()</a>  函数。</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> operator <span>import</span> itemgetter<span>,</span> attrgetter

<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>2</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'age'</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>

<span># 也支持多级排序！</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'grade'</span><span>,</span> <span>'age'</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="升序和降序" tabindex="-1"> <strong>升序和降序</strong></h2>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>2</span><span>)</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="排序稳定性和排序复杂度" tabindex="-1"> <strong>排序稳定性和排序复杂度</strong></h2>
<p>排序保证是  <strong><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener noreferrer">稳定</a></strong> 的。 这意味着当多个记录具有相同的键值时，将保留其原始顺序。</p>
<p>注意  <em>blue</em>  的两个记录如何保留它们的原始顺序，以便  <code>('blue', 1)</code>  保证在  <code>('blue', 2)</code>  之前。</p>
<p>这个美妙的属性允许你在一系列排序步骤中构建复杂的排序。例如，要按  <em>grade</em>  降序然后  <em>age</em>  升序对学生数据进行排序，请先  <em>age</em>  排序，然后再使用  <em>grade</em>  排序：</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'age'</span><span>)</span><span>)</span>     <span># sort on secondary key</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>s<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'grade'</span><span>)</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span>       <span># now sort on primary key, descending</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>Python 中使用的  <a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener noreferrer">Timsort</a>  算法可以有效地进行多种排序，因为它可以利用数据集中已存在的任何排序。</p>
<h2 id="使用装饰-排序-去装饰的旧方法" tabindex="-1"> <strong>使用装饰-排序-去装饰的旧方法</strong></h2>
<p>这个三个步骤被称为 Decorate-Sort-Undecorate ：</p>
<ul>
<li>首先，初始列表使用控制排序顺序的新值进行修饰。</li>
<li>然后，装饰列表已排序。</li>
<li>最后，删除装饰，创建一个仅包含新排序中初始值的列表。</li>
</ul>
<p>例如，要使用 DSU 方法按  <em>grade</em>  对学生数据进行排序：</p>
<div><pre><code><span>>></span><span>></span> decorated <span>=</span> <span>[</span><span>(</span>student<span>.</span>grade<span>,</span> i<span>,</span> student<span>)</span> <span>for</span> i<span>,</span> student <span>in</span> <span>enumerate</span><span>(</span>student_objects<span>)</span><span>]</span>
<span>>></span><span>></span> decorated<span>.</span>sort<span>(</span><span>)</span>
<span>>></span><span>></span> <span>[</span>student <span>for</span> grade<span>,</span> i<span>,</span> student <span>in</span> decorated<span>]</span>               <span># undecorate</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这方法语有效是因为元组按字典顺序进行比较，先比较第一项；如果它们相同则比较第二个项目，依此类推。</p>
<p>不一定在所有情况下都要在装饰列表中包含索引  <em>i</em> ，但包含它有两个好处：</p>
<ul>
<li>排序是稳定的——如果两个项具有相同的键，它们的顺序将保留在排序列表中。</li>
<li>原始项目不必具有可比性，因为装饰元组的排序最多由前两项决定。 因此，例如原始列表可能包含无法直接排序的复数。</li>
</ul>
<p>这个方法的另一个名字是 Randal L. Schwartz 在 Perl 程序员中推广的  <a href="https://en.wikipedia.org/wiki/Schwartzian_transform" target="_blank" rel="noopener noreferrer">Schwartzian transform</a>。</p>
<p>既然 Python 排序提供了键函数，那么通常不需要这种技术。</p>
<h2 id="使用-cmp-参数的旧方法" tabindex="-1"> 使用 cmp 参数的旧方法</h2>
<p>本 HOWTO 中给出的许多结构都假定为 Python 2.4 或更高版本。在此之前，没有内置  <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#sorted" target="_blank" rel="noopener noreferrer">sorted()</a> ， <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#list.sort" target="_blank" rel="noopener noreferrer">list.sort()</a>  也没有关键字参数。相反，所有 Py2.x 版本都支持  <em>cmp</em>  参数来处理用户指定的比较函数。</p>
<p>在 Py3.0 中， <em>cmp</em>  参数被完全删除（作为简化和统一语言努力的一部分，消除了丰富的比较与  <code>__cmp__()</code>  魔术方法之间的冲突）。</p>
<p>在 Py2.x 中， sort 允许一个可选函数，可以调用它来进行比较。该函数应该采用两个参数进行比较，然后返回负值为小于，如果它们相等则返回零，或者返回大于大于的正值。例如，我们可以这样做：</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>numeric_compare</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x <span>-</span> y
<span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>cmp</span><span>=</span>numeric_compare<span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>或者你可反转比较的顺序：</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>reverse_numeric</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> y <span>-</span> x
<span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>cmp</span><span>=</span>reverse_numeric<span>)</span>
<span>[</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>将代码从 Python 2.x 移植到 3.x 时，如果用户提供比较功能并且需要将其转换为键函数，则会出现这种情况。 以下包装器使这很容易：</p>
<div><pre><code><span>def</span> <span>cmp_to_key</span><span>(</span>mycmp<span>)</span><span>:</span>
    <span>'Convert a cmp= function into a key= function'</span>
    <span>class</span> <span>K</span><span>:</span>
        <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> obj<span>,</span> <span>*</span>args<span>)</span><span>:</span>
            self<span>.</span>obj <span>=</span> obj
        <span>def</span> <span>__lt__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>&lt;</span> <span>0</span>
        <span>def</span> <span>__gt__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>></span> <span>0</span>
        <span>def</span> <span>__eq__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>==</span> <span>0</span>
        <span>def</span> <span>__le__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>&lt;=</span> <span>0</span>
        <span>def</span> <span>__ge__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>>=</span> <span>0</span>
        <span>def</span> <span>__ne__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>!=</span> <span>0</span>
    <span>return</span> K
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>要转换为键函数，只需包装旧的比较函数：</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> key<span>=</span>cmp_to_key<span>(</span>reverse_numeric<span>)</span><span>)</span>
<span>[</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>在 Python 3.2 中， <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener noreferrer">functools.cmp_to_key()</a>  函数被添加到标准库中的  <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#module-functools" target="_blank" rel="noopener noreferrer">functools</a>  模块中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>游戏设计</title>
      <link>https://timpcfan.site/life/game/design.html</link>
      <guid>https://timpcfan.site/life/game/design.html</guid>
      <source url="https://timpcfan.site/rss.xml">游戏设计</source>
      <category>笔记</category>
      <pubDate>Sun, 02 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="游戏设计相关资源" tabindex="-1"> 游戏设计相关资源</h2>
<ul>
<li><a href="https://book.leveldesignbook.com/introduction" target="_blank" rel="noopener noreferrer">The Level Design Book</a></li>
</ul>
<div><p>提示</p>
<p><a href="https://weibo.com/u/5724617030" target="_blank" rel="noopener noreferrer">辣子鸡</a>推荐的关卡设计说明书</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>系统设计入门</title>
      <link>https://timpcfan.site/code/system-design/system-design-primer/</link>
      <guid>https://timpcfan.site/code/system-design/system-design-primer/</guid>
      <source url="https://timpcfan.site/rss.xml">系统设计入门</source>
      <category>转载</category>
      <pubDate>Sun, 02 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>原文地址：<a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener noreferrer">github.com/donnemartin/system-design-primer</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener noreferrer">掘金翻译计划</a></li>
<li>译者：<a href="https://github.com/XatMassacrE" target="_blank" rel="noopener noreferrer">XatMassacrE</a>、<a href="https://github.com/L9m" target="_blank" rel="noopener noreferrer">L9m</a>、<a href="https://github.com/Airmacho" target="_blank" rel="noopener noreferrer">Airmacho</a>、<a href="https://github.com/xiaoyusilen" target="_blank" rel="noopener noreferrer">xiaoyusilen</a>、<a href="https://github.com/jifaxu" target="_blank" rel="noopener noreferrer">jifaxu</a>、<a href="https://github.com/sqrthree" target="_blank" rel="noopener noreferrer">根号三</a></li>
</ul>
</blockquote>
<h1 id="系统设计入门" tabindex="-1"> 系统设计入门</h1>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/4rzy8D.png">
  <i>Content not supported</i>
</p>
<h2 id="目的" tabindex="-1"> 目的</h2>
<blockquote>
<p>学习如何设计大型系统。</p>
<p>为系统设计的面试做准备。</p>
</blockquote>
<h3 id="学习如何设计大型系统" tabindex="-1"> 学习如何设计大型系统</h3>
<p>学习如何设计可扩展的系统将会有助于你成为一个更好的工程师。</p>
<p>系统设计是一个很宽泛的话题。在互联网上，<strong>关于系统设计原则的资源也是多如牛毛。</strong></p>
<p>这个仓库就是这些资源的<strong>组织收集</strong>，它可以帮助你学习如何构建可扩展的系统。</p>
<h3 id="为系统设计的面试做准备" tabindex="-1"> 为系统设计的面试做准备</h3>
<p>在很多科技公司中，除了代码面试，系统设计也是<strong>技术面试过程</strong>中的一个<strong>必要环节</strong>。</p>
<p><strong>实践常见的系统设计面试题</strong>并且把你的答案和<strong>例子的解答</strong>进行<strong>对照</strong>：讨论，代码和图表。</p>
<p>面试准备的其他主题：</p>
<ul>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ul>
<h2 id="系统设计主题的索引" tabindex="-1"> 系统设计主题的索引</h2>
<blockquote>
<p>各种系统设计主题的摘要，包括优点和缺点。<strong>每一个主题都面临着取舍和权衡</strong>。</p>
<p>每个章节都包含着更多的资源的链接。</p>
</blockquote>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/trSJRx.png">
  <i>Content not supported</i>
</p>
<h2 id="学习指引" tabindex="-1"> 学习指引</h2>
<blockquote>
<p>基于你面试的时间线（短、中、长）去复习那些推荐的主题。</p>
</blockquote>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/bQjZIt.png" alt="" loading="lazy"></p>
<p><strong>问：对于面试来说，我需要知道这里的所有知识点吗？</strong></p>
<p><strong>答：不，如果只是为了准备面试的话，你并不需要知道所有的知识点。</strong></p>
<p>在一场面试中你会被问到什么取决于下面这些因素：</p>
<ul>
<li>你的经验</li>
<li>你的技术背景</li>
<li>你面试的职位</li>
<li>你面试的公司</li>
<li>运气</li>
</ul>
<p>那些有经验的候选人通常会被期望了解更多的系统设计的知识。架构师或者团队负责人则会被期望了解更多除了个人贡献之外的知识。顶级的科技公司通常也会有一次或者更多的系统设计面试。</p>
<p>面试会很宽泛的展开并在几个领域深入。这会帮助你了解一些关于系统设计的不同的主题。基于你的时间线，经验，面试的职位和面试的公司对下面的指导做出适当的调整。</p>
<ul>
<li><strong>短期</strong> - 以系统设计主题的<strong>广度</strong>为目标。通过解决<strong>一些</strong>面试题来练习。</li>
<li><strong>中期</strong> - 以系统设计主题的<strong>广度</strong>和<strong>初级深度</strong>为目标。通过解决<strong>很多</strong>面试题来练习。</li>
<li><strong>长期</strong> - 以系统设计主题的<strong>广度</strong>和<strong>高级深度</strong>为目标。通过解决<strong>大部分</strong>面试题来练习。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>短期</th>
<th>中期</th>
<th>长期</th>
</tr>
</thead>
<tbody>
<tr>
<td>阅读  以获得一个关于系统如何工作的宽泛的认识</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>阅读一些你要面试的的文章</td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>阅读 </td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>复习 </td>
<td>👍</td>
<td>👍</td>
<td>👍</td>
</tr>
<tr>
<td>完成 </td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
<tr>
<td>完成 </td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
<tr>
<td>复习 </td>
<td>一些</td>
<td>很多</td>
<td>大部分</td>
</tr>
</tbody>
</table>
<h2 id="如何处理一个系统设计的面试题" tabindex="-1"> 如何处理一个系统设计的面试题</h2>
<p>系统设计面试是一个<strong>开放式的对话</strong>。他们期望你去主导这个对话。</p>
<p>你可以使用下面的步骤来指引讨论。为了巩固这个过程，请使用下面的步骤完成这个章节。</p>
<h3 id="第一步-描述使用场景-约束和假设" tabindex="-1"> 第一步：描述使用场景，约束和假设</h3>
<p>把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。</p>
<ul>
<li>谁会使用它？</li>
<li>他们会怎样使用它？</li>
<li>有多少用户？</li>
<li>系统的作用是什么？</li>
<li>系统的输入输出分别是什么？</li>
<li>我们希望处理多少数据？</li>
<li>我们希望每秒钟处理多少请求？</li>
<li>我们希望的读写比率？</li>
</ul>
<h3 id="第二步-创造一个高层级的设计" tabindex="-1"> 第二步：创造一个高层级的设计</h3>
<p>使用所有重要的组件来描绘出一个高层级的设计。</p>
<ul>
<li>画出主要的组件和连接</li>
<li>证明你的想法</li>
</ul>
<h3 id="第三步-设计核心组件" tabindex="-1"> 第三步：设计核心组件</h3>
<p>对每一个核心组件进行详细深入的分析。举例来说，如果你被问到<a href="/code/system-design/system-design-primer/pastebin.html">设计一个 url 缩写服务</a>，开始讨论：</p>
<ul>
<li>生成并储存一个完整 url 的 hash
<ul>
<li><a href="/code/system-design/system-design-primer/pastebin.html">MD5</a> 和 <a href="/code/system-design/system-design-primer/pastebin.html">Base62</a></li>
<li>Hash 碰撞</li>
<li>SQL 还是 NoSQL</li>
<li>数据库模型</li>
</ul>
</li>
<li>将一个 hashed url 翻译成完整的 url
<ul>
<li>数据库查找</li>
</ul>
</li>
<li>API 和面向对象设计</li>
</ul>
<h3 id="第四步-扩展设计" tabindex="-1"> 第四步：扩展设计</h3>
<p>确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？</p>
<ul>
<li>负载均衡</li>
<li>水平扩展</li>
<li>缓存</li>
<li>数据库分片</li>
</ul>
<p>论述可能的解决办法和代价。每件事情需要取舍。可以使用来处理瓶颈。</p>
<h3 id="预估计算量" tabindex="-1"> 预估计算量</h3>
<p>你或许会被要求通过手算进行一些估算。涉及到的是下面的这些资源：</p>
<ul>
<li><a href="http://highscalability.com/blog/2011/1/26/google-pro-tip-use-back-of-the-envelope-calculations-to-choo.html" target="_blank" rel="noopener noreferrer">使用预估计算量</a></li>
<li></li>
<li></li>
</ul>
<h3 id="相关资源和延伸阅读" tabindex="-1"> 相关资源和延伸阅读</h3>
<p>查看下面的链接以获得我们期望的更好的想法：</p>
<ul>
<li><a href="https://www.palantir.com/2011/10/how-to-rock-a-systems-design-interview/" target="_blank" rel="noopener noreferrer">怎样通过一个系统设计的面试</a></li>
<li><a href="http://www.hiredintech.com/system-design" target="_blank" rel="noopener noreferrer">系统设计的面试</a></li>
<li><a href="https://www.youtube.com/watch?v=ZgdS0EUmn70" target="_blank" rel="noopener noreferrer">系统架构与设计的面试简介</a></li>
</ul>
<h2 id="系统设计的面试题和解答" tabindex="-1"> 系统设计的面试题和解答</h2>
<blockquote>
<p>普通的系统设计面试题和相关事例的论述，代码和图表。</p>
</blockquote>
<blockquote>
<p>与内容有关的解答在 <code>solutions/</code> 文件夹中。</p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设计 Pastebin.com (或者 Bit.ly)</td>
<td><a href="/code/system-design/system-design-primer/pastebin.html">解答</a></td>
</tr>
<tr>
<td>设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)</td>
<td><a href="/code/system-design/system-design-primer/twitter.html">解答</a></td>
</tr>
<tr>
<td>设计一个网页爬虫</td>
<td><a href="/code/system-design/system-design-primer/web_crawler.html">解答</a></td>
</tr>
<tr>
<td>设计 Mint.com</td>
<td><a href="/code/system-design/system-design-primer/mint.html">解答</a></td>
</tr>
<tr>
<td>为一个社交网络设计数据结构</td>
<td><a href="/code/system-design/system-design-primer/social_graph.html">解答</a></td>
</tr>
<tr>
<td>为搜索引擎设计一个 key-value 储存</td>
<td><a href="/code/system-design/system-design-primer/query_cache.html">解答</a></td>
</tr>
<tr>
<td>通过分类特性设计 Amazon 的销售排名</td>
<td><a href="/code/system-design/system-design-primer/sales_rank.html">解答</a></td>
</tr>
<tr>
<td>在 AWS 上设计一个百万用户级别的系统</td>
<td><a href="/code/system-design/system-design-primer/scaling_aws.html">解答</a></td>
</tr>
</tbody>
</table>
<h3 id="设计-pastebin-com-或者-bit-ly" tabindex="-1"> 设计 Pastebin.com (或者 Bit.ly)</h3>
<p><a href="/code/system-design/system-design-primer/pastebin.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gCRLTI.png" alt="" loading="lazy"></p>
<h3 id="设计-twitter-时间线和搜索-或者-facebook-feed-和搜索" tabindex="-1"> 设计 Twitter 时间线和搜索 (或者 Facebook feed 和搜索)</h3>
<p><a href="/code/system-design/system-design-primer/twitter.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/X82Bri.png" alt="" loading="lazy"></p>
<h3 id="设计一个网页爬虫" tabindex="-1"> 设计一个网页爬虫</h3>
<p><a href="/code/system-design/system-design-primer/web_crawler.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gHJYnF.png" alt="" loading="lazy"></p>
<h3 id="设计-mint-com" tabindex="-1"> 设计 Mint.com</h3>
<p><a href="/code/system-design/system-design-primer/mint.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/8IA620.png" alt="" loading="lazy"></p>
<h3 id="为一个社交网络设计数据结构" tabindex="-1"> 为一个社交网络设计数据结构</h3>
<p><a href="/code/system-design/system-design-primer/social_graph.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/FIuPES.png" alt="" loading="lazy"></p>
<h3 id="为搜索引擎设计一个-key-value-储存" tabindex="-1"> 为搜索引擎设计一个 key-value 储存</h3>
<p><a href="/code/system-design/system-design-primer/query_cache.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1toaVx.png" alt="" loading="lazy"></p>
<h3 id="设计按类别分类的-amazon-销售排名" tabindex="-1"> 设计按类别分类的 Amazon 销售排名</h3>
<p><a href="/code/system-design/system-design-primer/sales_rank.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/fxgGVS.png" alt="" loading="lazy"></p>
<h3 id="在-aws-上设计一个百万用户级别的系统" tabindex="-1"> 在 AWS 上设计一个百万用户级别的系统</h3>
<p><a href="/code/system-design/system-design-primer/scaling_aws.html">查看实践与解答</a></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/NdAfr9.png" alt="" loading="lazy"></p>
<h2 id="面向对象设计的面试问题及解答" tabindex="-1"> 面向对象设计的面试问题及解答</h2>
<blockquote>
<p>常见面向对象设计面试问题及实例讨论，代码和图表演示。</p>
<p>与内容相关的解决方案在 <code>solutions/</code> 文件夹中。</p>
</blockquote>
<blockquote>
<p><strong>注：此节还在完善中</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设计 hash map</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/hash_table/hash_map.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计 LRU 缓存</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/lru_cache/lru_cache.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计一个呼叫中心</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/call_center/call_center.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计一副牌</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/deck_of_cards/deck_of_cards.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计一个停车场</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/parking_lot/parking_lot.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计一个聊天服务</td>
<td><a href="https://github.com/donnemartin/system-design-primer/tree/master/solutions/object_oriented_design/online_chat/online_chat.ipynb" target="_blank" rel="noopener noreferrer">解决方案</a></td>
</tr>
<tr>
<td>设计一个环形数组</td>
<td></td>
</tr>
<tr>
<td>添加一个面向对象设计问题</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="系统设计主题-从这里开始" tabindex="-1"> 系统设计主题：从这里开始</h2>
<p>不熟悉系统设计？</p>
<p>首先，你需要对一般性原则有一个基本的认识，知道它们是什么，怎样使用以及利弊。</p>
<h3 id="第一步-回顾可扩展性-scalability-的视频讲座" tabindex="-1"> 第一步：回顾可扩展性（scalability）的视频讲座</h3>
<p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener noreferrer">哈佛大学可扩展性讲座</a></p>
<ul>
<li>主题涵盖
<ul>
<li>垂直扩展（Vertical scaling）</li>
<li>水平扩展（Horizontal scaling）</li>
<li>缓存</li>
<li>负载均衡</li>
<li>数据库复制</li>
<li>数据库分区</li>
</ul>
</li>
</ul>
<h3 id="第二步-回顾可扩展性文章" tabindex="-1"> 第二步：回顾可扩展性文章</h3>
<p><a href="http://www.lecloud.net/tagged/scalability/chrono" target="_blank" rel="noopener noreferrer">可扩展性</a></p>
<ul>
<li>主题涵盖：
<ul>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener noreferrer">Clones</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener noreferrer">数据库</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener noreferrer">缓存</a></li>
<li><a href="http://www.lecloud.net/post/9699762917/scalability-for-dummies-part-4-asynchronism" target="_blank" rel="noopener noreferrer">异步</a></li>
</ul>
</li>
</ul>
<h3 id="接下来的步骤" tabindex="-1"> 接下来的步骤</h3>
<p>接下来，我们将看看高阶的权衡和取舍:</p>
<ul>
<li><strong>性能</strong>与<strong>可扩展性</strong></li>
<li><strong>延迟</strong>与<strong>吞吐量</strong></li>
<li><strong>可用性</strong>与<strong>一致性</strong></li>
</ul>
<p>记住<strong>每个方面都面临取舍和权衡</strong>。</p>
<p>然后，我们将深入更具体的主题，如 DNS、CDN 和负载均衡器。</p>
<h2 id="性能与可扩展性" tabindex="-1"> 性能与可扩展性</h2>
<p>如果服务<strong>性能</strong>的增长与资源的增加是成比例的，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。<sup><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html">1</a></sup></p>
<p>另一个角度来看待性能与可扩展性:</p>
<ul>
<li>如果你的系统有<strong>性能</strong>问题，对于单个用户来说是缓慢的。</li>
<li>如果你的系统有<strong>可扩展性</strong>问题，单个用户较快但在高负载下会变慢。</li>
</ul>
<h3 id="来源及延伸阅读" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="http://www.allthingsdistributed.com/2006/03/a_word_on_scalability.html" target="_blank" rel="noopener noreferrer">简单谈谈可扩展性</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">可扩展性，可用性，稳定性和模式</a></li>
</ul>
<h2 id="延迟与吞吐量" tabindex="-1"> 延迟与吞吐量</h2>
<p><strong>延迟</strong>是执行操作或运算结果所花费的时间。</p>
<p><strong>吞吐量</strong>是单位时间内（执行）此类操作或运算的数量。</p>
<p>通常，你应该以<strong>可接受级延迟</strong>下<strong>最大化吞吐量</strong>为目标。</p>
<h3 id="来源及延伸阅读-1" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="https://community.cadence.com/cadence_blogs_8/b/sd/archive/2010/09/13/understanding-latency-vs-throughput" target="_blank" rel="noopener noreferrer">理解延迟与吞吐量</a></li>
</ul>
<h2 id="可用性与一致性" tabindex="-1"> 可用性与一致性</h2>
<h3 id="cap-理论" tabindex="-1"> CAP 理论</h3>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/nMNgXq.png">
  <i>Content not supported</i>
  <strong><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited">来源：再看 CAP 理论</a></strong>
</p>
<p>在一个分布式计算系统中，只能同时满足下列的两点:</p>
<ul>
<li><strong>一致性</strong> ─ 每次访问都能获得最新数据但可能会收到错误响应</li>
<li><strong>可用性</strong> ─ 每次访问都能收到非错响应，但不保证获取到最新数据</li>
<li><strong>分区容错性</strong> ─ 在任意分区网络故障的情况下系统仍能继续运行</li>
</ul>
<p><strong>网络并不可靠，所以你应要支持分区容错性，并需要在软件可用性和一致性间做出取舍。</strong></p>
<h4 id="cp-─-一致性和分区容错性" tabindex="-1"> CP ─ 一致性和分区容错性</h4>
<p>等待分区节点的响应可能会导致延时错误。如果你的业务需求需要原子读写，CP 是一个不错的选择。</p>
<h4 id="ap-─-可用性与分区容错性" tabindex="-1"> AP ─ 可用性与分区容错性</h4>
<p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。</p>
<p>如果业务需求允许，或当有外部故障时要求系统继续运行，AP 是一个不错的选择。</p>
<h3 id="来源及延伸阅读-2" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" target="_blank" rel="noopener noreferrer">再看 CAP 理论</a></li>
<li><a href="http://ksat.me/a-plain-english-introduction-to-cap-theorem/" target="_blank" rel="noopener noreferrer">通俗易懂地介绍 CAP 理论</a></li>
<li><a href="https://github.com/henryr/cap-faq" target="_blank" rel="noopener noreferrer">CAP FAQ</a></li>
</ul>
<h2 id="一致性模式" tabindex="-1"> 一致性模式</h2>
<p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 中的一致性定义 ─ 每次访问都能获得最新数据但可能会收到错误响应</p>
<h3 id="弱一致性" tabindex="-1"> 弱一致性</h3>
<p>在写入之后，访问可能看到，也可能看不到（写入数据）。尽力优化之让其能访问最新数据。</p>
<p>这种方式可以 memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。打个比方，如果你在通话中丢失信号几秒钟时间，当重新连接时你是听不到这几秒钟所说的话的。</p>
<h3 id="最终一致性" tabindex="-1"> 最终一致性</h3>
<p>在写入后，访问最终能看到写入数据（通常在数毫秒内）。数据被异步复制。</p>
<p>DNS 和 email 等系统使用的是此种方式。最终一致性在高可用性系统中效果不错。</p>
<h3 id="强一致性" tabindex="-1"> 强一致性</h3>
<p>在写入后，访问立即可见。数据被同步复制。</p>
<p>文件系统和关系型数据库（RDBMS）中使用的是此种方式。强一致性在需要记录的系统中运作良好。</p>
<h3 id="来源及延伸阅读-3" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="noopener noreferrer">Transactions across data centers</a></li>
</ul>
<h2 id="可用性模式" tabindex="-1"> 可用性模式</h2>
<p>有两种支持高可用性的模式: <strong>故障切换（fail-over）<strong>和</strong>复制（replication）</strong>。</p>
<h3 id="故障切换" tabindex="-1"> 故障切换</h3>
<h4 id="工作到备用切换-active-passive" tabindex="-1"> 工作到备用切换（Active-passive）</h4>
<p>关于工作到备用的故障切换流程是，工作服务器发送周期信号给待机中的备用服务器。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。</p>
<p>宕机时间取决于备用服务器处于“热”待机状态还是需要从“冷”待机状态进行启动。只有工作服务器处理流量。</p>
<p>工作到备用的故障切换也被称为主从切换。</p>
<h4 id="双工作切换-active-active" tabindex="-1"> 双工作切换（Active-active）</h4>
<p>在双工作切换中，双方都在管控流量，在它们之间分散负载。</p>
<p>如果是外网服务器，DNS 将需要对两方都了解。如果是内网服务器，应用程序逻辑将需要对两方都了解。</p>
<p>双工作切换也可以称为主主切换。</p>
<h3 id="缺陷-故障切换" tabindex="-1"> 缺陷：故障切换</h3>
<ul>
<li>故障切换需要添加额外硬件并增加复杂性。</li>
<li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据。</li>
</ul>
<h3 id="复制" tabindex="-1"> 复制</h3>
<h4 id="主-─-从复制和主-─-主复制" tabindex="-1"> 主 ─ 从复制和主 ─ 主复制</h4>
<p>这个主题进一步探讨了部分:</p>
<ul>
<li></li>
<li></li>
</ul>
<h2 id="域名系统" tabindex="-1"> 域名系统</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/GosmRV.jpg">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/srikrupa5/dns-security-presentation-issa">来源：DNS 安全介绍</a></strong>
</p>
<p>域名系统是把 www.example.com 等域名转换成 IP 地址。</p>
<p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于<a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener noreferrer">存活时间 TTL</a>。</p>
<ul>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务器。</li>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IP 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ example.com 指向 www.example.com ）或映射到一个 <code>A</code> 记录。</li>
</ul>
<p><a href="https://www.cloudflare.com/dns/" target="_blank" rel="noopener noreferrer">CloudFlare</a> 和 <a href="https://aws.amazon.com/route53/" target="_blank" rel="noopener noreferrer">Route 53</a> 等平台提供管理 DNS 的功能。某些 DNS 服务通过集中方式来路由流量:</p>
<ul>
<li><a href="http://g33kinfo.com/info/archives/2657" target="_blank" rel="noopener noreferrer">加权轮询调度</a>
<ul>
<li>防止流量进入维护中的服务器</li>
<li>在不同大小集群间负载均衡</li>
<li>A/B 测试</li>
</ul>
</li>
<li>基于延迟路由</li>
<li>基于地理位置路由</li>
</ul>
<h3 id="缺陷-dns" tabindex="-1"> 缺陷:DNS</h3>
<ul>
<li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li>
<li>虽然它们通常由<a href="http://superuser.com/questions/472695/who-controls-the-dns-servers/472729" target="_blank" rel="noopener noreferrer">政府，网络服务提供商和大公司</a>管理，但 DNS 服务管理仍可能是复杂的。</li>
<li>DNS 服务最近遭受 <a href="http://dyn.com/blog/dyn-analysis-summary-of-friday-october-21-attack/" target="_blank" rel="noopener noreferrer">DDoS 攻击</a>，阻止不知道 Twitter IP 地址的用户访问 Twitter。</li>
</ul>
<h3 id="来源及延伸阅读-4" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx" target="_blank" rel="noopener noreferrer">DNS 架构</a></li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener noreferrer">Wikipedia</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/" target="_blank" rel="noopener noreferrer">关于 DNS 的文章</a></li>
</ul>
<h2 id="内容分发网络-cdn" tabindex="-1"> 内容分发网络（CDN）</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/IPEWdV.jpg">
  <i>Content not supported</i>
  <strong><a href="https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/">来源：为什么使用 CDN</a></strong>
</p>
<p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p>
<p>将内容存储在 CDN 上可以从两个方面来提供性能:</p>
<ul>
<li>从靠近用户的数据中心提供资源</li>
<li>通过 CDN 你的服务器不必真的处理请求</li>
</ul>
<h3 id="cdn-推送-push" tabindex="-1"> CDN 推送（push）</h3>
<p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<h3 id="cdn-拉取-pull" tabindex="-1"> CDN 拉取（pull）</h3>
<p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live" target="_blank" rel="noopener noreferrer">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<h3 id="缺陷-cdn" tabindex="-1"> 缺陷：CDN</h3>
<ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
<h3 id="来源及延伸阅读-5" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener noreferrer">全球性内容分发网络</a></li>
<li><a href="http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/" target="_blank" rel="noopener noreferrer">CDN 拉取和 CDN 推送的区别</a></li>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="noopener noreferrer">Wikipedia</a></li>
</ul>
<h2 id="负载均衡器" tabindex="-1"> 负载均衡器</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/eH0pZ3.png">
  <i>Content not supported</i>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">来源：可扩展的系统设计模式</a></strong>
</p>
<p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p>
<ul>
<li>防止请求进入不好的服务器</li>
<li>防止资源过载</li>
<li>帮助消除单一的故障点</li>
</ul>
<p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。
增加的好处包括:</p>
<ul>
<li><strong>SSL 终结</strong> ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。
<ul>
<li>不需要再每台服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">X.509 证书</a>。</li>
</ul>
</li>
<li><strong>Session 留存</strong> ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li>
</ul>
<p>通常会设置采用 或  模式的多个负载均衡器，以免发生故障。</p>
<p>负载均衡器能基于多种方式来路由流量:</p>
<ul>
<li>随机</li>
<li>最少负载</li>
<li>Session/cookie</li>
<li><a href="http://g33kinfo.com/info/archives/2657" target="_blank" rel="noopener noreferrer">轮询调度或加权轮询调度算法</a></li>
<li></li>
<li></li>
</ul>
<h3 id="四层负载均衡" tabindex="-1"> 四层负载均衡</h3>
<p>四层负载均衡根据监看的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener noreferrer">网络地址转换（NAT）</a>来向上游服务器转发网络数据包。</p>
<h3 id="七层负载均衡器" tabindex="-1"> 七层负载均衡器</h3>
<p>七层负载均衡器根据监控来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p>
<p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p>
<h3 id="水平扩展" tabindex="-1"> 水平扩展</h3>
<p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<strong>垂直扩展</strong>更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p>
<h4 id="缺陷-水平扩展" tabindex="-1"> 缺陷：水平扩展</h4>
<ul>
<li>水平扩展引入了复杂度并涉及服务器复制
<ul>
<li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
<li>session 可以集中存储在数据库或持久化（Redis、Memcached）的数据存储区中。</li>
</ul>
</li>
<li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li>
</ul>
<h3 id="缺陷-负载均衡器" tabindex="-1"> 缺陷：负载均衡器</h3>
<ul>
<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>
<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>
<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>
</ul>
<h3 id="来源及延伸阅读-6" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener noreferrer">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener noreferrer">HAProxy 架构指南</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones" target="_blank" rel="noopener noreferrer">可扩展性</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener noreferrer">Wikipedia</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/" target="_blank" rel="noopener noreferrer">四层负载平衡</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/" target="_blank" rel="noopener noreferrer">七层负载平衡</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html" target="_blank" rel="noopener noreferrer">ELB 监听器配置</a></li>
</ul>
<h2 id="反向代理-web-服务器" tabindex="-1"> 反向代理（web 服务器）</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/99lNyZ.png">
  <i>Content not supported</i>
  <strong><a href="https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg">资料来源：维基百科</a></strong>
  <i>Content not supported</i>
</p>
<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>
<p>带来的好处包括：</p>
<ul>
<li><strong>增加安全性</strong> - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
<li><strong>提高可扩展性和灵活性</strong> - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
<li><strong>本地终结 SSL 会话</strong> - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。
<ul>
<li>免除了在每个服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">X.509</a> 证书的需要</li>
</ul>
</li>
<li><strong>压缩</strong> - 压缩服务器响应</li>
<li><strong>缓存</strong> - 直接返回命中的缓存结果</li>
<li><strong>静态内容</strong> - 直接提供静态内容
<ul>
<li>HTML/CSS/JS</li>
<li>图片</li>
<li>视频</li>
<li>等等</li>
</ul>
</li>
</ul>
<h3 id="负载均衡器与反向代理" tabindex="-1"> 负载均衡器与反向代理</h3>
<ul>
<li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li>
<li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li>
<li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li>
</ul>
<h3 id="不利之处-反向代理" tabindex="-1"> 不利之处：反向代理</h3>
<ul>
<li>引入反向代理会增加系统的复杂度。</li>
<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如<a href="https://en.wikipedia.org/wiki/Failover" target="_blank" rel="noopener noreferrer">故障转移</a>）会进一步增加复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-7" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/" target="_blank" rel="noopener noreferrer">反向代理与负载均衡</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/" target="_blank" rel="noopener noreferrer">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt" target="_blank" rel="noopener noreferrer">HAProxy 架构指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="noopener noreferrer">Wikipedia</a></li>
</ul>
<h2 id="应用层" tabindex="-1"> 应用层</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/Vn6Dxd.png">
  <i>Content not supported</i>
  <strong><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer">资料来源：可缩放系统构架介绍</a></strong>
</p>
<p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。</p>
<p><strong>单一职责原则</strong>提倡小型的，自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p>
<p>应用层中的工作进程也有可以实现。</p>
<h3 id="微服务" tabindex="-1"> 微服务</h3>
<p>与此讨论相关的话题是 <a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener noreferrer">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。<sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup></p>
<p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p>
<h3 id="服务发现" tabindex="-1"> 服务发现</h3>
<p>像 <a href="https://www.consul.io/docs/index.html" target="_blank" rel="noopener noreferrer">Consul</a>，<a href="https://coreos.com/etcd/docs/latest" target="_blank" rel="noopener noreferrer">Etcd</a> 和 <a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">Zookeeper</a> 这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。<a href="https://www.consul.io/intro/getting-started/checks.html" target="_blank" rel="noopener noreferrer">Health checks</a> 可以帮助确认服务的完整性和是否经常使用一个  路径。Consul 和 Etcd 都有一个内建的  用来存储配置信息和其他的共享信息。</p>
<h3 id="不利之处-应用层" tabindex="-1"> 不利之处：应用层</h3>
<ul>
<li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li>
<li>微服务会增加部署和运营的复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-8" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale" target="_blank" rel="noopener noreferrer">可缩放系统构架介绍</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">破解系统设计面试</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank" rel="noopener noreferrer">面向服务架构</a></li>
<li><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">Zookeeper 介绍</a></li>
<li><a href="https://cloudncode.wordpress.com/2016/07/22/msa-getting-started/" target="_blank" rel="noopener noreferrer">构建微服务，你所需要知道的一切</a></li>
</ul>
<h2 id="数据库" tabindex="-1"> 数据库</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/Yphy9o.png">
  <i>Content not supported</i>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>
<h3 id="关系型数据库管理系统-rdbms" tabindex="-1"> 关系型数据库管理系统（RDBMS）</h3>
<p>像 SQL 这样的关系型数据库是一系列以表的形式组织的数据项集合。</p>
<blockquote>
<p>校对注：这里作者 SQL 可能指的是 MySQL</p>
</blockquote>
<p><strong>ACID</strong> 用来描述关系型数据库<a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener noreferrer">事务</a>的特性。</p>
<ul>
<li><strong>原子性</strong> - 每个事务内部所有操作要么全部完成，要么全部不完成。</li>
<li><strong>一致性</strong> - 任何事务都使数据库从一个有效的状态转换到另一个有效状态。</li>
<li><strong>隔离性</strong> - 并发执行事务的结果与顺序执行事务的结果相同。</li>
<li><strong>持久性</strong> - 事务提交后，对系统的影响是永久的。</li>
</ul>
<p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和 <strong>SQL 调优</strong>。</p>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/J9ekTj.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<h4 id="主从复制" tabindex="-1"> 主从复制</h4>
<p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。</p>
<h5 id="不利之处-主从复制" tabindex="-1"> 不利之处：主从复制</h5>
<ul>
<li>将从库提升为主库需要额外的逻辑。</li>
<li>参考中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/SqrqxL.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<h4 id="主主复制" tabindex="-1"> 主主复制</h4>
<p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p>
<h5 id="不利之处-主主复制" tabindex="-1"> 不利之处： 主主复制</h5>
<ul>
<li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li>
<li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li>
<li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li>
<li>参考中，主从复制和主主复制<strong>共同</strong>的问题。</li>
</ul>
<h5 id="不利之处-复制" tabindex="-1"> 不利之处：复制</h5>
<ul>
<li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能。</li>
<li>写入会被重放到负责读取操作的副本。副本可能因为过多写操作阻塞住，导致读取功能异常。</li>
<li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟。</li>
<li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但读取副本只支持单线程顺序地写入。</li>
<li>复制意味着更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读-9" tabindex="-1"> 来源及延伸阅读</h5>
<ul>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">扩展性，可用性，稳定性模式</a></li>
<li><a href="https://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="noopener noreferrer">多主复制</a></li>
</ul>
<h4 id="联合" tabindex="-1"> 联合</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/d4lFbX.png">
  <i>Content not supported</i>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>
<p>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<h5 id="不利之处-联合" tabindex="-1"> 不利之处：联合</h5>
<ul>
<li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li>
<li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li>
<li>用 <a href="http://stackoverflow.com/questions/5145637/querying-data-by-joining-two-tables-in-two-database-on-different-servers" target="_blank" rel="noopener noreferrer">server link</a> 从两个库联结数据更复杂。</li>
<li>联合需要更多的硬件和额外的复杂度。</li>
</ul>
<h5 id="来源及延伸阅读-联合" tabindex="-1"> 来源及延伸阅读：联合</h5>
<ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener noreferrer">扩展你的用户数到第一个一千万</a></li>
</ul>
<h4 id="分片" tabindex="-1"> 分片</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/Cl5xCU.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。</p>
<p>类似的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<p>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p>
<h5 id="不利之处-分片" tabindex="-1"> 不利之处：分片</h5>
<ul>
<li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li>
<li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。
<ul>
<li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener noreferrer">一致性哈希</a>的分片算法可以减少这种情况。</li>
</ul>
</li>
<li>联结多个分片的数据操作更复杂。</li>
<li>分片需要更多的硬件和额外的复杂度。</li>
</ul>
<h4 id="来源及延伸阅读-分片" tabindex="-1"> 来源及延伸阅读：分片</h4>
<ul>
<li><a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html" target="_blank" rel="noopener noreferrer">分片时代来临</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shard_(database_architecture)" target="_blank" rel="noopener noreferrer">数据库分片架构</a></li>
<li><a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html" target="_blank" rel="noopener noreferrer">一致性哈希</a></li>
</ul>
<h4 id="非规范化" tabindex="-1"> 非规范化</h4>
<p>非规范化试图以写入性能为代价来换取读取性能。在多个表中冗余数据副本，以避免高成本的联结操作。一些关系型数据库，比如 <a href="https://en.wikipedia.org/wiki/PostgreSQL" target="_blank" rel="noopener noreferrer">PostgreSQL</a> 和 Oracle 支持<a href="https://en.wikipedia.org/wiki/Materialized_view" target="_blank" rel="noopener noreferrer">物化视图</a>，可以处理冗余信息存储和保证冗余副本一致。</p>
<p>当数据使用诸如和等技术被分割，进一步提高了处理跨数据中心的联结操作复杂度。非规范化可以规避这种复杂的联结操作。</p>
<p>在多数系统中，读取操作的频率远高于写入操作，比例可达到 100:1，甚至 1000:1。需要复杂的数据库联结的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p>
<h5 id="不利之处-非规范化" tabindex="-1"> 不利之处：非规范化</h5>
<ul>
<li>数据会冗余。</li>
<li>约束可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度。</li>
<li>非规范化的数据库在高写入负载下性能可能比规范化的数据库差。</li>
</ul>
<h5 id="来源及延伸阅读-非规范化" tabindex="-1"> 来源及延伸阅读：非规范化</h5>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Denormalization" target="_blank" rel="noopener noreferrer">非规范化</a></li>
</ul>
<h4 id="sql-调优" tabindex="-1"> SQL 调优</h4>
<p>SQL 调优是一个范围很广的话题，有很多相关的<a href="https://www.amazon.com/s/ref=nb_sb_noss_2?url=search-alias%3Daps&amp;field-keywords=sql+tuning" target="_blank" rel="noopener noreferrer">书</a>可以作为参考。</p>
<p>利用<strong>基准测试</strong>和<strong>性能分析</strong>来模拟和发现系统瓶颈很重要。</p>
<ul>
<li><strong>基准测试</strong> - 用 <a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="noopener noreferrer">ab</a> 等工具模拟高负载情况。</li>
<li><strong>性能分析</strong> - 通过启用如<a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener noreferrer">慢查询日志</a>等工具来辅助追踪性能问题。</li>
</ul>
<p>基准测试和性能分析可能会指引你到以下优化方案。</p>
<h5 id="改进模式" tabindex="-1"> 改进模式</h5>
<ul>
<li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li>
<li>使用 <code>CHAR</code> 类型存储固定长度的字段，不要用 <code>VARCHAR</code>。
<ul>
<li><code>CHAR</code> 在快速、随机访问时效率很高。如果使用 <code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li>
</ul>
</li>
<li>使用 <code>TEXT</code> 类型存储大块的文本，例如博客正文。<code>TEXT</code> 还允许布尔搜索。使用 <code>TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</li>
<li>使用 <code>INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</li>
<li>使用 <code>DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</li>
<li>避免使用 <code>BLOBS</code> 存储实际对象，而是用来存储存放对象的位置。</li>
<li><code>VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li>
<li>在适用场景中设置 <code>NOT NULL</code> 约束来<a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener noreferrer">提高搜索性能</a>。</li>
</ul>
<h5 id="使用正确的索引" tabindex="-1"> 使用正确的索引</h5>
<ul>
<li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li>
<li>索引通常表示为自平衡的 <a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener noreferrer">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li>
<li>设置索引，会将数据存在内存中，占用了更多内存空间。</li>
<li>写入操作会变慢，因为索引需要被更新。</li>
<li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li>
</ul>
<h5 id="避免高成本的联结操作" tabindex="-1"> 避免高成本的联结操作</h5>
<ul>
<li>有性能需要，可以进行非规范化。</li>
</ul>
<h5 id="分割数据表" tabindex="-1"> 分割数据表</h5>
<ul>
<li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li>
</ul>
<h5 id="调优查询缓存" tabindex="-1"> 调优查询缓存</h5>
<ul>
<li>在某些情况下，<a href="http://dev.mysql.com/doc/refman/5.7/en/query-cache" target="_blank" rel="noopener noreferrer">查询缓存</a>可能会导致<a href="https://www.percona.com/blog/2014/01/28/10-mysql-performance-tuning-settings-after-installation/" target="_blank" rel="noopener noreferrer">性能问题</a>。</li>
</ul>
<h5 id="来源及延伸阅读-10" tabindex="-1"> 来源及延伸阅读</h5>
<ul>
<li><a href="http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck" target="_blank" rel="noopener noreferrer">MySQL 查询优化小贴士</a></li>
<li><a href="http://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l" target="_blank" rel="noopener noreferrer">为什么 VARCHAR(255) 很常见？</a></li>
<li><a href="http://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search" target="_blank" rel="noopener noreferrer">Null 值是如何影响数据库性能的？</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html" target="_blank" rel="noopener noreferrer">慢查询日志</a></li>
</ul>
<h3 id="nosql" tabindex="-1"> NoSQL</h3>
<p>NoSQL 是<strong>键-值数据库</strong>、<strong>文档型数据库</strong>、<strong>列型数据库</strong>或<strong>图数据库</strong>的统称。数据库是非规范化的，表联结大多在应用程序代码中完成。大多数 NoSQL 无法实现真正符合 ACID 的事务，支持。</p>
<p><strong>BASE</strong> 通常被用于描述 NoSQL 数据库的特性。相比 ，BASE 强调可用性超过一致性。</p>
<ul>
<li><strong>基本可用</strong> - 系统保证可用性。</li>
<li><strong>软状态</strong> - 即使没有输入，系统状态也可能随着时间变化。</li>
<li><strong>最终一致性</strong> - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li>
</ul>
<p>除了在  之间做选择，了解哪种类型的 NoSQL 数据库最适合你的用例也是非常有帮助的。我们将在下一节中快速了解下 <strong>键-值存储</strong>、<strong>文档型存储</strong>、<strong>列型存储</strong>和<strong>图存储</strong>数据库。</p>
<h4 id="键-值存储" tabindex="-1"> 键-值存储</h4>
<blockquote>
<p>抽象模型：哈希表</p>
</blockquote>
<p>键-值存储通常可以实现 O(1) 时间读写，用内存或 SSD 存储数据。数据存储可以按<a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener noreferrer">字典顺序</a>维护键，从而实现键的高效检索。键-值存储可以用于存储元数据。</p>
<p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如存放在内存中的缓存。键-值存储提供的操作有限，如果需要更多操作，复杂度将转嫁到应用程序层面。</p>
<p>键-值存储是如文档存储，在某些情况下，甚至是图存储等更复杂的存储系统的基础。</p>
<h4 id="来源及延伸阅读-11" tabindex="-1"> 来源及延伸阅读</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Key-value_database" target="_blank" rel="noopener noreferrer">键-值数据库</a></li>
<li><a href="http://stackoverflow.com/questions/4056093/what-are-the-disadvantages-of-using-a-key-value-table-over-nullable-columns-or" target="_blank" rel="noopener noreferrer">键-值存储的劣势</a></li>
<li><a href="http://qnimate.com/overview-of-redis-architecture/" target="_blank" rel="noopener noreferrer">Redis 架构</a></li>
<li><a href="https://adayinthelifeof.nl/2011/02/06/memcache-internals/" target="_blank" rel="noopener noreferrer">Memcached 架构</a></li>
</ul>
<h4 id="文档类型存储" tabindex="-1"> 文档类型存储</h4>
<blockquote>
<p>抽象模型：将文档作为值的键-值存储</p>
</blockquote>
<p>文档类型存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构提供 API 或查询语句来实现查询。请注意，许多键-值存储数据库有用值存储元数据的特性，这也模糊了这两种存储类型的界限。</p>
<p>基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</p>
<p>MongoDB 和 CouchDB 等一些文档类型存储还提供了类似 SQL 语言的查询语句来实现复杂查询。DynamoDB 同时支持键-值存储和文档类型存储。</p>
<p>文档类型存储具备高度的灵活性，常用于处理偶尔变化的数据。</p>
<h4 id="来源及延伸阅读-文档类型存储" tabindex="-1"> 来源及延伸阅读：文档类型存储</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Document-oriented_database" target="_blank" rel="noopener noreferrer">面向文档的数据库</a></li>
<li><a href="https://www.mongodb.com/mongodb-architecture" target="_blank" rel="noopener noreferrer">MongoDB 架构</a></li>
<li><a href="https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/" target="_blank" rel="noopener noreferrer">CouchDB 架构</a></li>
<li><a href="https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up" target="_blank" rel="noopener noreferrer">Elasticsearch 架构</a></li>
</ul>
<h4 id="列型存储" tabindex="-1"> 列型存储</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/6Ys6ur.png">
  <i>Content not supported</i>
  <strong><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">资料来源: SQL 和 NoSQL，一个简短的历史</a></strong>
</p>
<blockquote>
<p>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p>
</blockquote>
<p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p>
<p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener noreferrer">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html" target="_blank" rel="noopener noreferrer">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p>
<p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p>
<h5 id="来源及延伸阅读-列型存储" tabindex="-1"> 来源及延伸阅读：列型存储</h5>
<ul>
<li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html" target="_blank" rel="noopener noreferrer">SQL 与 NoSQL 简史</a></li>
<li><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">BigTable 架构</a></li>
<li><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture" target="_blank" rel="noopener noreferrer">Hbase 架构</a></li>
<li><a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html" target="_blank" rel="noopener noreferrer">Cassandra 架构</a></li>
</ul>
<h4 id="图数据库" tabindex="-1"> 图数据库</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/PLUwzS.png">
  <i>Content not supported</i>
  <strong><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png">资料来源：图数据库</a></strong>
</p>
<blockquote>
<p>抽象模型： 图</p>
</blockquote>
<p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p>
<p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过  访问。</p>
<h5 id="相关资源和延伸阅读-图" tabindex="-1"> 相关资源和延伸阅读：图</h5>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database" target="_blank" rel="noopener noreferrer">图数据库</a></li>
<li><a href="https://neo4j.com/" target="_blank" rel="noopener noreferrer">Neo4j</a></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb" target="_blank" rel="noopener noreferrer">FlockDB</a></li>
</ul>
<h4 id="来源及延伸阅读-nosql" tabindex="-1"> 来源及延伸阅读：NoSQL</h4>
<ul>
<li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology" target="_blank" rel="noopener noreferrer">数据库术语解释</a></li>
<li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq" target="_blank" rel="noopener noreferrer">NoSQL 数据库 - 调查及决策指南</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database" target="_blank" rel="noopener noreferrer">可扩展性</a></li>
<li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I" target="_blank" rel="noopener noreferrer">NoSQL 介绍</a></li>
<li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html" target="_blank" rel="noopener noreferrer">NoSQL 模式</a></li>
</ul>
<h3 id="sql-还是-nosql" tabindex="-1"> SQL 还是 NoSQL</h3>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/lwTe70.png">
  <i>Content not supported</i>
  <strong><a href="https://www.infoq.com/articles/Transition-RDBMS-NoSQL/">资料来源：从 RDBMS 转换到 NoSQL</a></strong>
</p>
<p>选取 <strong>SQL</strong> 的原因:</p>
<ul>
<li>结构化数据</li>
<li>严格的模式</li>
<li>关系型数据</li>
<li>需要复杂的联结操作</li>
<li>事务</li>
<li>清晰的扩展模式</li>
<li>既有资源更丰富：开发者、社区、代码库、工具等</li>
<li>通过索引进行查询非常快</li>
</ul>
<p>选取 <strong>NoSQL</strong> 的原因：</p>
<ul>
<li>半结构化数据</li>
<li>动态或灵活的模式</li>
<li>非关系型数据</li>
<li>不需要复杂的联结操作</li>
<li>存储 TB （甚至 PB）级别的数据</li>
<li>高数据密集的工作负载</li>
<li>IOPS 高吞吐量</li>
</ul>
<p>适合 NoSQL 的示例数据：</p>
<ul>
<li>埋点数据和日志数据</li>
<li>排行榜或者得分数据</li>
<li>临时数据，如购物车</li>
<li>频繁访问的（“热”）表</li>
<li>元数据／查找表</li>
</ul>
<h5 id="来源及延伸阅读-sql-或-nosql" tabindex="-1"> 来源及延伸阅读：SQL 或 NoSQL</h5>
<ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU" target="_blank" rel="noopener noreferrer">扩展你的用户数到第一个千万</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/" target="_blank" rel="noopener noreferrer">SQL 和 NoSQL 的不同</a></li>
</ul>
<h2 id="缓存" tabindex="-1"> 缓存</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/jzJC80.png">
  <i>Content not supported</i>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">资料来源：可扩展的系统设计模式</a></strong>
</p>
<p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p>
<p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p>
<h3 id="客户端缓存" tabindex="-1"> 客户端缓存</h3>
<p>缓存可以位于客户端（操作系统或者浏览器），或者不同的缓存层。</p>
<h3 id="cdn-缓存" tabindex="-1"> CDN 缓存</h3>
<p> 也被视为一种缓存。</p>
<h3 id="web-服务器缓存" tabindex="-1"> Web 服务器缓存</h3>
<p>和缓存（比如 <a href="https://www.varnish-cache.org/" target="_blank" rel="noopener noreferrer">Varnish</a>）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</p>
<h3 id="数据库缓存" tabindex="-1"> 数据库缓存</h3>
<p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。调整配置，在不同情况下使用不同的模式可以进一步提高性能。</p>
<h3 id="应用缓存" tabindex="-1"> 应用缓存</h3>
<p>基于内存的缓存比如 Memcached 和 Redis 是应用程序和数据存储之间的一种键值存储。由于数据保存在 RAM 中，它比存储在磁盘上的典型数据库要快多了。RAM 比磁盘限制更多，所以例如 <a href="https://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used" target="_blank" rel="noopener noreferrer">least recently used (LRU)</a> 的<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener noreferrer">缓存无效算法</a>可以将「热门数据」放在 RAM 中，而对一些比较「冷门」的数据不做处理。</p>
<p>Redis 有下列附加功能：</p>
<ul>
<li>持久性选项</li>
<li>内置数据结构比如有序集合和列表</li>
</ul>
<p>有多个缓存级别，分为两大类：<strong>数据库查询</strong>和<strong>对象</strong>：</p>
<ul>
<li>行级别</li>
<li>查询级别</li>
<li>完整的可序列化对象</li>
<li>完全渲染的 HTML</li>
</ul>
<p>一般来说，你应该尽量避免基于文件的缓存，因为这使得复制和自动缩放很困难。</p>
<h3 id="数据库查询级别的缓存" tabindex="-1"> 数据库查询级别的缓存</h3>
<p>当你查询数据库的时候，将查询语句的哈希值与查询结果存储到缓存中。这种方法会遇到以下问题：</p>
<ul>
<li>很难用复杂的查询删除已缓存结果。</li>
<li>如果一条数据比如表中某条数据的一项被改变，则需要删除所有可能包含已更改项的缓存结果。</li>
</ul>
<h3 id="对象级别的缓存" tabindex="-1"> 对象级别的缓存</h3>
<p>将您的数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：</p>
<ul>
<li>如果对象的基础数据已经更改了，那么从缓存中删掉这个对象。</li>
<li>允许异步处理：workers 通过使用最新的缓存对象来组装对象。</li>
</ul>
<p>建议缓存的内容：</p>
<ul>
<li>用户会话</li>
<li>完全渲染的 Web 页面</li>
<li>活动流</li>
<li>用户图数据</li>
</ul>
<h3 id="何时更新缓存" tabindex="-1"> 何时更新缓存</h3>
<p>由于你只能在缓存中存储有限的数据，所以你需要选择一个适用于你用例的缓存更新策略。</p>
<h4 id="缓存模式" tabindex="-1"> 缓存模式</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/Iyf6Ae.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast">资料来源：从缓存到内存数据网格</a></strong>
</p>
<p>应用从存储器读写。缓存不和存储器直接交互，应用执行以下操作：</p>
<ul>
<li>在缓存中查找记录，如果所需数据不在缓存中</li>
<li>从数据库中加载所需内容</li>
<li>将查找到的结果存储到缓存中</li>
<li>返回所需内容</li>
</ul>
<div><pre><code><span>def</span> <span>get_user</span><span>(</span>self<span>,</span> user_id<span>)</span><span>:</span>
    user <span>=</span> cache<span>.</span>get<span>(</span><span>"user.{0}"</span><span>,</span> user_id<span>)</span>
    <span>if</span> user <span>is</span> <span>None</span><span>:</span>
        user <span>=</span> db<span>.</span>query<span>(</span><span>"SELECT * FROM users WHERE user_id = {0}"</span><span>,</span> user_id<span>)</span>
        <span>if</span> user <span>is</span> <span>not</span> <span>None</span><span>:</span>
            key <span>=</span> <span>"user.{0}"</span><span>.</span><span>format</span><span>(</span>user_id<span>)</span>
            cache<span>.</span><span>set</span><span>(</span>key<span>,</span> json<span>.</span>dumps<span>(</span>user<span>)</span><span>)</span>
    <span>return</span> user
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><a href="https://memcached.org/" target="_blank" rel="noopener noreferrer">Memcached</a> 通常用这种方式使用。</p>
<p>添加到缓存中的数据读取速度很快。缓存模式也称为延迟加载。只缓存所请求的数据，这避免了没有被请求的数据占满了缓存空间。</p>
<h5 id="缓存的缺点" tabindex="-1"> 缓存的缺点：</h5>
<ul>
<li>请求的数据如果不在缓存中就需要经过三个步骤来获取数据，这会导致明显的延迟。</li>
<li>如果数据库中的数据更新了会导致缓存中的数据过时。这个问题需要通过设置  TTL 强制更新缓存或者直写模式来缓解这种情况。</li>
<li>当一个节点出现故障的时候，它将会被一个新的节点替代，这增加了延迟的时间。</li>
</ul>
<h4 id="直写模式" tabindex="-1"> 直写模式</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/u7NGom.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>应用使用缓存作为主要的数据存储，将数据读写到缓存中，而缓存负责从数据库中读写数据。</p>
<ul>
<li>应用向缓存中添加/更新数据</li>
<li>缓存同步地写入数据存储</li>
<li>返回所需内容</li>
</ul>
<p>应用代码：</p>
<div><pre><code>set_user(12345, {"foo":"bar"})
</code></pre><div aria-hidden="true"><div></div></div></div><p>缓存代码：</p>
<div><pre><code><span>def</span> <span>set_user</span><span>(</span>user_id<span>,</span> values<span>)</span><span>:</span>
    user <span>=</span> db<span>.</span>query<span>(</span><span>"UPDATE Users WHERE id = {0}"</span><span>,</span> user_id<span>,</span> values<span>)</span>
    cache<span>.</span><span>set</span><span>(</span>user_id<span>,</span> user<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>由于存写操作所以直写模式整体是一种很慢的操作，但是读取刚写入的数据很快。相比读取数据，用户通常比较能接受更新数据时速度较慢。缓存中的数据不会过时。</p>
<h5 id="直写模式的缺点" tabindex="-1"> 直写模式的缺点：</h5>
<ul>
<li>由于故障或者缩放而创建的新的节点，新的节点不会缓存，直到数据库更新为止。缓存应用直写模式可以缓解这个问题。</li>
<li>写入的大多数数据可能永远都不会被读取，用 TTL 可以最小化这种情况的出现。</li>
</ul>
<h4 id="回写模式" tabindex="-1"> 回写模式</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/H3SU47.png">
  <i>Content not supported</i>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
<p>在回写模式中，应用执行以下操作：</p>
<ul>
<li>在缓存中增加或者更新条目</li>
<li>异步写入数据，提高写入性能。</li>
</ul>
<h5 id="回写模式的缺点" tabindex="-1"> 回写模式的缺点：</h5>
<ul>
<li>缓存可能在其内容成功存储之前丢失数据。</li>
<li>执行直写模式比缓存或者回写模式更复杂。</li>
</ul>
<h4 id="刷新" tabindex="-1"> 刷新</h4>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/U2BLz3.png">
  <i>Content not supported</i>
  <strong><a href=http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast>资料来源：从缓存到内存数据网格</a></strong>
</p>
<p>你可以将缓存配置成在到期之前自动刷新最近访问过的内容。</p>
<p>如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低。</p>
<h5 id="刷新的缺点" tabindex="-1"> 刷新的缺点：</h5>
<ul>
<li>不能准确预测到未来需要用到的数据可能会导致性能不如不使用刷新。</li>
</ul>
<h3 id="缓存的缺点-1" tabindex="-1"> 缓存的缺点：</h3>
<ul>
<li>需要保持缓存和真实数据源之间的一致性，比如数据库根据<a href="https://en.wikipedia.org/wiki/Cache_algorithms" target="_blank" rel="noopener noreferrer">缓存无效</a>。</li>
<li>需要改变应用程序比如增加 Redis 或者 memcached。</li>
<li>无效缓存是个难题，什么时候更新缓存是与之相关的复杂问题。</li>
</ul>
<h3 id="相关资源和延伸阅读-1" tabindex="-1"> 相关资源和延伸阅读</h3>
<ul>
<li><a href="http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast" target="_blank" rel="noopener noreferrer">从缓存到内存数据</a></li>
<li><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html" target="_blank" rel="noopener noreferrer">可扩展系统设计模式</a></li>
<li><a href="http://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener noreferrer">可缩放系统构架介绍</a></li>
<li><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/" target="_blank" rel="noopener noreferrer">可扩展性，可用性，稳定性和模式</a></li>
<li><a href="http://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache" target="_blank" rel="noopener noreferrer">可扩展性</a></li>
<li><a href="http://docs.aws.amazon.com/AmazonElastiCache/latest/UserGuide/Strategies.html" target="_blank" rel="noopener noreferrer">AWS ElastiCache 策略</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank" rel="noopener noreferrer">维基百科</a></li>
</ul>
<h2 id="异步" tabindex="-1"> 异步</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/GeFaAf.png">
  <i>Content not supported</i>
  <strong><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>资料来源：可缩放系统构架介绍</a></strong>
</p>
<p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p>
<h3 id="消息队列" tabindex="-1"> 消息队列</h3>
<p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p>
<ul>
<li>应用程序将作业发布到队列，然后通知用户作业状态</li>
<li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成</li>
</ul>
<p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p>
<p><strong>Redis</strong> 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p>
<p><strong>RabbitMQ</strong> 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</p>
<p><strong>Amazon SQS</strong> 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p>
<h3 id="任务队列" tabindex="-1"> 任务队列</h3>
<p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。 它们可以支持调度，并可用于在后台运行计算密集型作业。</p>
<p><strong>Celery</strong> 支持调度，主要是用 Python 开发的。</p>
<h3 id="背压" tabindex="-1"> 背压</h3>
<p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。<a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener noreferrer">背压</a>可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是<a href="https://en.wikipedia.org/wiki/Exponential_backoff" target="_blank" rel="noopener noreferrer">指数退避</a>。</p>
<h3 id="异步的缺点" tabindex="-1"> 异步的缺点：</h3>
<ul>
<li>简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li>
</ul>
<h3 id="相关资源和延伸阅读-2" tabindex="-1"> 相关资源和延伸阅读</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=1KRYH75wgy4" target="_blank" rel="noopener noreferrer">这是一个数字游戏</a></li>
<li><a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html" target="_blank" rel="noopener noreferrer">超载时应用背压</a></li>
<li><a href="https://en.wikipedia.org/wiki/Little%27s_law" target="_blank" rel="noopener noreferrer">利特尔法则</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-a-message-queue-and-a-task-queue-Why-would-a-task-queue-require-a-message-broker-like-RabbitMQ-Redis-Celery-or-IronMQ-to-function" target="_blank" rel="noopener noreferrer">消息队列与任务队列有什么区别？</a></li>
</ul>
<h2 id="通讯" tabindex="-1"> 通讯</h2>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/qTBwox.jpg">
  <i>Content not supported</i>
  <strong><a href=http://www.escotal.com/osilayer.html>资料来源：OSI 7层模型</a></strong>
</p>
<h3 id="超文本传输协议-http" tabindex="-1"> 超文本传输协议（HTTP）</h3>
<p>HTTP 是一种在客户端和服务器之间编码和传输数据的方法。它是一个请求/响应协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。HTTP 是独立的，允许请求和响应流经许多执行负载均衡，缓存，加密和压缩的中间路由器和服务器。</p>
<p>一个基本的 HTTP 请求由一个动词（方法）和一个资源（端点）组成。 以下是常见的 HTTP 动词：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>描述</th>
<th>*幂等</th>
<th>安全性</th>
<th>可缓存</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>读取资源</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源或触发处理数据的进程</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>PUT</td>
<td>创建或替换资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>PATCH</td>
<td>部分更新资源</td>
<td>No</td>
<td>No</td>
<td>Yes，如果回应包含刷新信息</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
</tbody>
</table>
<p><strong>多次执行不会产生不同的结果</strong>。</p>
<p>HTTP 是依赖于较低级协议（如 <strong>TCP</strong> 和 <strong>UDP</strong>）的应用层协议。</p>
<h4 id="来源及延伸阅读-http" tabindex="-1"> 来源及延伸阅读：HTTP</h4>
<ul>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol" target="_blank" rel="noopener noreferrer">README</a> +</li>
<li><a href="https://www.nginx.com/resources/glossary/http/" target="_blank" rel="noopener noreferrer">HTTP 是什么？</a></li>
<li><a href="https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol" target="_blank" rel="noopener noreferrer">HTTP 和 TCP 的区别</a></li>
<li><a href="https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1" target="_blank" rel="noopener noreferrer">PUT 和 PATCH 的区别</a></li>
</ul>
<h3 id="传输控制协议-tcp" tabindex="-1"> 传输控制协议（TCP）</h3>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/QI2nvi.jpg">
  <i>Content not supported</i>
  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1/">资料来源：如何制作多人游戏</a></strong>
</p>
<p>TCP 是通过 <a href="https://en.wikipedia.org/wiki/Internet_Protocol" target="_blank" rel="noopener noreferrer">IP 网络</a>的面向连接的协议。 使用<a href="https://en.wikipedia.org/wiki/Handshaking" target="_blank" rel="noopener noreferrer">握手</a>建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p>
<ul>
<li>每个数据包的序列号和<a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#Checksum_computation" target="_blank" rel="noopener noreferrer">校验码</a>。</li>
<li><a href="https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)" target="_blank" rel="noopener noreferrer">确认包</a>和自动重传</li>
</ul>
<p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行<a href="https://en.wikipedia.org/wiki/Flow_control_(data)" target="_blank" rel="noopener noreferrer">流量控制</a>和<a href="https://en.wikipedia.org/wiki/Network_congestion#Congestion_control" target="_blank" rel="noopener noreferrer">拥塞控制</a>。这些确保措施会导致延迟，而且通常导致传输效率比 UDP 低。</p>
<p>为了确保高吞吐量，Web 服务器可以保持大量的 TCP 连接，从而导致高内存使用。在 Web 服务器线程间拥有大量开放连接可能开销巨大，消耗资源过多，也就是说，一个  服务器。<a href="https://en.wikipedia.org/wiki/Connection_pool" target="_blank" rel="noopener noreferrer">连接池</a> 可以帮助除了在适用的情况下切换到 UDP。</p>
<p>TCP 对于需要高可靠性但时间紧迫的应用程序很有用。比如包括 Web 服务器，数据库信息，SMTP，FTP 和 SSH。</p>
<p>以下情况使用 TCP 代替 UDP：</p>
<ul>
<li>你需要数据完好无损。</li>
<li>你想对网络吞吐量自动进行最佳评估。</li>
</ul>
<h3 id="用户数据报协议-udp" tabindex="-1"> 用户数据报协议（UDP）</h3>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/oUNCQg.jpg">
  <i>Content not supported</i>
  <strong><a href="http://www.wildbunny.co.uk/blog/2012/10/09/how-to-make-a-multi-player-game-part-1">资料来源：如何制作多人游戏</a></strong>
</p>
<p>UDP 是无连接的。数据报（类似于数据包）只在数据报级别有保证。数据报可能会无序的到达目的地，也有可能会遗失。UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 UDP 通常效率更高。</p>
<p>UDP 可以通过广播将数据报发送至子网内的所有设备。这对 <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol" target="_blank" rel="noopener noreferrer">DHCP</a> 很有用，因为子网内的设备还没有分配 IP 地址，而 IP 对于 TCP 是必须的。</p>
<p>UDP 可靠性更低但适合用在网络电话、视频聊天，流媒体和实时多人游戏上。</p>
<p>以下情况使用 UDP 代替 TCP：</p>
<ul>
<li>你需要低延迟</li>
<li>相对于数据丢失更糟的是数据延迟</li>
<li>你想实现自己的错误校正方法</li>
</ul>
<h4 id="来源及延伸阅读-tcp-与-udp" tabindex="-1"> 来源及延伸阅读：TCP 与 UDP</h4>
<ul>
<li><a href="http://gafferongames.com/networking-for-game-programmers/udp-vs-tcp/" target="_blank" rel="noopener noreferrer">游戏编程的网络</a></li>
<li><a href="http://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/" target="_blank" rel="noopener noreferrer">TCP 与 UDP 的关键区别</a></li>
<li><a href="http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp" target="_blank" rel="noopener noreferrer">TCP 与 UDP 的不同</a></li>
<li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol" target="_blank" rel="noopener noreferrer">传输控制协议</a></li>
<li><a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer">用户数据报协议</a></li>
<li><a href="http://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf" target="_blank" rel="noopener noreferrer">Memcache 在 Facebook 的扩展</a></li>
</ul>
<h3 id="远程过程调用协议-rpc" tabindex="-1"> 远程过程调用协议（RPC）</h3>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/ZY4SYg.png">
  <i>Content not supported</i>
  <strong><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview">Source: Crack the system design interview</a></strong>
</p>
<p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 <a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener noreferrer">Protobuf</a>、<a href="https://thrift.apache.org/" target="_blank" rel="noopener noreferrer">Thrift</a> 和 <a href="https://avro.apache.org/docs/current/" target="_blank" rel="noopener noreferrer">Avro</a>。</p>
<p>RPC 是一个“请求-响应”协议：</p>
<ul>
<li><strong>客户端程序</strong> ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li>
<li><strong>客户端 stub 程序</strong> ── 将请求过程的 id 和参数打包进请求信息中。</li>
<li><strong>客户端通信模块</strong> ── 将信息从客户端发送至服务端。</li>
<li><strong>服务端通信模块</strong> ── 将接受的包传给服务端存根程序。</li>
<li><strong>服务端 stub 程序</strong> ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li>
</ul>
<p>RPC 调用示例：</p>
<div><pre><code>GET /someoperation?data=anId

POST /anotheroperation
{
  "data":"anId";
  "anotherdata": "another value"
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>RPC 专注于暴露方法。RPC 通常用于处理内部通讯的性能问题，这样你可以手动处理本地调用以更好的适应你的情况。</p>
<p>当以下情况时选择本地库（也就是 SDK）：</p>
<ul>
<li>你知道你的目标平台。</li>
<li>你想控制如何访问你的“逻辑”。</li>
<li>你想对发生在你的库中的错误进行控制。</li>
<li>性能和终端用户体验是你最关心的事。</li>
</ul>
<p>遵循 <strong>REST</strong> 的 HTTP API 往往更适用于公共 API。</p>
<h4 id="缺点-rpc" tabindex="-1"> 缺点：RPC</h4>
<ul>
<li>RPC 客户端与服务实现捆绑地很紧密。</li>
<li>一个新的 API 必须在每一个操作或者用例中定义。</li>
<li>RPC 很难调试。</li>
<li>你可能没办法很方便的去修改现有的技术。举个例子，如果你希望在 <a href="http://www.squid-cache.org/" target="_blank" rel="noopener noreferrer">Squid</a> 这样的缓存服务器上确保 <a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener noreferrer">RPC 被正确缓存</a>的话可能需要一些额外的努力了。</li>
</ul>
<h3 id="表述性状态转移-rest" tabindex="-1"> 表述性状态转移（REST）</h3>
<p>REST 是一种强制的客户端/服务端架构设计模型，客户端基于服务端管理的一系列资源操作。服务端提供修改或获取资源的接口。所有的通信必须是无状态和可缓存的。</p>
<p>RESTful 接口有四条规则：</p>
<ul>
<li><strong>标志资源（HTTP 里的 URI）</strong> ── 无论什么操作都使用同一个 URI。</li>
<li><strong>表示的改变（HTTP 的动作）</strong> ── 使用动作, headers 和 body。</li>
<li><strong>可自我描述的错误信息（HTTP 中的 status code）</strong> ── 使用状态码，不要重新造轮子。</li>
<li><strong><a href="http://restcookbook.com/Basics/hateoas/" target="_blank" rel="noopener noreferrer">HATEOAS</a>（HTTP 中的 HTML 接口）</strong> ── 你的 web 服务器应该能够通过浏览器访问。</li>
</ul>
<p>REST 请求的例子：</p>
<div><pre><code>GET /someresources/anId

PUT /someresources/anId
{"anotherdata": "another value"}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>REST 关注于暴露数据。它减少了客户端／服务端的耦合程度，经常用于公共 HTTP API 接口设计。REST 使用更通常与规范化的方法来通过 URI 暴露资源，<a href="https://github.com/for-GET/know-your-http-well/blob/master/headers.md" target="_blank" rel="noopener noreferrer">通过 header 来表述</a>并通过 GET、POST、PUT、DELETE 和 PATCH 这些动作来进行操作。因为无状态的特性，REST 易于横向扩展和隔离。</p>
<h4 id="缺点-rest" tabindex="-1"> 缺点：REST</h4>
<ul>
<li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织的或者结构复杂的时候它可能无法很好的适应。举个例子，返回过去一小时中与特定事件集匹配的更新记录这种操作就很难表示为路径。使用 REST，可能会使用 URI 路径，查询参数和可能的请求体来实现。</li>
<li>REST 一般依赖几个动作（GET、POST、PUT、DELETE 和 PATCH），但有时候仅仅这些没法满足你的需要。举个例子，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单的用上面这几个 verbs 表达。</li>
<li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源需要客户端，服务器之间多次往返通信。例如，获取博客内容及其关联评论。对于使用不确定网络环境的移动应用来说，这些多次往返通信是非常麻烦的。</li>
<li>随着时间的推移，更多的字段可能会被添加到 API 响应中，较旧的客户端将会接收到所有新的数据字段，即使是那些它们不需要的字段，结果它会增加负载大小并引起更大的延迟。</li>
</ul>
<h3 id="rpc-与-rest-比较" tabindex="-1"> RPC 与 REST 比较</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>RPC</th>
<th>REST</th>
</tr>
</thead>
<tbody>
<tr>
<td>注册</td>
<td><strong>POST</strong> /signup</td>
<td><strong>POST</strong> /persons</td>
</tr>
<tr>
<td>注销</td>
<td><strong>POST</strong> /resign<i>Content not supported</i>{<i>Content not supported</i>&quot;personid&quot;: &quot;1234&quot;<i>Content not supported</i>}</td>
<td><strong>DELETE</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户信息</td>
<td><strong>GET</strong> /readPerson?personid=1234</td>
<td><strong>GET</strong> /persons/1234</td>
</tr>
<tr>
<td>读取用户物品列表</td>
<td><strong>GET</strong> /readUsersItemsList?personid=1234</td>
<td><strong>GET</strong> /persons/1234/items</td>
</tr>
<tr>
<td>向用户物品列表添加一项</td>
<td><strong>POST</strong> /addItemToUsersItemsList<i>Content not supported</i>{<i>Content not supported</i>&quot;personid&quot;: &quot;1234&quot;;<i>Content not supported</i>&quot;itemid&quot;: &quot;456&quot;<i>Content not supported</i>}</td>
<td><strong>POST</strong> /persons/1234/items<i>Content not supported</i>{<i>Content not supported</i>&quot;itemid&quot;: &quot;456&quot;<i>Content not supported</i>}</td>
</tr>
<tr>
<td>更新一个物品</td>
<td><strong>POST</strong> /modifyItem<i>Content not supported</i>{<i>Content not supported</i>&quot;itemid&quot;: &quot;456&quot;;<i>Content not supported</i>&quot;key&quot;: &quot;value&quot;<i>Content not supported</i>}</td>
<td><strong>PUT</strong> /items/456<i>Content not supported</i>{<i>Content not supported</i>&quot;key&quot;: &quot;value&quot;<i>Content not supported</i>}</td>
</tr>
<tr>
<td>删除一个物品</td>
<td><strong>POST</strong> /removeItem<i>Content not supported</i>{<i>Content not supported</i>&quot;itemid&quot;: &quot;456&quot;<i>Content not supported</i>}</td>
<td><strong>DELETE</strong> /items/456</td>
</tr>
</tbody>
</table>
<p align="center">
  <strong><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc">资料来源：你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></strong>
</p>
<h4 id="来源及延伸阅读-rest-与-rpc" tabindex="-1"> 来源及延伸阅读：REST 与 RPC</h4>
<ul>
<li><a href="https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/" target="_blank" rel="noopener noreferrer">你真的知道你为什么更喜欢 REST 而不是 RPC 吗</a></li>
<li><a href="http://programmers.stackexchange.com/a/181186" target="_blank" rel="noopener noreferrer">什么时候 RPC 比 REST 更合适？</a></li>
<li><a href="http://stackoverflow.com/questions/15056878/rest-vs-json-rpc" target="_blank" rel="noopener noreferrer">REST vs JSON-RPC</a></li>
<li><a href="http://etherealbits.com/2012/12/debunking-the-myths-of-rpc-rest/" target="_blank" rel="noopener noreferrer">揭开 RPC 和 REST 的神秘面纱</a></li>
<li><a href="https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs" target="_blank" rel="noopener noreferrer">使用 REST 的缺点是什么</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">破解系统设计面试</a></li>
<li><a href="https://code.facebook.com/posts/1468950976659943/" target="_blank" rel="noopener noreferrer">Thrift</a></li>
<li><a href="http://arstechnica.com/civis/viewtopic.php?t=1190508" target="_blank" rel="noopener noreferrer">为什么在内部使用 REST 而不是 RPC</a></li>
</ul>
<h2 id="安全" tabindex="-1"> 安全</h2>
<p>这一部分需要更多内容。！</p>
<p>安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：</p>
<ul>
<li>在运输和等待过程中加密</li>
<li>对所有的用户输入和从用户那里发来的参数进行处理以防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener noreferrer">XSS</a> 和 <a href="https://en.wikipedia.org/wiki/SQL_injection" target="_blank" rel="noopener noreferrer">SQL 注入</a>。</li>
<li>使用参数化的查询来防止 SQL 注入。</li>
<li>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege" target="_blank" rel="noopener noreferrer">最小权限原则</a>。</li>
</ul>
<h3 id="来源及延伸阅读-12" tabindex="-1"> 来源及延伸阅读</h3>
<ul>
<li><a href="https://github.com/FallibleInc/security-guide-for-developers" target="_blank" rel="noopener noreferrer">为开发者准备的安全引导</a></li>
<li><a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet" target="_blank" rel="noopener noreferrer">OWASP top ten</a></li>
</ul>
<h2 id="附录" tabindex="-1"> 附录</h2>
<p>一些时候你会被要求做出保守估计。比如，你可能需要估计从磁盘中生成 100 张图片的缩略图需要的时间或者一个数据结构需要多少的内存。<strong>2 的次方表</strong>和<strong>每个开发者都需要知道的一些时间数据</strong>（译注：OSChina 上有这篇文章的<a href="https://www.oschina.net/news/30009/every-programmer-should-know" target="_blank" rel="noopener noreferrer">译文</a>）都是一些很方便的参考资料。</p>
<h3 id="_2-的次方表" tabindex="-1"> 2 的次方表</h3>
<div><pre><code>Power           Exact Value         Approx Value        Bytes
---------------------------------------------------------------
7                             128
8                             256
10                           1024   1 thousand           1 KB
16                         65,536                       64 KB
20                      1,048,576   1 million            1 MB
30                  1,073,741,824   1 billion            1 GB
32                  4,294,967,296                        4 GB
40              1,099,511,627,776   1 trillion           1 TB
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="来源及延伸阅读-13" tabindex="-1"> 来源及延伸阅读</h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Power_of_two" target="_blank" rel="noopener noreferrer">2 的次方</a></li>
</ul>
<h3 id="每个程序员都应该知道的延迟数" tabindex="-1"> 每个程序员都应该知道的延迟数</h3>
<div><pre><code>Latency Comparison Numbers
--------------------------
L1 cache reference                           0.5 ns
Branch mispredict                            5   ns
L2 cache reference                           7   ns                      14x L1 cache
Mutex lock/unlock                           25   ns
Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache
Compress 1K bytes with Zippy            10,000   ns       10 us
Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us
Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD
Read 1 MB sequentially from memory     250,000   ns      250 us
Round trip within same datacenter      500,000   ns      500 us
Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory
Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip
Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD
Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD
Send packet CA->Netherlands->CA    150,000,000   ns  150,000 us  150 ms

Notes
-----
1 ns = 10^-9 seconds
1 us = 10^-6 seconds = 1,000 ns
1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>基于上述数字的指标：</p>
<ul>
<li>从磁盘以 30 MB/s 的速度顺序读取</li>
<li>以 100 MB/s 从 1 Gbps 的以太网顺序读取</li>
<li>从 SSD 以 1 GB/s 的速度读取</li>
<li>以 4 GB/s 的速度从主存读取</li>
<li>每秒能绕地球 6-7 圈</li>
<li>数据中心内每秒有 2,000 次往返</li>
</ul>
<h4 id="延迟数可视化" tabindex="-1"> 延迟数可视化</h4>
<img src="https://camo.githubusercontent.com/77f72259e1eb58596b564d1ad823af1853bc60a3/687474703a2f2f692e696d6775722e636f6d2f6b307431652e706e67">
<h4 id="来源及延伸阅读-14" tabindex="-1"> 来源及延伸阅读</h4>
<ul>
<li><a href="https://gist.github.com/jboner/2841832" target="_blank" rel="noopener noreferrer">每个程序员都应该知道的延迟数 — 1</a></li>
<li><a href="https://gist.github.com/hellerbarde/2843375" target="_blank" rel="noopener noreferrer">每个程序员都应该知道的延迟数 — 2</a></li>
<li><a href="http://www.cs.cornell.edu/projects/ladis2009/talks/dean-keynote-ladis2009.pdf" target="_blank" rel="noopener noreferrer">关于建设大型分布式系统的的设计方案、课程和建议</a></li>
<li><a href="https://static.googleusercontent.com/media/research.google.com/en//people/jeff/stanford-295-talk.pdf" target="_blank" rel="noopener noreferrer">关于建设大型可拓展分布式系统的软件工程咨询</a></li>
</ul>
<h3 id="其它的系统设计面试题" tabindex="-1"> 其它的系统设计面试题</h3>
<blockquote>
<p>常见的系统设计面试问题，给出了如何解决的方案链接</p>
</blockquote>
<table>
<thead>
<tr>
<th>问题</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>设计类似于 Dropbox 的文件同步服务</td>
<td><a href="https://www.youtube.com/watch?v=PE4gwstWhmc" target="_blank" rel="noopener noreferrer">youtube.com</a></td>
</tr>
<tr>
<td>设计类似于 Google 的搜索引擎</td>
<td><a href="http://queue.acm.org/detail.cfm?id=988407" target="_blank" rel="noopener noreferrer">queue.acm.org</a><i>Content not supported</i><a href="http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search" target="_blank" rel="noopener noreferrer">stackexchange.com</a><i>Content not supported</i><a href="http://www.ardendertat.com/2012/01/11/implementing-search-engines/" target="_blank" rel="noopener noreferrer">ardendertat.com</a><i>Content not supported</i><a href="http://infolab.stanford.edu/~backrub/google.html" target="_blank" rel="noopener noreferrer">stanford.edu</a></td>
</tr>
<tr>
<td>设计类似于 Google 的可扩展网络爬虫</td>
<td><a href="https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch" target="_blank" rel="noopener noreferrer">quora.com</a></td>
</tr>
<tr>
<td>设计 Google 文档</td>
<td><a href="https://code.google.com/p/google-mobwrite/" target="_blank" rel="noopener noreferrer">code.google.com</a><i>Content not supported</i><a href="https://neil.fraser.name/writing/sync/" target="_blank" rel="noopener noreferrer">neil.fraser.name</a></td>
</tr>
<tr>
<td>设计类似 Redis 的键值存储</td>
<td><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>设计类似 Memcached 的缓存系统</td>
<td><a href="http://www.slideshare.net/oemebamo/introduction-to-memcached" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>设计类似亚马逊的推荐系统</td>
<td><a href="http://tech.hulu.com/blog/2011/09/19/recommendation-system.html" target="_blank" rel="noopener noreferrer">hulu.com</a><i>Content not supported</i><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf" target="_blank" rel="noopener noreferrer">ijcai13.org</a></td>
</tr>
<tr>
<td>设计类似 Bitly 的短链接系统</td>
<td><a href="http://n00tc0d3r.blogspot.com/" target="_blank" rel="noopener noreferrer">n00tc0d3r.blogspot.com</a></td>
</tr>
<tr>
<td>设计类似 WhatsApp 的聊天应用</td>
<td><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html" target="_blank" rel="noopener noreferrer">highscalability.com</a></td>
</tr>
<tr>
<td>设计类似 Instagram 的图片分享系统</td>
<td><a href="http://highscalability.com/flickr-architecture" target="_blank" rel="noopener noreferrer">highscalability.com</a><i>Content not supported</i><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener noreferrer">highscalability.com</a></td>
</tr>
<tr>
<td>设计 Facebook 的新闻推荐方法</td>
<td><a href="http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed" target="_blank" rel="noopener noreferrer">quora.com</a><i>Content not supported</i><a href="http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed" target="_blank" rel="noopener noreferrer">quora.com</a><i>Content not supported</i><a href="http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>设计 Facebook 的时间线系统</td>
<td><a href="https://www.facebook.com/note.php?note_id=10150468255628920" target="_blank" rel="noopener noreferrer">facebook.com</a><i>Content not supported</i><a href="http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html" target="_blank" rel="noopener noreferrer">highscalability.com</a></td>
</tr>
<tr>
<td>设计 Facebook 的聊天系统</td>
<td><a href="http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf" target="_blank" rel="noopener noreferrer">erlang-factory.com</a><i>Content not supported</i><a href="https://www.facebook.com/note.php?note_id=14218138919&amp;id=9445547199&amp;index=0" target="_blank" rel="noopener noreferrer">facebook.com</a></td>
</tr>
<tr>
<td>设计类似 Facebook 的图表搜索系统</td>
<td><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920" target="_blank" rel="noopener noreferrer">facebook.com</a><i>Content not supported</i><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920" target="_blank" rel="noopener noreferrer">facebook.com</a><i>Content not supported</i><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920" target="_blank" rel="noopener noreferrer">facebook.com</a></td>
</tr>
<tr>
<td>设计类似 CloudFlare 的内容传递网络</td>
<td><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&amp;context=compsci" target="_blank" rel="noopener noreferrer">cmu.edu</a></td>
</tr>
<tr>
<td>设计类似 Twitter 的热门话题系统</td>
<td><a href="http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/" target="_blank" rel="noopener noreferrer">michael-noll.com</a><i>Content not supported</i><a href="http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/" target="_blank" rel="noopener noreferrer">snikolov .wordpress.com</a></td>
</tr>
<tr>
<td>设计一个随机 ID 生成系统</td>
<td><a href="https://blog.twitter.com/2010/announcing-snowflake" target="_blank" rel="noopener noreferrer">blog.twitter.com</a><i>Content not supported</i><a href="https://github.com/twitter/snowflake/" target="_blank" rel="noopener noreferrer">github.com</a></td>
</tr>
<tr>
<td>返回一定时间段内次数前 k 高的请求</td>
<td><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf" target="_blank" rel="noopener noreferrer">ucsb.edu</a><i>Content not supported</i><a href="http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf" target="_blank" rel="noopener noreferrer">wpi.edu</a></td>
</tr>
<tr>
<td>设计一个数据源于多个数据中心的服务系统</td>
<td><a href="http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html" target="_blank" rel="noopener noreferrer">highscalability.com</a></td>
</tr>
<tr>
<td>设计一个多人网络卡牌游戏</td>
<td><a href="https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html" target="_blank" rel="noopener noreferrer">indieflashblog.com</a><i>Content not supported</i><a href="http://buildnewgames.com/real-time-multiplayer/" target="_blank" rel="noopener noreferrer">buildnewgames.com</a></td>
</tr>
<tr>
<td>设计一个垃圾回收系统</td>
<td><a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/" target="_blank" rel="noopener noreferrer">stuffwithstuff.com</a><i>Content not supported</i><a href="http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf" target="_blank" rel="noopener noreferrer">washington.edu</a></td>
</tr>
<tr>
<td>添加更多的系统设计问题</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="真实架构" tabindex="-1"> 真实架构</h3>
<blockquote>
<p>关于现实中真实的系统是怎么设计的文章。</p>
</blockquote>
<p align="center">
  <img src="http://timpcfan-site.cdn.bcebos.com/imgs/YonmRt.png">
  <i>Content not supported</i>
  <strong><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability">Source: Twitter timelines at scale</a></strong>
</p>
<p><strong>不要专注于以下文章的细节，专注于以下方面：</strong></p>
<ul>
<li>发现这些文章中的共同的原则、技术和模式。</li>
<li>学习每个组件解决哪些问题，什么情况下使用，什么情况下不适用</li>
<li>复习学过的文章</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>系统</th>
<th>引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data processing</td>
<td><strong>MapReduce</strong> - Google 的分布式数据处理</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a></td>
</tr>
<tr>
<td>Data processing</td>
<td><strong>Spark</strong> - Databricks 的分布式数据处理</td>
<td><a href="http://www.slideshare.net/AGrishchenko/apache-spark-architecture" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Data processing</td>
<td><strong>Storm</strong> - Twitter 的分布式数据处理</td>
<td><a href="http://www.slideshare.net/previa/storm-16094009" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Bigtable</strong> - Google 的列式数据库</td>
<td><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf" target="_blank" rel="noopener noreferrer">harvard.edu</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>HBase</strong> - Bigtable 的开源实现</td>
<td><a href="http://www.slideshare.net/alexbaranau/intro-to-hbase" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Cassandra</strong> - Facebook 的列式数据库</td>
<td><a href="http://www.slideshare.net/planetcassandra/cassandra-introduction-features-30103666" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>DynamoDB</strong> - Amazon 的文档数据库</td>
<td><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="noopener noreferrer">harvard.edu</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>MongoDB</strong> - 文档数据库</td>
<td><a href="http://www.slideshare.net/mdirolf/introduction-to-mongodb" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Spanner</strong> - Google 的全球分布数据库</td>
<td><a href="http://research.google.com/archive/spanner-osdi2012.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Memcached</strong> - 分布式内存缓存系统</td>
<td><a href="http://www.slideshare.net/oemebamo/introduction-to-memcached" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Data store</td>
<td><strong>Redis</strong> - 能够持久化及具有值类型的分布式内存缓存系统</td>
<td><a href="http://www.slideshare.net/dvirsky/introduction-to-redis" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>File system</td>
<td><strong>Google File System (GFS)</strong> - 分布式文件系统</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/zh-CN/us/archive/gfs-sosp2003.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a></td>
</tr>
<tr>
<td>File system</td>
<td><strong>Hadoop File System (HDFS)</strong> - GFS 的开源实现</td>
<td><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html" target="_blank" rel="noopener noreferrer">apache.org</a></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Chubby</strong> - Google 的分布式系统的低耦合锁服务</td>
<td><a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Dapper</strong> - 分布式系统跟踪基础设施</td>
<td><a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36356.pdf" target="_blank" rel="noopener noreferrer">research.google.com</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Kafka</strong> - LinkedIn 的发布订阅消息系统</td>
<td><a href="http://www.slideshare.net/mumrah/kafka-talk-tri-hug" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td>Misc</td>
<td><strong>Zookeeper</strong> - 集中的基础架构和协调服务</td>
<td><a href="http://www.slideshare.net/sauravhaloi/introduction-to-apache-zookeeper" target="_blank" rel="noopener noreferrer">slideshare.net</a></td>
</tr>
<tr>
<td></td>
<td>添加更多</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="公司的系统架构" tabindex="-1"> 公司的系统架构</h3>
<table>
<thead>
<tr>
<th>Company</th>
<th>Reference(s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Amazon</td>
<td><a href="http://highscalability.com/amazon-architecture" target="_blank" rel="noopener noreferrer">Amazon 的架构</a></td>
</tr>
<tr>
<td>Cinchcast</td>
<td><a href="http://highscalability.com/blog/2012/7/16/cinchcast-architecture-producing-1500-hours-of-audio-every-d.html" target="_blank" rel="noopener noreferrer">每天产生 1500 小时的音频</a></td>
</tr>
<tr>
<td>DataSift</td>
<td><a href="http://highscalability.com/blog/2011/11/29/datasift-architecture-realtime-datamining-at-120000-tweets-p.html" target="_blank" rel="noopener noreferrer">每秒实时挖掘 120000 条 tweet</a></td>
</tr>
<tr>
<td>DropBox</td>
<td><a href="https://www.youtube.com/watch?v=PE4gwstWhmc" target="_blank" rel="noopener noreferrer">我们如何缩放 Dropbox</a></td>
</tr>
<tr>
<td>ESPN</td>
<td><a href="http://highscalability.com/blog/2013/11/4/espns-architecture-at-scale-operating-at-100000-duh-nuh-nuhs.html" target="_blank" rel="noopener noreferrer">每秒操作 100000 次</a></td>
</tr>
<tr>
<td>Google</td>
<td><a href="http://highscalability.com/google-architecture" target="_blank" rel="noopener noreferrer">Google 的架构</a></td>
</tr>
<tr>
<td>Instagram</td>
<td><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html" target="_blank" rel="noopener noreferrer">1400 万用户，达到兆级别的照片存储</a><i>Content not supported</i><a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-of-instances" target="_blank" rel="noopener noreferrer">是什么在驱动 Instagram</a></td>
</tr>
<tr>
<td>Justin.tv</td>
<td><a href="http://highscalability.com/blog/2010/3/16/justintvs-live-video-broadcasting-architecture.html" target="_blank" rel="noopener noreferrer">Justin.Tv 的直播广播架构</a></td>
</tr>
<tr>
<td>Facebook</td>
<td><a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/key-value/fb-memcached-nsdi-2013.pdf" target="_blank" rel="noopener noreferrer">Facebook 的可扩展 memcached</a><i>Content not supported</i><a href="https://cs.uwaterloo.ca/~brecht/courses/854-Emerging-2014/readings/data-store/tao-facebook-distributed-datastore-atc-2013.pdf" target="_blank" rel="noopener noreferrer">TAO: Facebook 社交图的分布式数据存储</a><i>Content not supported</i><a href="https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Beaver.pdf" target="_blank" rel="noopener noreferrer">Facebook 的图片存储</a></td>
</tr>
<tr>
<td>Flickr</td>
<td><a href="http://highscalability.com/flickr-architecture" target="_blank" rel="noopener noreferrer">Flickr 的架构</a></td>
</tr>
<tr>
<td>Mailbox</td>
<td><a href="http://highscalability.com/blog/2013/6/18/scaling-mailbox-from-0-to-one-million-users-in-6-weeks-and-1.html" target="_blank" rel="noopener noreferrer">在 6 周内从 0 到 100 万用户</a></td>
</tr>
<tr>
<td>Pinterest</td>
<td><a href="http://highscalability.com/blog/2013/4/15/scaling-pinterest-from-0-to-10s-of-billions-of-page-views-a.html" target="_blank" rel="noopener noreferrer">从零到每月数十亿的浏览量</a><i>Content not supported</i><a href="http://highscalability.com/blog/2012/5/21/pinterest-architecture-update-18-million-visitors-10x-growth.html" target="_blank" rel="noopener noreferrer">1800 万访问用户，10 倍增长，12 名员工</a></td>
</tr>
<tr>
<td>Playfish</td>
<td><a href="http://highscalability.com/blog/2010/9/21/playfishs-social-gaming-architecture-50-million-monthly-user.html" target="_blank" rel="noopener noreferrer">月用户量 5000 万并在不断增长</a></td>
</tr>
<tr>
<td>PlentyOfFish</td>
<td><a href="http://highscalability.com/plentyoffish-architecture" target="_blank" rel="noopener noreferrer">PlentyOfFish 的架构</a></td>
</tr>
<tr>
<td>Salesforce</td>
<td><a href="http://highscalability.com/blog/2013/9/23/salesforce-architecture-how-they-handle-13-billion-transacti.html" target="_blank" rel="noopener noreferrer">他们每天如何处理 13 亿笔交易</a></td>
</tr>
<tr>
<td>Stack Overflow</td>
<td><a href="http://highscalability.com/blog/2009/8/5/stack-overflow-architecture.html" target="_blank" rel="noopener noreferrer">Stack Overflow 的架构</a></td>
</tr>
<tr>
<td>TripAdvisor</td>
<td><a href="http://highscalability.com/blog/2011/6/27/tripadvisor-architecture-40m-visitors-200m-dynamic-page-view.html" target="_blank" rel="noopener noreferrer">40M 访问者，200M 页面浏览量，30TB 数据</a></td>
</tr>
<tr>
<td>Tumblr</td>
<td><a href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html" target="_blank" rel="noopener noreferrer">每月 150 亿的浏览量</a></td>
</tr>
<tr>
<td>Twitter</td>
<td><a href="http://highscalability.com/scaling-twitter-making-twitter-10000-percent-faster" target="_blank" rel="noopener noreferrer">Making Twitter 10000 percent faster</a><i>Content not supported</i><a href="http://highscalability.com/blog/2011/12/19/how-twitter-stores-250-million-tweets-a-day-using-mysql.html" target="_blank" rel="noopener noreferrer">每天使用 MySQL 存储 2.5 亿条 tweet</a><i>Content not supported</i><a href="http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html" target="_blank" rel="noopener noreferrer">150M 活跃用户，300K QPS，22 MB/S 的防火墙</a><i>Content not supported</i><a href="https://www.infoq.com/presentations/Twitter-Timeline-Scalability" target="_blank" rel="noopener noreferrer">可扩展时间表</a><i>Content not supported</i><a href="https://www.youtube.com/watch?v=5cKTP36HVgI" target="_blank" rel="noopener noreferrer">Twitter 的大小数据</a><i>Content not supported</i><a href="https://www.youtube.com/watch?v=z8LU0Cj6BOU" target="_blank" rel="noopener noreferrer">Twitter 的行为：规模超过 1 亿用户</a></td>
</tr>
<tr>
<td>Uber</td>
<td><a href="http://highscalability.com/blog/2015/9/14/how-uber-scales-their-real-time-market-platform.html" target="_blank" rel="noopener noreferrer">Uber 如何扩展自己的实时化市场</a></td>
</tr>
<tr>
<td>WhatsApp</td>
<td><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html" target="_blank" rel="noopener noreferrer">Facebook 用 190 亿美元购买 WhatsApp 的架构</a></td>
</tr>
<tr>
<td>YouTube</td>
<td><a href="https://www.youtube.com/watch?v=w5WVu624fY8" target="_blank" rel="noopener noreferrer">YouTube 的可扩展性</a><i>Content not supported</i><a href="http://highscalability.com/youtube-architecture" target="_blank" rel="noopener noreferrer">YouTube 的架构</a></td>
</tr>
</tbody>
</table>
<h3 id="公司工程博客" tabindex="-1"> 公司工程博客</h3>
<blockquote>
<p>你即将面试的公司的架构</p>
<p>你面对的问题可能就来自于同样领域</p>
</blockquote>
<ul>
<li><a href="http://nerds.airbnb.com/" target="_blank" rel="noopener noreferrer">Airbnb Engineering</a></li>
<li><a href="https://developer.atlassian.com/blog/" target="_blank" rel="noopener noreferrer">Atlassian Developers</a></li>
<li><a href="http://cloudengineering.autodesk.com/blog/" target="_blank" rel="noopener noreferrer">Autodesk Engineering</a></li>
<li><a href="https://aws.amazon.com/blogs/aws/" target="_blank" rel="noopener noreferrer">AWS Blog</a></li>
<li><a href="http://word.bitly.com/" target="_blank" rel="noopener noreferrer">Bitly Engineering Blog</a></li>
<li><a href="https://www.box.com/blog/engineering/" target="_blank" rel="noopener noreferrer">Box Blogs</a></li>
<li><a href="http://blog.cloudera.com/blog/" target="_blank" rel="noopener noreferrer">Cloudera Developer Blog</a></li>
<li><a href="https://tech.dropbox.com/" target="_blank" rel="noopener noreferrer">Dropbox Tech Blog</a></li>
<li><a href="http://engineering.quora.com/" target="_blank" rel="noopener noreferrer">Engineering at Quora</a></li>
<li><a href="http://www.ebaytechblog.com/" target="_blank" rel="noopener noreferrer">Ebay Tech Blog</a></li>
<li><a href="https://blog.evernote.com/tech/" target="_blank" rel="noopener noreferrer">Evernote Tech Blog</a></li>
<li><a href="http://codeascraft.com/" target="_blank" rel="noopener noreferrer">Etsy Code as Craft</a></li>
<li><a href="https://www.facebook.com/Engineering" target="_blank" rel="noopener noreferrer">Facebook Engineering</a></li>
<li><a href="http://code.flickr.net/" target="_blank" rel="noopener noreferrer">Flickr Code</a></li>
<li><a href="http://engineering.foursquare.com/" target="_blank" rel="noopener noreferrer">Foursquare Engineering Blog</a></li>
<li><a href="https://github.blog/category/engineering" target="_blank" rel="noopener noreferrer">GitHub Engineering Blog</a></li>
<li><a href="http://googleresearch.blogspot.com/" target="_blank" rel="noopener noreferrer">Google Research Blog</a></li>
<li><a href="https://engineering.groupon.com/" target="_blank" rel="noopener noreferrer">Groupon Engineering Blog</a></li>
<li><a href="https://engineering.heroku.com/" target="_blank" rel="noopener noreferrer">Heroku Engineering Blog</a></li>
<li><a href="http://product.hubspot.com/blog/topic/engineering" target="_blank" rel="noopener noreferrer">Hubspot Engineering Blog</a></li>
<li><a href="http://highscalability.com/" target="_blank" rel="noopener noreferrer">High Scalability</a></li>
<li><a href="http://instagram-engineering.tumblr.com/" target="_blank" rel="noopener noreferrer">Instagram Engineering</a></li>
<li><a href="https://software.intel.com/en-us/blogs/" target="_blank" rel="noopener noreferrer">Intel Software Blog</a></li>
<li><a href="https://blogs.janestreet.com/category/ocaml/" target="_blank" rel="noopener noreferrer">Jane Street Tech Blog</a></li>
<li><a href="http://engineering.linkedin.com/blog" target="_blank" rel="noopener noreferrer">LinkedIn Engineering</a></li>
<li><a href="https://engineering.microsoft.com/" target="_blank" rel="noopener noreferrer">Microsoft Engineering</a></li>
<li><a href="https://blogs.msdn.microsoft.com/pythonengineering/" target="_blank" rel="noopener noreferrer">Microsoft Python Engineering</a></li>
<li><a href="http://techblog.netflix.com/" target="_blank" rel="noopener noreferrer">Netflix Tech Blog</a></li>
<li><a href="https://devblog.paypal.com/category/engineering/" target="_blank" rel="noopener noreferrer">Paypal Developer Blog</a></li>
<li><a href="http://engineering.pinterest.com/" target="_blank" rel="noopener noreferrer">Pinterest Engineering Blog</a></li>
<li><a href="https://engineering.quora.com/" target="_blank" rel="noopener noreferrer">Quora Engineering</a></li>
<li><a href="http://www.redditblog.com/" target="_blank" rel="noopener noreferrer">Reddit Blog</a></li>
<li><a href="https://developer.salesforce.com/blogs/engineering/" target="_blank" rel="noopener noreferrer">Salesforce Engineering Blog</a></li>
<li><a href="https://slack.engineering/" target="_blank" rel="noopener noreferrer">Slack Engineering Blog</a></li>
<li><a href="https://labs.spotify.com/" target="_blank" rel="noopener noreferrer">Spotify Labs</a></li>
<li><a href="http://www.twilio.com/engineering" target="_blank" rel="noopener noreferrer">Twilio Engineering Blog</a></li>
<li><a href="https://engineering.twitter.com/" target="_blank" rel="noopener noreferrer">Twitter Engineering</a></li>
<li><a href="http://eng.uber.com/" target="_blank" rel="noopener noreferrer">Uber Engineering Blog</a></li>
<li><a href="http://yahooeng.tumblr.com/" target="_blank" rel="noopener noreferrer">Yahoo Engineering Blog</a></li>
<li><a href="http://engineeringblog.yelp.com/" target="_blank" rel="noopener noreferrer">Yelp Engineering Blog</a></li>
<li><a href="https://www.zynga.com/blogs/engineering" target="_blank" rel="noopener noreferrer">Zynga Engineering Blog</a></li>
</ul>
<h4 id="来源及延伸阅读-15" tabindex="-1"> 来源及延伸阅读</h4>
<ul>
<li><a href="https://github.com/kilimchoi/engineering-blogs" target="_blank" rel="noopener noreferrer">kilimchoi/engineering-blogs</a></li>
</ul>
<h2 id="正在完善中" tabindex="-1"> 正在完善中</h2>
<p>有兴趣加入添加一些部分或者帮助完善某些部分吗？！</p>
<ul>
<li>使用 MapReduce 进行分布式计算</li>
<li>一致性哈希</li>
<li>直接存储器访问（DMA）控制器</li>
<li></li>
</ul>
<h2 id="致谢" tabindex="-1"> 致谢</h2>
<p>整个仓库都提供了证书和源</p>
<p>特别鸣谢：</p>
<ul>
<li><a href="http://www.hiredintech.com/system-design/the-system-design-process/" target="_blank" rel="noopener noreferrer">Hired in tech</a></li>
<li><a href="https://www.amazon.com/dp/0984782850/" target="_blank" rel="noopener noreferrer">Cracking the coding interview</a></li>
<li><a href="http://highscalability.com/" target="_blank" rel="noopener noreferrer">High scalability</a></li>
<li><a href="https://github.com/checkcheckzz/system-design-interview" target="_blank" rel="noopener noreferrer">checkcheckzz/system-design-interview</a></li>
<li><a href="https://github.com/shashank88/system_design" target="_blank" rel="noopener noreferrer">shashank88/system_design</a></li>
<li><a href="https://github.com/mmcgrana/services-engineering" target="_blank" rel="noopener noreferrer">mmcgrana/services-engineering</a></li>
<li><a href="https://gist.github.com/vasanthk/485d1c25737e8e72759f" target="_blank" rel="noopener noreferrer">System design cheat sheet</a></li>
<li><a href="http://dancres.github.io/Pages/" target="_blank" rel="noopener noreferrer">A distributed systems reading list</a></li>
<li><a href="http://www.puncsky.com/blog/2016-02-13-crack-the-system-design-interview" target="_blank" rel="noopener noreferrer">Cracking the system design interview</a></li>
</ul>
<h2 id="联系方式" tabindex="-1"> 联系方式</h2>
<p>欢迎联系我讨论本文的不足、问题或者意见。</p>
<p>可以在我的 <a href="https://github.com/donnemartin" target="_blank" rel="noopener noreferrer">GitHub 主页</a>上找到我的联系方式</p>
<h2 id="许可" tabindex="-1"> 许可</h2>
<pre><code>Creative Commons Attribution 4.0 International License (CC BY 4.0)

http://creativecommons.org/licenses/by/4.0/
</code></pre>
]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/bQjZIt.png" type="image/png"/>
    </item>
    <item>
      <title>游戏笔记</title>
      <link>https://timpcfan.site/life/game/</link>
      <guid>https://timpcfan.site/life/game/</guid>
      <source url="https://timpcfan.site/rss.xml">游戏笔记</source>
      <category>笔记</category>
      <pubDate>Sun, 02 Oct 2022 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<h3 id="玩游戏" tabindex="-1"> 玩游戏</h3>
<ul>
<li><a href="/life/game/mahjong.html">日麻笔记</a></li>
<li><a href="/life/game/genshin.html">原神</a></li>
<li><a href="/life/game/tetris.html">Tetris</a></li>
<li>Minecraft</li>
<li>东方project</li>
</ul>
<h3 id="做游戏" tabindex="-1"> 做游戏</h3>
<ul>
<li><a href="/life/game/design.html">游戏设计</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>