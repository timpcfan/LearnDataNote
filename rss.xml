<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://timpcfan.site/rss.xml" rel="self" type="application/rss+xml"/>
    <title>TrystanLei</title>
    <link>https://timpcfan.site/</link>
    <description>积累点滴，汇聚成溪。</description>
    <language>zh-CN</language>
    <pubDate>Wed, 05 Oct 2022 10:27:35 GMT</pubDate>
    <lastBuildDate>Wed, 05 Oct 2022 10:27:35 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>笔记</category>
    <category>前端</category>
    <category>API</category>
    <item>
      <title>CSS 笔记</title>
      <link>https://timpcfan.site/code/frontend/css.html</link>
      <guid>https://timpcfan.site/code/frontend/css.html</guid>
      <source url="https://timpcfan.site/rss.xml">CSS 笔记</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Tue, 04 Oct 2022 01:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>相关信息</p>
<p>整理了一些学习 CSS 时的笔记。</p>
</div>
<h2 id="css-布局之-position-篇" tabindex="-1"> CSS 布局之 position 篇 <sup></sup></h2>
<div><p>提示</p>
<p><code>position</code> 属性用来描述 HTML 元素如何在文档流中定位。</p>
</div>
<h3 id="position-属性" tabindex="-1"> position 属性</h3>
<p>position 属性的值有：</p>
<ul>
<li>static：（默认值）根据正常文档流放置。</li>
<li>relative：基于正常文档流的位置使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
<li>absolute：将元素<strong>移出文档流</strong>，在<a href="/code/frontend/css_containing_block.html"><mark>包含块</mark></a>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>fixed：将元素<strong>移出文档流</strong>，在<strong>整个视图区域</strong>内使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行放置。</li>
<li>sticky：基于正常文档流的位置放置，并且在滚动屏幕时能粘在画面内，使用 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性进行偏移。</li>
</ul>
<div><p>巨大的坑</p>
<p>注意：<strong>包含块</strong>不一定就是直接的父容器！详情请查阅<a href="/code/frontend/css_containing_block.html">文档</a>。</p>
</div>
<h3 id="指定位置" tabindex="-1"> 指定位置</h3>
<p><code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 属性用于指定元素的最终位置。</p>
<div><p>这里拿 absolute 模式来举例。</p>
</div>
<ul>
<li>top: 元素上边界距离包含块的相对距离。</li>
<li>right: 元素右边界距离包含块的相对距离。</li>
<li>bottom: 元素下边界距离包含块的相对距离。</li>
<li>left: 元素左边界距离包含块的相对距离。</li>
</ul>
<iframe height="370px" width="100%" src="https://interactive-examples.mdn.mozilla.net/pages/css/position.html" title="MDN Web Docs Interactive Example" loading="lazy"></iframe>
<h2 id="css-布局之-flexbox-篇-基础" tabindex="-1"> CSS 布局之 Flexbox 篇（基础） <sup></sup></h2>
<h3 id="介绍" tabindex="-1"> 介绍</h3>
<p>Flexbox 是Flexible Box Module. 一种布局模型，可以轻松控制 html 元素 之间的空间分布和对齐方式。</p>
<p>Flexbox 控制一次仅在一维（行或列）中的定位。对于二维控件，CSS Grid Layout 应运而生。</p>
<p>给定以下模板：</p>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-1<span>"</span></span><span>></span></span>1<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-2<span>"</span></span><span>></span></span>2<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-3<span>"</span></span><span>></span></span>3<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-4<span>"</span></span><span>></span></span>4<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-5<span>"</span></span><span>></span></span>5<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-6<span>"</span></span><span>></span></span>6<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-7<span>"</span></span><span>></span></span>7<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-8<span>"</span></span><span>></span></span>8<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-9<span>"</span></span><span>></span></span>9<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box box-10<span>"</span></span><span>></span></span>10<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上述 div 的默认行为，尊重正常的 html 文档流，是从上到下、从左到右呈现并占据整个正文宽度，因为它的display属性默认为block.</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/4USqRq.jpg" alt="4USqRq" height="300" loading="lazy"></p>
<h3 id="弹性item" tabindex="-1"> 弹性item</h3>
<p>当<code>display: flex</code>应用于<code>.container div</code> 时，所有直接子 <code>div</code> 变为<code>flex-items</code>，并获得新的行为：</p>
<ul>
<li>它们将显示在一行中，因为 <code>flex-direction</code> 默认为 <code>row</code></li>
<li>它们将从左到右显示</li>
<li>项目<strong>不会拉伸</strong>以适应整个宽度（主轴），但它们会收缩以做到这一点。
<img src="http://timpcfan-site.cdn.bcebos.com/imgs/AsUQoe.gif" alt="AsUQoe" loading="lazy"></li>
<li>项目<strong>拉伸</strong>以适应交叉轴（本例中的高度）。</li>
<li>如果物品有不同的高度，它们将伸展到最高的一个高度</li>
<li>flex-basis默认为auto（项目宽度将由其内容设置）</li>
<li>flex-wrap默认为nowrap（如果容器的宽度不足以容纳物品，它们不会包装，而是会溢出）</li>
</ul>
<div><p>提示</p>
<p>在主轴上收缩（收缩成自身宽度），在交叉轴上拉伸（拉伸成最高那个）。</p>
</div>
<h3 id="弹性容器" tabindex="-1"> 弹性容器</h3>
<ul>
<li>display: flex使容器扩展可用的整个宽度。与flex相反display: inline-flex，它使容器折叠到内容的宽度。</li>
</ul>
<h3 id="flex-direction" tabindex="-1"> flex-direction</h3>
<p>一旦声明为 flex 容器，该元素就可以被认为是两个轴。主轴，由flex-direction属性定义。和交叉轴，它垂直于第一个。</p>
<p>该属性有四个值flex-direction：<code>row</code>、 <code>column</code>、<code>row-reverse</code>、 <code>columncolumn-reverse</code></p>
<p>默认值为row，它设置主轴水平，从左到右，横轴垂直截取它，从上到下。类似地，该column值设置垂直轴，从上到下，交叉轴从左到右。两个选项的reverse属性都将主轴反转 180°。交叉轴保持不变。</p>
<p>这些值的弹性项目行为可以在下面观察到：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oibRlg.gif" alt="oibRlg" loading="lazy"></p>
<h3 id="flex-wrap" tabindex="-1"> flex-wrap</h3>
<p>flex-wrap是当容器中的空间不足以容纳所有弹性项目时处理弹性项目的属性。</p>
<p>默认情况下flex-wrap设置为nowrap，这意味着如果容器不能以原始宽度容纳一行中的项目，它们将缩小以适应。如果由于某种原因它们无法收缩，那么它们会溢出容器。</p>
<p>通过为项目设置 300px 宽度，该nowrap选项会输出以下结果：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yuHKj4.png" alt="yuHKj4" height="300" loading="lazy"></p>
<p>其中，每个项目都缩小到大约 70px 以适应容器。</p>
<p>当属性更新为 时wrap，项目的宽度现在实际上将具有其原始值 300 像素。当第一行的宽度不足以容纳 300 像素时，该项目不会溢出容器，而是换行到新行。每一行都应该被认为是一个单独的弹性容器。一个容器中的空间分布不会影响相邻的其他容器。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HqmnPV.png" alt="HqmnPV" height="300" loading="lazy"></p>
<p>另一种选择是wrap-reverse，它反转交叉轴。flex-direction由属性从上到下设置，wrap-reverse将其转换为从下到上。</p>
<h3 id="弹性流" tabindex="-1"> 弹性流</h3>
<p><code>flex-direction</code>并且<code>flex-wrap</code>可以在单个属性中声明：<code>flex-flow: [direction] [wrap]</code></p>
<h3 id="对齐" tabindex="-1"> 对齐</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/invnoF.png" alt="" loading="lazy"></p>
<p>在 Flexbox 中，项目沿轴的对齐和空间分布可以通过四个属性来控制 ：</p>
<ul>
<li>justify-content：对齐主轴上的所有项目</li>
<li>align-items：对齐交叉轴上的所有项目</li>
<li>align-self：在交叉轴上对齐单个项目</li>
<li>align-content: 控制交叉轴上弯曲线之间的空间</li>
</ul>
<h3 id="弹性盒尺寸" tabindex="-1"> 弹性盒尺寸</h3>
<p>项目的大小和灵活性可以通过三个属性来控制flex-grow、flex-shrink和flex-basis。这三个都作用于主轴。</p>
<ul>
<li>flex-grow: 如果有多余的空间，每个项目应该如何放大</li>
<li>flex-shrink: 如果没有足够的空间，每个项目应该如何减少</li>
<li>flex-basis: 在设置上面两个属性之前，项目应该是什么大小</li>
</ul>
<h4 id="flex-grow-弹性成长" tabindex="-1"> flex-grow 弹性成长</h4>
<p>此属性的flex grow factor设置是处理项目大小相对于彼此的比率。</p>
<p>默认值为 0，表示如果有可用空间，则将其放在最后一项之后。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/55rRLZ.png" alt="" loading="lazy"></p>
<p>在上面的示例中，direction设置为row，并且每个弹性项目width都设置为60px。由于容器很980px宽，因此有680px可用空间。该空间称为positive free space。</p>
<p>通过设置flex-grow为1，正的可用空间量在弹性项目之间平均分配。每个项目的宽度将增加136px，总计196px。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5trUDz.png" alt="" loading="lazy"></p>
<p>通过<code>flex-grow: 2</code>应用于第三个项目，它获得的可用正可用空间量是<code>286px</code>其余项目的两倍，<code>173px</code>。</p>
<p>下图显示了<code>flex-grow</code>属性设置为其内容值的项目。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1ftKa2.png" alt="" loading="lazy"></p>
<h4 id="flex-shrink-弹性收缩" tabindex="-1"> flex-shrink 弹性收缩</h4>
<p>flex-shrink处理项目大小，当没有足够的可用空间将它们全部放入容器中时。因此，它negative free space通过缩小项目来划分项目。</p>
<p>下一张图片显示了980px装有五个300px宽物品的容器。由于没有空间容纳1500px所需，默认flex shrink factor值1使每个项目均匀收缩到196px。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Y3Pm8q.png" alt="" loading="lazy"></p>
<p>通过<code>flex-shrink: 2</code>为第三项设置比率，它会比其他项小两倍。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Wcu0xX.png" alt="" loading="lazy"></p>
<p>本节中的最后一张图片显示了将其内容值保存为 flex 收缩率的每个项目。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/uAEXro.png" alt="" loading="lazy"></p>
<h4 id="flex-basis-弹性基础" tabindex="-1"> flex-basis 弹性基础</h4>
<p>flex-basis是在实际设置可用空间之前检查每个项目应具有的大小的属性。默认值为auto，并且项目宽度由width属性显式设置，或者采用内容宽度。它还接受像素值。</p>
<p>下面的 gif 显示了一个800px宽容器和五个设置为flex-basis: 160px. 这告诉浏览器：理想情况下，有足够的空间来放置所有项目，尊重它们的160px宽度，并且没有正/负的可用空间。如果没有足够的空间，由于flex-shrink默认为1，所有项目都被均匀收缩。如果有多余的空间，则flex-grow默认为0，并且空白空间位于最后一项之后。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SKURrp.png" alt="" loading="lazy"></p>
<p>下一个 gif 显示项目 1 设置为<code>flex-shrink: 10</code>，项目 4 设置为<code>flex-grow: 10</code>。对于负的可用空间，项目 1 的宽度减少了 10 倍。对于正的可用空间，项目 4 的宽度是其他项目的 10 倍。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/B184OW.png" alt="" loading="lazy"></p>
<p><code>flex-basis</code>也接受 value <code>content</code>，无论<code>width</code>是否设置，计算可用空间的宽度都是项目的内容。如果您不想考虑该计算的项目宽度，请将基础设置为<code>0</code>。</p>
<h4 id="flex-弹性" tabindex="-1"> flex 弹性</h4>
<p>flex 是 <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code> 的简写.</p>
<p>它接受以下预定义值：</p>
<ul>
<li><code>initial</code>: 重置为 flexbox 默认值，与 <code>flex: 0 1 auto</code> 相同</li>
<li><code>auto</code>: flex-items 可以根据需要增长/缩小，与 <code>flex: 1 1 auto</code> 相同</li>
<li><code>none</code>: 使项目不灵活，与 <code>flex: 0 0 auto</code> 相同</li>
<li><code>flex: 1</code>: flex-items 具有增长/收缩的能力并且flex-basis设置为零，与 <code>flex: 1 1 0</code> 相同</li>
</ul>
<h2 id="css-布局之-flexbox-篇-扩展" tabindex="-1"> CSS 布局之 Flexbox 篇（扩展） <sup></sup></h2>
<h3 id="几个例子" tabindex="-1"> 几个例子</h3>
<h4 id="例子-居中对齐" tabindex="-1"> 例子：居中对齐</h4>
<div><pre><code><span>.CenterMe</span> <span>{</span>
	<span>background-color</span><span>:</span> indigo<span>;</span>
	<span>color</span><span>:</span> #ebebeb<span>;</span>
	<span>font-size</span><span>:</span> 2rem<span>;</span>
	<span>height</span><span>:</span> 200px<span>;</span>
	<span>display</span><span>:</span> flex<span>;</span>
	<span>align-items</span><span>:</span> center<span>;</span> <span>/* 沿着交叉轴对齐 */</span>
	<span>justify-content</span><span>:</span> center<span>;</span> <span>/* 沿着主轴对齐 */</span>
<span>}</span>

&lt;div class=<span>"CenterMe"</span>>Hello<span>,</span> I'm centered with Flexbox!&lt;/div>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/K3PDPP.png" alt="K3PDPP" loading="lazy"></p>
<h4 id="例子-偏移" tabindex="-1"> 例子：偏移</h4>
<div><pre><code><span>.LastItem,
.ListItem</span> <span>{</span>
  <span>color</span><span>:</span> #ebebeb<span>;</span>
  <span>text-decoration</span><span>:</span> none<span>;</span>
<span>}</span>

<span>.ListItem</span> <span>{</span>
  <span>margin-right</span><span>:</span> 1rem<span>;</span>
<span>}</span>

<span>.LastItem</span> <span>{</span>
  <span>margin-left</span><span>:</span> auto<span>;</span> <span>/* 用上该侧所有可用的外边距 */</span>
<span>}</span>

&lt;div class=<span>"MenuWrap"</span>>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Home&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>About Us&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Products&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"ListItem"</span>>Policy&lt;/a>
  &lt;a href=<span>"#"</span> class=<span>"LastItem"</span>>Contact Us&lt;/a>
&lt;/div>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/9jnlas.png" alt="9jnlas" loading="lazy"></p>
<h4 id="例子-反序" tabindex="-1"> 例子：反序</h4>
<p>让所有项反序排列</p>
<div><pre><code><span>flex-direction</span><span>:</span> row-reverse
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>相关信息</p>
<p>此外还有 column-reverse  为垂直反序。</p>
</div>
<h3 id="flexbox的对齐" tabindex="-1"> flexbox的对齐</h3>
<p>关于Flexbox的对齐，最重要的是理解坐标轴。有两个轴，“主轴”和“交叉轴”。这两个轴代表什么取决于Flexbox排列的方向。比如，如果将Flexbox的方向设置为<code>row</code>，则主轴就是横轴， 而交叉轴就是纵轴。</p>
<p>反之，如果Flexbox的方向是<code>column</code>，则主轴就是纵轴，而交叉轴为横轴。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OioNsa.png" alt="OioNsa" loading="lazy"></p>
<h4 id="沿着交叉轴对齐" tabindex="-1"> 沿着交叉轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>align-items：设置容器内所有item沿交叉轴对齐的方式（对容器内元素）</li>
<li>align-self：针对内部元素，设置特定的沿交叉轴对齐的方式（对自己）</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start: 把元素的对齐设置为flex-start，可以让元素从Flexbox父元素的起始边 开始。</li>
<li>flex-end: 把元素的对齐设置为flex-end，会沿Flexbox父元素的末尾对齐该元素。</li>
<li>center: 把元素放在Flexbox元素的中间。</li>
<li>baseline: 让Flexbox元素中的所有项沿基线对齐。</li>
<li>stretch: 让Flexbox中的所有项(没交叉轴)拉伸至与父元素一样大</li>
</ul>
<h4 id="沿着主轴对齐" tabindex="-1"> 沿着主轴对齐</h4>
<p>设置的属性：</p>
<ul>
<li>justify-content：设置容器内所有item沿主轴的对齐方式</li>
</ul>
<p>对齐的方式：</p>
<ul>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>space-between：设置如何处理空白，将空白分配到元素之间</li>
<li>space-around：设置如何处理空白，将空白分配到元素两边</li>
</ul>
<div><pre><code>&lt;div class=<span>"FlexWrapper"</span>>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 1.&lt;/div>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 2.&lt;/div>
	&lt;div class=<span>"FlexInner"</span>>I am content in the inner Flexbox 3.&lt;/div>
&lt;/div>
<span>/* 再看以下CSS。我们把每个内部元素(FlexInner)的宽度都设置为25%，包含它们的容器
Flexbox(FlexWrapper)的宽度为100% */</span>
<span>.FlexWrapper</span> <span>{</span>
	<span>background-color</span><span>:</span> indigo<span>;</span>
	<span>display</span><span>:</span> flex<span>;</span>
	<span>justify-content</span><span>:</span> space-between<span>;</span>
	<span>height</span><span>:</span> 200px<span>;</span>
	<span>width</span><span>:</span> 100%<span>;</span>
<span>}</span>
<span>.FlexInner</span> <span>{</span>
  <span>background-color</span><span>:</span> #34005B<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
  <span>width</span><span>:</span> 25%<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/Iqs9fg.png" alt="Iqs9fg" loading="lazy"></p>
<h3 id="flex属性" tabindex="-1"> flex属性</h3>
<p>前面已经给伸缩项(flex-item)定义过宽度了。除了width，还可以通过flex属性来定义宽 度，或者叫“伸缩性”(flexiness)。再看另一个例子，同样的标记，但CSS有所不同:</p>
<div><pre><code><span>.FlexInner</span> <span>{</span>
  <span>border</span><span>:</span> 1px solid #ebebeb<span>;</span>
  <span>background-color</span><span>:</span> #34005B<span>;</span>
  <span>display</span><span>:</span> flex<span>;</span>
  <span>height</span><span>:</span> 100px<span>;</span>
	<span>flex</span><span>:</span> 1<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的flex实际上是三个属性合体的简写:flex-grow、flex-shrink和flex-basis。 关于这三个属性的详细介绍，可以参考规范<a href="https://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener noreferrer">原文</a>。不过， 规范还是建议大家使用flex这个简写属性，也就是我们这里用的这个，明白吗?</p>
<div><pre><code><span>flex</span><span>:</span> 1       1     100px
      伸展    收缩    基准
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>对于伸缩项，如果flex属性存在(且浏览器支持)，<strong>则使用它的值控制元素的大小，忽略宽度和高度值的设置</strong>，即使它们的声明位于flex声明之后，也会被忽略。下面分别看看这三个 属性。</p>
<ul>
<li>flex-grow(传给flex的第一个值)是相对于其他伸缩项，当前伸缩项在空间允许的情况下可以伸展的量。</li>
<li>flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量。</li>
<li>flex-basis(传给flex的最后一个值)是伸缩项伸缩的基准值。</li>
</ul>
<p>虽然只写<code>flex: 1</code>也没问题，但还是建议大家把三个值写全。这样才能更清楚地表明你想干什么。比如<code>flex: 1 2 auto</code>的意思是在有空间的情况下可以伸展1部分，在空间不足时可以收缩1部分，而<strong>基准大小是内容的固有宽度</strong>(即不伸缩的情况下内容的大小)。
再试一个:<code>flex: 0 0 50px</code>的意思是，这个伸缩项既不伸也不缩，基准为50像素(即无论是否存在自由空间，都是50像素)。那么<code>flex: 2 0 50%</code>呢?意思就是会多占用两个可用空间， 不收缩，基准为50%。但愿这几个例子能帮大家理解flex属性。</p>
<div><p>提示</p>
<p>将flex-shrink的值设置为0，flex-basis实际上就相当于最小宽度。</p>
</div>
<h2 id="css-布局之-grid-篇" tabindex="-1"> CSS 布局之 Grid 篇 <sup></sup></h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/GwfRmw.png" alt="" loading="lazy"></p>
<p>一个网格通常具有许多的<strong>列（column）<strong>与</strong>行（row）</strong>，以及行与行、列与列之间的间隙，这个间隙一般被称为<strong>沟槽（gutter）</strong>。</p>
<h3 id="定义网格" tabindex="-1"> 定义网格</h3>
<p>在一个父容器中使用：<code>display: grid;</code> ，将这个容器改为网格布局。</p>
<ul>
<li>初始状态：只有一列的网格，你的子项还是会像正常布局流那样从上往下排布。</li>
</ul>
<div><pre><code><span>.container</span> <span>{</span>
    <span>display</span><span>:</span> grid<span>;</span>
    <span>grid-template-columns</span><span>:</span> 200px 200px 200px<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>使用 <code>grid-template-columns</code> 来定义多个列，每个参数代表一个列的宽度。可以使用 <code>fr</code> 这个单位来灵活定义网格的行与列的大小。这个单位表示了<strong>可用空间</strong>的一个比例。</p>
<div><pre><code><span>grid-template-columns</span><span>:</span> 1fr 1fr 1fr<span>;</span>          <span>/* 三个列，每个列宽度相等 */</span>
<span>grid-template-columns</span><span>:</span> 400px 1fr 1fr<span>;</span>        <span>/* 三个列，后面两个列的宽度为：(总宽度-400px)/2 */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 1fr<span>)</span><span>;</span>       <span>/* 三个列，可以使用repeat函数来重复定义 */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>2<span>,</span> 1fr<span>,</span> 2fr<span>)</span><span>;</span>  <span>/* 1fr 2fr 1fr 2fr */</span>
<span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>auto-fill<span>,</span> <span>minmax</span><span>(</span>200px<span>,</span> 1fr<span>)</span><span>)</span><span>;</span> <span>/* auto-fill 表示填满屏幕，minmax限制大小 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>同样的，使用 <code>grid-template-rows</code> 可以定义多个行 ，每个参数代表一个行的高度。</p>
</div>
<h4 id="网格间隙" tabindex="-1"> 网格间隙</h4>
<div><pre><code><span>gap</span><span>:</span> 20px<span>;</span>  <span>/* 标准 */</span>
<span>grid-gap</span><span>:</span> 20px<span>;</span>  <span>/* 旧 */</span>
<span>grid-row-gap</span><span>:</span> 20px<span>;</span>  <span>/* 行间距 */</span>
<span>grid-column-gap</span><span>:</span> 20px<span>;</span>  <span>/* 列间距 */</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h4 id="显式网格与隐式网格" tabindex="-1"> 显式网格与隐式网格</h4>
<p>使用 <code>grid-template-columns</code> 与 <code>grid-template-rows</code> 定义的网络称为显式网格，而多余的内容则会继续往下填充到新的行的格子内，这些格子被称为隐式网格。</p>
<p>隐式网格的默认行/列大小是参数<code>auto</code> ，大小会根据放入的内容自动调整。也可以使用 <code>[grid-auto-rows](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-rows)</code>和<code>[grid-auto-columns](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-auto-columns)</code>属性手动设定隐式网格的大小。</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-columns</span><span>:</span> <span>repeat</span><span>(</span>3<span>,</span> 1fr<span>)</span><span>;</span>
  <span>grid-auto-rows</span><span>:</span> 100px<span>;</span>
  <span>grid-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="元素放置" tabindex="-1"> 元素放置</h3>
<h4 id="基于线的元素放置" tabindex="-1"> 基于线的元素放置</h4>
<p>定义完网格之后，每行每列的边界（网格线的边缘）都有一个索引，可以使用这些线来定位放置元素。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHBtux.png" alt="" loading="lazy"></p>
<div><pre><code><span>grid-column-start</span><span>:</span> 1  <span>/* 列的开始边界 */</span>
<span>grid-column-end</span><span>:</span> 3  <span>/* 列的结束边界，因此 1 / 3 表示 1、2列 */</span>
<span>grid-row-start</span><span>:</span> 2
<span>grid-row-end</span><span>:</span> 3
<span>/* 或者 */</span>
<span>grid-column</span><span>:</span> 1 / 3
<span>grid-row</span><span>:</span> 2
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>可以使用负数来进行倒数，但对于隐式网格来说 -1 不一定代表最后一条分界线。</p>
</div>
<h4 id="使用-grid-template-areas-属性放置元素" tabindex="-1"> 使用 grid-template-areas 属性放置元素</h4>
<p>另一种往网格放元素的方式是用<code>[grid-template-areas](https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid-template-areas)</code>属性，并且你要命名一些元素并在属性中使用这些名字作为一个区域。</p>
<p>将之前基于线的元素放置代码删除（或者重新下载一份新的文件），然后加入以下 CSS 规则：</p>
<div><pre><code><span>.container</span> <span>{</span>
  <span>display</span><span>:</span> grid<span>;</span>
  <span>grid-template-areas</span><span>:</span>
      <span>"header header"</span>
      <span>"sidebar content"</span>
      <span>"footer footer"</span><span>;</span>
  <span>grid-template-columns</span><span>:</span> 1fr 3fr<span>;</span>
  <span>grid-gap</span><span>:</span> 20px<span>;</span>
<span>}</span>

<span>header</span> <span>{</span>
  <span>grid-area</span><span>:</span> header<span>;</span>
<span>}</span>

<span>article</span> <span>{</span>
  <span>grid-area</span><span>:</span> content<span>;</span>
<span>}</span>

<span>aside</span> <span>{</span>
  <span>grid-area</span><span>:</span> sidebar<span>;</span>
<span>}</span>

<span>footer</span> <span>{</span>
  <span>grid-area</span><span>:</span> footer<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>grid-template-areas</code>属性的使用规则如下：</p>
<ul>
<li>你需要填满网格的每个格子</li>
<li>对于某个横跨多个格子的元素，重复写上那个元素<code>grid-area</code>属性定义的区域名字</li>
<li>所有名字只能出现在一个连续的区域，不能在不同的位置出现</li>
<li>一个连续的区域必须是一个矩形</li>
<li>使用<code>.</code>符号，让一个格子留空</li>
</ul>
<p>你可以在文件中尽情发挥你的想象来测试各种网格排版，比如把页脚放在内容之下，或者把侧边栏一直延伸到最底。这种直观的元素放置方式很棒，你在 CSS 中看到的就是实际会出现的排版效果。</p>
<h2 id="css-选择器" tabindex="-1"> CSS 选择器</h2>
<table>
<thead>
<tr>
<th>选择器</th>
<th>示例</th>
<th>示例说明</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>.class</td>
<td>.intro</td>
<td>选择所有class=&quot;intro&quot;的元素</td>
<td>1</td>
</tr>
<tr>
<td>#id</td>
<td>#firstname</td>
<td>选择所有id=&quot;firstname&quot;的元素</td>
<td>1</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>选择所有元素</td>
<td>2</td>
</tr>
<tr>
<td>element</td>
<td>p</td>
<td>选择所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element,element</td>
<td>div,p</td>
<td>选择所有<code>&lt;div&gt;</code>元素和<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element element</td>
<td>div p</td>
<td>选择<code>&lt;div&gt;</code>元素内的所有<code>&lt;p&gt;</code>元素</td>
<td>1</td>
</tr>
<tr>
<td>element&gt;element</td>
<td>div&gt;p</td>
<td>选择所有父级是 <code>&lt;div&gt;</code> 元素的 <code>&lt;p&gt;</code> 元素（div的直接儿子，不包含孙子）</td>
<td>2</td>
</tr>
<tr>
<td>element+element</td>
<td>div+p</td>
<td>选择所有紧跟在 <code>&lt;div&gt;</code> 元素之后的第一个 <code>&lt;p&gt;</code> 元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute]</td>
<td>[target]</td>
<td>选择所有带有target属性元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute=value]</td>
<td>[target=-blank]</td>
<td>选择所有使用target=&quot;-blank&quot;的元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute~=value]</td>
<td>[title~=flower]</td>
<td>选择标题属性包含单词&quot;flower&quot;的所有元素</td>
<td>2</td>
</tr>
<tr>
<td>[attribute</td>
<td>=language]</td>
<td>[lang</td>
<td>=en]</td>
</tr>
<tr>
<td>:link</td>
<td>a:link</td>
<td>选择所有未访问链接</td>
<td>1</td>
</tr>
<tr>
<td>:visited</td>
<td>a:visited</td>
<td>选择所有访问过的链接</td>
<td>1</td>
</tr>
<tr>
<td>:active</td>
<td>a:active</td>
<td>选择活动链接</td>
<td>1</td>
</tr>
<tr>
<td>:hover</td>
<td>a:hover</td>
<td>选择鼠标在链接上面时</td>
<td>1</td>
</tr>
<tr>
<td>:focus</td>
<td>input:focus</td>
<td>选择具有焦点的输入元素</td>
<td>2</td>
</tr>
<tr>
<td>:first-letter</td>
<td>p:first-letter</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一个字母</td>
<td>1</td>
</tr>
<tr>
<td>:first-line</td>
<td>p:first-line</td>
<td>选择每一个<code>&lt;p&gt;</code>元素的第一行</td>
<td>1</td>
</tr>
<tr>
<td>:first-child</td>
<td>p:first-child</td>
<td>指定只有当<code>&lt;p&gt;</code>元素是其父级的第一个子级的样式。</td>
<td>2</td>
</tr>
<tr>
<td>:before</td>
<td>p:before</td>
<td>在每个<code>&lt;p&gt;</code>元素之前插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:after</td>
<td>p:after</td>
<td>在每个<code>&lt;p&gt;</code>元素之后插入内容</td>
<td>2</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>p:lang(it)</td>
<td>选择一个lang属性的起始值=&quot;it&quot;的所有<code>&lt;p&gt;</code>元素</td>
<td>2</td>
</tr>
<tr>
<td>element1~element2</td>
<td>p~ul</td>
<td>选择p元素之后的每一个ul元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute^=value]</td>
<td>a[src^=&quot;https&quot;]</td>
<td>选择每一个src属性的值以&quot;https&quot;开头的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute$=value]</td>
<td>a[src$=&quot;.pdf&quot;]</td>
<td>选择每一个src属性的值以&quot;.pdf&quot;结尾的元素</td>
<td>3</td>
</tr>
<tr>
<td>[attribute*=value]</td>
<td>a[src*=&quot;runoob&quot;]</td>
<td>选择每一个src属性的值包含子字符串&quot;runoob&quot;的元素</td>
<td>3</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>p:first-of-type</td>
<td>选择每个p元素是其父级的第一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>p:last-of-type</td>
<td>选择每个p元素是其父级的最后一个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>p:only-of-type</td>
<td>选择每个p元素是其父级的唯一p元素</td>
<td>3</td>
</tr>
<tr>
<td>:only-child</td>
<td>p:only-child</td>
<td>选择每个p元素是其父级的唯一子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>p:nth-child(2)</td>
<td>选择每个p元素是其父级的第二个子元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>p:nth-last-child(2)</td>
<td>选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>p:nth-of-type(2)</td>
<td>选择每个p元素是其父级的第二个p元素</td>
<td>3</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>p:nth-last-of-type(2)</td>
<td>选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td>
<td>3</td>
</tr>
<tr>
<td>:last-child</td>
<td>p:last-child</td>
<td>选择每个p元素是其父级的最后一个子级。</td>
<td>3</td>
</tr>
<tr>
<td>:root</td>
<td>:root</td>
<td>选择文档的根元素</td>
<td>3</td>
</tr>
<tr>
<td>:empty</td>
<td>p:empty</td>
<td>选择每个没有任何子级的p元素（包括文本节点）</td>
<td>3</td>
</tr>
<tr>
<td>:target</td>
<td>#news:target</td>
<td>选择当前活动的#news元素（包含该锚名称的点击的URL）</td>
<td>3</td>
</tr>
<tr>
<td>:enabled</td>
<td>input:enabled</td>
<td>选择每一个已启用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:disabled</td>
<td>input:disabled</td>
<td>选择每一个禁用的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:checked</td>
<td>input:checked</td>
<td>选择每个选中的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:not(selector)</td>
<td>:not(p)</td>
<td>选择每个并非p元素的元素</td>
<td>3</td>
</tr>
<tr>
<td>::selection</td>
<td>::selection</td>
<td>匹配元素中被用户选中或处于高亮状态的部分</td>
<td>3</td>
</tr>
<tr>
<td>:out-of-range</td>
<td>:out-of-range</td>
<td>匹配值在指定区间之外的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:in-range</td>
<td>:in-range</td>
<td>匹配值在指定区间之内的input元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-write</td>
<td>:read-write</td>
<td>用于匹配可读及可写的元素</td>
<td>3</td>
</tr>
<tr>
<td>:read-only</td>
<td>:read-only</td>
<td>用于匹配设置 &quot;readonly&quot;（只读） 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:optional</td>
<td>:optional</td>
<td>用于匹配可选的输入元素</td>
<td>3</td>
</tr>
<tr>
<td>:required</td>
<td>:required</td>
<td>用于匹配设置了 &quot;required&quot; 属性的元素</td>
<td>3</td>
</tr>
<tr>
<td>:valid</td>
<td>:valid</td>
<td>用于匹配输入值为合法的元素</td>
<td>3</td>
</tr>
<tr>
<td>:invalid</td>
<td>:invalid</td>
<td>用于匹配输入值为非法的元素</td>
<td>3</td>
</tr>
</tbody>
</table>
<hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener noreferrer">position - CSS | MDN</a> </p>
</li>
<li id="footnote2"><p><a href="https://blog.csdn.net/allway2/article/details/125083126" target="_blank" rel="noopener noreferrer">Flexbox 基础知识_allway2的博客-CSDN博客</a> </p>
</li>
<li id="footnote3"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Flexbox" target="_blank" rel="noopener noreferrer">弹性盒子 - 学习 Web 开发 | MDN</a> </p>
</li>
<li id="footnote4"><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/CSS_layout/Grids#flexbox_%E7%BD%91%E6%A0%BC" target="_blank" rel="noopener noreferrer">网格 - 学习 Web 开发 | MDN</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js 笔记</title>
      <link>https://timpcfan.site/code/frontend/vue.html</link>
      <guid>https://timpcfan.site/code/frontend/vue.html</guid>
      <source url="https://timpcfan.site/rss.xml">Vue.js 笔记</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 03 Oct 2022 12:48:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>提示</p>
<p>Vue (读音 /vjuː/，类似于  view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>
</div>
<div><p>注意</p>
<p>本笔记整理较为混乱，建议使用<a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">官方文档</a>学习。</p>
</div>
<h2 id="相关学习资源" tabindex="-1"> 相关学习资源</h2>
<ul>
<li>
<p><a href="https://v2.cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue2 文档</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org" target="_blank" rel="noopener noreferrer">Vue3 文档</a></p>
</li>
</ul>
<h2 id="vue-简介" tabindex="-1"> vue 简介</h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" alt="AYFU9u" loading="lazy"></p>
<p>官方给 vue 的定位是前端框架，因为它提供了构建用户界面的一整套解决方案（俗称 vue 全家桶）</p>
<ul>
<li>vue（核心库）</li>
<li>vue-router（路由方案）</li>
<li>vuex（状态管理方案）</li>
<li>vue 组件库（快速搭建页面 UI 效果的方案）</li>
</ul>
<p>以及辅助 vue 项目开发的一系列工具：</p>
<ul>
<li>vue-cli（npm 全局包：一键生成工程化的 vue 项目 - 基于 webpack，大而全）</li>
<li>vite（npm 全局包：一键生成工程化的 vue 项目 - 小而巧）</li>
<li>vue-devtools（浏览器插件：辅助调试的工具）</li>
<li>vetur（vscode 插件：提供语法高亮和智能提示）</li>
</ul>
<h3 id="vue-的特性" tabindex="-1"> vue 的特性</h3>
<ul>
<li>数据驱动视图：
<ul>
<li>在使用了 vue 的页面中，vue 会监听数据的变化，从而自动重新渲染页面的结构。</li>
<li>好处：当页面数据发生变化时，页面会自动重新渲染。</li>
<li>注：这是单向的数据绑定</li>
</ul>
</li>
<li>双向数据绑定
<ul>
<li>在填写表单时，双向数据绑定可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中。</li>
</ul>
</li>
</ul>
<h3 id="mvvm" tabindex="-1"> MVVM</h3>
<p>MVVM 是 vue 实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。它把每个 HTML 页面都拆分成了三个部分：</p>
<ul>
<li>View：当前页面所渲染的 DOM 结构</li>
<li>Model：当前页面渲染时所依赖的数据源</li>
<li>ViewModel：表示 vue 的实例，它是 MVVM 的核心，连接 View 与 Model</li>
</ul>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/mZ91S3.png" alt="mZ91S3" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/qF2xKn.png" alt="qF2xKn" loading="lazy"></p>
<h3 id="vue-的版本" tabindex="-1"> vue 的版本</h3>
<ul>
<li>2.x 版本是目前企业级项目开发中的主流版本</li>
<li>3.x 版本于 2020-09-19 发布，是未来企业级项目开发的趋势</li>
</ul>
<h3 id="_2-x-与-3-x-的对比" tabindex="-1"> 2.x 与 3.x 的对比</h3>
<ul>
<li>2.x 的绝大多数 API 在 3.x 中同样支持。</li>
<li>3.x 新增：组合式 API、多根节点组件、更好的 TypeScript 支持等</li>
<li>3.x 废弃：过滤器、不再支持$on，$off 和$once 实例方法等</li>
</ul>
<h2 id="vue-基础" tabindex="-1"> vue 基础</h2>
<p>渐进式 JavaScript 框架</p>
<h3 id="第一个-vue-程序" tabindex="-1"> 第一个 Vue 程序</h3>
<ol>
<li>导入开发版本的 Vue.js</li>
<li>创建 Vue 实例对象，设置 <code>el</code> 属性和 <code>data</code> 属性</li>
<li>使用简洁的模板语法把数据渲染到页面上</li>
</ol>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>基础</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>{</span><span>{</span> message <span>}</span><span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@next<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var vm = new Vue({
        el: "#app",
        data: {
          message: "Hello Vue!",
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="el-挂载点" tabindex="-1"> el：挂载点</h4>
<ul>
<li>Vue 实例的作用范围？
<ul>
<li>作用在 <code>el</code> 作用的元素内部（包括任意层次的子标签）</li>
</ul>
</li>
<li>其值可以使用其他选择器吗？
<ul>
<li>可以，css 选择器都可以，但建议使用 ID 选择器</li>
</ul>
</li>
<li>是否可以设置其他的 dom 元素
<ul>
<li>可以，但建议使用 div 标签，因为没有其他样式</li>
</ul>
</li>
</ul>
<h4 id="data-数据对象" tabindex="-1"> data：数据对象</h4>
<ul>
<li>Vue 中用到的数据定义在 <code>data</code> 中</li>
<li><code>data</code> 中可以写复杂类型的数据</li>
<li>渲染复杂类型的数据时，遵守 js 的语法即可</li>
</ul>
<h2 id="vue-指令" tabindex="-1"> vue 指令</h2>
<h3 id="v-text" tabindex="-1"> v-text</h3>
<blockquote>
<p>设置标签的文本值（textContent）</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>她说：{{ message }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span><span>></span></span>她说：{{ message+'???' }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span> <span>v-text</span><span><span>=</span><span>"</span>message<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
  <span><span><span>&lt;</span>h1</span> <span>v-text</span><span><span>=</span><span>"</span>message+'???'<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>将标签中的文本，都使用 <code>data</code> 的指定属性替换。</p>
<p>可以在 v-text 中拼接字符串。</p>
<h3 id="v-html" tabindex="-1"> v-html</h3>
<blockquote>
<p>设置标签的 innerHTML</p>
</blockquote>
<p>与 <code>v-text</code> 类似，不过如果设置的文本为 html 内容会进行解析。</p>
<h3 id="v-on-基础" tabindex="-1"> v-on 基础</h3>
<blockquote>
<p>为元素绑定事件</p>
</blockquote>
<p>语法：<code>v-on:事件名=&quot;方法名&quot;</code> 或者 <code>@事件名=&quot;方法名&quot;</code></p>
<ul>
<li>方法定义在 Vue 对象的 <code>methods</code> 属性中。</li>
<li>方法内部通过 <code>this</code> 关键字可以访问定义在 <code>data</code> 中的数据</li>
<li>如果是直接将方法写在属性的位置，则不需要 <code>this.xxx</code></li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>method1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>method1<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span><span>v-on:</span>monseenter</span><span><span>=</span><span>"</span>method2<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>事件绑定<span>"</span></span> <span>@dblclick</span><span><span>=</span><span>"</span>message='点击啦'<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注</p>
<p>注：事件名不需要写 <code>on</code> 因为左侧 <code>v-on</code> 已经有了</p>
</div>
<div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>method1</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>"你好吗"</span><span>;</span>
    <span>}</span><span>,</span>
    <span>method2</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-show" tabindex="-1"> v-show</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>isShow<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-show</span><span><span>=</span><span>"</span>age>=18<span>"</span></span><span>></span></span>hhh<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>isShow</span><span>:</span> <span>false</span><span>,</span>
    <span>age</span><span>:</span> <span>16</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-if" tabindex="-1"> v-if</h3>
<blockquote>
<p>根据表达值的真假，切换元素的显示和隐藏（操纵 dom 元素）</p>
</blockquote>
<p>与 <code>v-show</code> 类似，但操纵的是 dom 元素（在 dom 中添加或删除该标签）</p>
<div><p>如何选择 `v-show` 还是 `v-if` ？</p>
<p>频繁切换的元素使用 <code>v-show</code> ，否则使用 <code>v-if</code></p>
</div>
<h3 id="v-else" tabindex="-1"> v-else</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div><p>注意</p>
<p>前一兄弟元素必须有  <code>v-if</code>  或  <code>v-else-if</code>。</p>
</div>
<h3 id="v-else-if" tabindex="-1"> v-else-if</h3>
<blockquote>
<p>与 v-if 配合，切换元素的显示和隐藏</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>type === 'A'<span>"</span></span><span>></span></span><span>
  A
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else-if</span><span><span>=</span><span>"</span>type === 'B'<span>"</span></span><span>></span></span><span>
  B
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else-if</span><span><span>=</span><span>"</span>type === 'C'<span>"</span></span><span>></span></span><span>
  C
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>v-else</span><span>></span></span><span>
  Not A/B/C
</span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-bind" tabindex="-1"> v-bind</h3>
<blockquote>
<p>设置元素的属性（比如：src, title, class）</p>
</blockquote>
<p>语法：<code>v-bind:属性名=表达式</code> 或 <code>:属性名=表达式</code></p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>img</span> <span><span>v-bind:</span>src</span><span><span>=</span><span>"</span>imgSrc<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>imgtitle+'!!!'<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span>:class</span><span><span>=</span><span>"</span>isActive?'active':''<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>img</span> <span>:class</span><span><span>=</span><span>"</span>{active:isActive}<span>"</span></span> <span>/></span></span>
  <span>&lt;!-- 对象的写法：active 是否生效，取决于 isActive 的值 --></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>设置 <code>class</code> 属性时，建议使用对象的写法（第 4 个）</p>
</div>
<h3 id="v-for" tabindex="-1"> v-for</h3>
<blockquote>
<p>根据数据生成列表结构</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>item in arr<span>"</span></span> <span>:title</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>{{ item }}<span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item, index) in arr<span>"</span></span><span>></span></span>{{ index }}{{ item }}<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>arr</span><span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>当列表的数据变化时，默认情况下，vue 会尽可能地复用已存在的 DOM 元素，从而提升渲染的性能。但这种默认的性能优化策略，会<strong>导致有状态的列表无法被正确更新</strong>。此时，需要为每项提供一个<strong>唯一</strong>的 key 属性（不能使用 index）：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>user in userlist<span>"</span></span> <span>:key</span><span><span>=</span><span>"</span>user.id<span>"</span></span><span>></span></span><span>
    </span><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>checkbox<span>"</span></span> <span>/></span></span><span>
    姓名：</span><span>{</span><span>{</span>user<span>.</span>name<span>}</span><span>}</span><span>
  </span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div>
<h3 id="v-on-补充" tabindex="-1"> v-on 补充</h3>
<blockquote>
<p>传递自定义参数，事件修饰符</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>@click</span><span><span>=</span><span>"</span>method1(p1,p2)<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>@keyup.enter</span><span><span>=</span><span>"</span>sayHi<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>method1</span><span>:</span> <span>function</span> <span>(</span><span>p1<span>,</span> p2</span><span>)</span> <span>{</span><span>}</span><span>,</span>
    <span>sayHi</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>解释</strong></p>
<ul>
<li>可以在 v-on 的属性中传入函数的参数</li>
<li>对于事件，可以使用修饰符</li>
</ul>
<p><strong>修饰符</strong>（文档：<a href="https://v2.cn.vuejs.org/v2/api/#v-on" target="_blank" rel="noopener noreferrer">https://v2.cn.vuejs.org/v2/api/#v-on</a>）</p>
<ul>
<li><code>.stop</code> - 调用  <code>event.stopPropagation()</code>。（阻止冒泡行为（内到外））</li>
<li><code>.prevent</code> - 调用  <code>event.preventDefault()</code>。（例如：阻止超链接的跳转）</li>
<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。（定义在外层组件上，以捕获的形式来触发事件（外到内））</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。（只有点他自己才会触发，而不受冒泡影响）</li>
<li><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
<li><code>.once</code> - 只触发一次回调。</li>
<li><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</li>
<li><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</li>
<li><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</li>
<li><code>.passive</code> - (2.3.0) 以  <code>{ passive: true }</code>  模式添加侦听器</li>
</ul>
<h4 id="事件对象-event" tabindex="-1"> 事件对象 event</h4>
<p>在原生的 DOM 事件绑定中，可以在事件处理函数处，接收事件对象 event。同理，在 v-on 指令所绑定的事件处理函数中，同样可以接收到事件对象 event：</p>
<div><pre><code><span>&lt;</span>button @click<span>=</span><span>"addCount"</span><span>></span><span>+</span><span>1</span><span><span><span>&lt;/</span>button</span><span>></span></span>
<span>// ----------------------------------------------------</span>
<span>methods</span><span>:</span> <span>{</span>
  <span>addCount</span><span>(</span><span>e</span><span>)</span> <span>{</span> <span>// e 为事件对象</span>
    <span>const</span> color <span>=</span> e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor
    e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor <span>=</span> color <span>===</span> <span>'red'</span> <span>?</span> <span>''</span> <span>:</span> <span>'red'</span>
    <span>this</span><span>.</span>count <span>+=</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当传递参数时，event 对象将被覆盖掉，此时我们可以传递一个特殊的参数 <code>$event</code> 来表示原生的事件参数对象：</p>
<div><pre><code><span>&lt;</span>button @click<span>=</span><span>"addCount(step, $event)"</span><span>></span><span>+</span><span>1</span><span><span><span>&lt;/</span>button</span><span>></span></span>
<span>// ----------------------------------------------------</span>
<span>methods</span><span>:</span> <span>{</span>
  <span>addCount</span><span>(</span><span>step<span>,</span> e</span><span>)</span> <span>{</span> <span>// e 为事件对象</span>
    console<span>.</span><span>log</span><span>(</span>step<span>)</span>
    <span>const</span> color <span>=</span> e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor
    e<span>.</span>target<span>.</span>style<span>.</span>backgroundColor <span>=</span> color <span>===</span> <span>'red'</span> <span>?</span> <span>''</span> <span>:</span> <span>'red'</span>
    <span>this</span><span>.</span>count <span>+=</span> <span>1</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="v-model" tabindex="-1"> v-model</h3>
<blockquote>
<p>获取和设置表单元素的值（<strong>双向数据绑定</strong>）</p>
</blockquote>
<ul>
<li>绑定的是 <code>input</code> 的 <code>value</code> 属性</li>
<li>之后无论是在表单中直接修改元素，还是在 js 中修改绑定的变量，都会使得两边的值都被改变</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>message<span>"</span></span> <span>/></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"lalala"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="vue-过滤器-vue2-x-内容" tabindex="-1"> vue 过滤器（vue2.x 内容）</h2>
<p>过滤器（Filters）常用于文本的格式化。例如：hello → Hello</p>
<p>过滤器应该被添加在 JavaScript 表达式的尾部，由“管道符”进行调用，示例代码如下：</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> message <span>|</span> capitalize <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span><span>v-bind:</span>id</span><span><span>=</span><span>"</span>rawId | formatId<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>过滤器可以用在两个地方：</p>
<ul>
<li>插值表达式（{{}}）</li>
<li>和 v-bind 属性绑定（:xxx）</li>
</ul>
<p>在创建 vue 实例期间，可以在 filters 节点中定义过滤器，示例代码：</p>
<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"hello vue.js"</span><span>,</span>
    <span>info</span><span>:</span> <span>"title info"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>filters</span><span>:</span> <span>{</span>
    <span>capitalize</span><span>(</span><span>str</span><span>)</span> <span>{</span>
      <span>return</span> str<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span> <span>+</span> str<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="连续调用多个过滤器" tabindex="-1"> 连续调用多个过滤器</h3>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> text <span>|</span> capitalize <span>|</span> maxLength <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="过滤器传参" tabindex="-1"> 过滤器传参</h3>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span> message <span>|</span> <span>filterA</span><span>(</span>arg1<span>,</span> arg2<span>)</span> <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

Vue<span>.</span><span>filter</span><span>(</span><span>'filterA'</span><span>,</span> <span>(</span><span>msg<span>,</span> arg1<span>,</span> arg2</span><span>)</span> <span>=></span> <span>{</span><span>...</span><span>}</span><span>)</span>  <span>// msg永远是第一个参数</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="版本兼容性" tabindex="-1"> 版本兼容性</h3>
<p>3.x 版本中取消掉了过滤器的特性，官方建议使用或<strong>方法</strong>代替之。</p>
<h2 id="vue-组件基础" tabindex="-1"> vue 组件基础</h2>
<p>如何创建 vite 项目：</p>
<h3 id="组件化开发思想" tabindex="-1"> 组件化开发思想</h3>
<div><p>相关信息</p>
<p>根据封装的思想，把页面上可重用的部分封装成组件，从而方便项目的开发和维护。</p>
</div>
<p>vue 是一个完全支持组件化开发的框架。vue 中规定组件的后缀名是 .vue。</p>
<h3 id="vue-组件的构成" tabindex="-1"> vue 组件的构成</h3>
<p>每个.vue 组件都由 3 部分构成，分别是：</p>
<ul>
<li>template → 组件的模板结构（必需）</li>
<li>script → 组件的 JavaScript 行为（可选）</li>
<li>style → 组件的样式（可选）</li>
</ul>
<h4 id="组件的-template-节点" tabindex="-1"> 组件的 template 节点</h4>
<p>在组件 <code>&lt;template&gt;</code> 节点中，支持使用 vue 指令，来辅助渲染当前组件的 DOM 结构。</p>
<div><p>注意</p>
<p>2.x 中，template 标签内仅支持单一根节点，3.x 中取消了该限制。</p>
</div>
<h4 id="组件的-script-节点" tabindex="-1"> 组件的 script 节点</h4>
<p>vue 规定：组件内 <code>&lt;script&gt;</code> 节点是可选的，开发者可以在 <code>&lt;script&gt;</code> 节点中封装组件的 JavaScript 业务逻辑。 <code>&lt;script&gt;</code> 节点的基本结构如下：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
// 今后，组件相关的 data 数据、methods 方法等，
// 都需要定义到 export default 所导出的对象中。
export default {
    name: 'MyApp', // name属性表示组件名称（建议首字母大写）
    data() {  // 组件中 data 需要指向一个函数，而不是一个对象！！
        return {
            username: 'lzt',
            count: 0,
        }
    },
    methods: {
        addCount() {
            this.count++;
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="组件中的-style-节点" tabindex="-1"> 组件中的 style 节点</h4>
<p>vue 规定：组件内的 <code>&lt;style&gt;</code> 节点是可选的，开发者可以在 <code>&lt;style&gt;</code> 节点中编写样式美化当前组件的 UI 结构。 <code>&lt;style&gt;</code> 节点的基本结构如下：</p>
<div><pre><code><span><span><span>&lt;</span>style</span> <span>lang</span><span><span>=</span><span>"</span>css<span>"</span></span><span>></span></span><span>
h1 {
    font-weight: normal;
}
</span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>也可以使用其他的语法，如 less 等，需要安装相应的依赖包：<code>npm install less -D</code></p>
</div>
<h3 id="组件的注册" tabindex="-1"> 组件的注册</h3>
<p>组件之间可以进行相互的引用，例如：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/SieVd6.png" alt="SieVd6" loading="lazy"></p>
<p>vue 中组件的引用原则：先注册后使用。</p>
<h4 id="组件注册的两种方式" tabindex="-1"> 组件注册的两种方式</h4>
<p>vue 中注册组件的方式分为“全局注册”和“局部注册”两种，其中：</p>
<ul>
<li>全局注册：可以在全局任何一个组件内使用</li>
<li>局部注册：只能在当前注册的范围内使用</li>
</ul>
<h4 id="全局注册组件" tabindex="-1"> 全局注册组件</h4>
<div><pre><code><span>// main.js</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>// 1. 导入需要被全局注册的组件</span>
<span>import</span> Swiper <span>from</span> <span>"./components/01.globalReg/Swiper.vue"</span><span>;</span>
<span>import</span> Test <span>from</span> <span>"./components/01.globalReg/Test.vue"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

<span>// 2. 调用 app.compenent() 方法全局注册组件</span>
app<span>.</span><span>compenent</span><span>(</span><span>"my-swiper"</span><span>,</span> Swiper<span>)</span><span>;</span>
app<span>.</span><span>compenent</span><span>(</span><span>"my-test"</span><span>,</span> Test<span>)</span><span>;</span>

app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// App.vue</span>
<span>// 3. 在页面中使用上面定义的标签名</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>my-swiper</span><span>></span></span><span><span><span>&lt;/</span>my-swiper</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>my-test</span><span>></span></span><span><span><span>&lt;/</span>my-test</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="局部注册组件" tabindex="-1"> 局部注册组件</h4>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>my-search</span><span>></span></span><span><span><span>&lt;/</span>my-search</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
import MySearch from './compenents/MySearch.vue'
export default {
    compenents: {  // 通过 compenents 节点，为当前的组件注册私有子组件
        'my-search': MySearch,
        MySearch, // 也可以直接这样，这是使用大驼峰法命名
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="组件注册时的命名" tabindex="-1"> 组件注册时的命名</h4>
<ul>
<li>使用 kebab-case 命名法（短横线命名法，如 my-swiper ）
<ul>
<li>必须严格按照短横线名称进行使用</li>
</ul>
</li>
<li>使用 PascalCase 命名法（帕斯卡命名法或大驼峰法，如 MySwiper）
<ul>
<li>既可以严格按照帕斯卡名称使用，也可以转换成短横线名称使用</li>
</ul>
</li>
</ul>
<p>可以直接使用组件的.name 属性</p>
<div><pre><code><span>// main.js</span>
app<span>.</span><span>compenent</span><span>(</span>Swiper<span>.</span>name<span>,</span> Swiper<span>)</span><span>;</span> <span>// Swiper.name === 'MySwiper'</span>
app<span>.</span><span>compenent</span><span>(</span>Test<span>.</span>name<span>,</span> Test<span>)</span><span>;</span> <span>// Test.name === 'MyTest'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="组件之间样式冲突问题" tabindex="-1"> 组件之间样式冲突问题</h3>
<div><p>相关信息</p>
<p>若在父组件中定义样式，会影响到子组件的样式，这样就很容易造成多个组件之间的样式冲突问题。导致组件冲突问题的根本原因是：</p>
<ol>
<li>单页面应用程序中，所有组件的 DOM 结构，都是基于<strong>唯一的 index.html 页面</strong>进行呈现的</li>
<li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li>
</ol>
</div>
<h4 id="使用自定义属性解决样式冲突" tabindex="-1"> 使用自定义属性解决样式冲突</h4>
<p>为每个组件<strong>分配唯一的自定义属性</strong>，在编写组件样式时，通过<strong>属性选择器</strong>来控制<strong>样式的作用域</strong>：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span> <span>data-v-001</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h3</span> <span>data-v-001</span><span>></span></span><span>轮播图组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>style</span><span>></span></span><span>
  /* 通过中括号“属性选择器”，来防止组件之间的样式冲突问题 */
    .container[data-v-001] {
        border: 1px solid red;
    }
</span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="使用-scoped-属性解决样式冲突" tabindex="-1"> 使用 scoped 属性解决样式冲突</h4>
<p>手动分配自定义属性非常难以维护，可以使用 style 节点的 scoped 属性，vue 将自动分配自定义属性：</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>轮播图组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span>&lt;</span>style <span>**</span>scoped<span>**</span><span>></span><span><span>
    <span>.container</span> <span>{</span>
        <span>border</span><span>:</span> 1px solid red<span>;</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="deep-样式穿透" tabindex="-1"> /deep/ 样式穿透</h4>
<p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。</p>
<div><pre><code><span>&lt;</span>style lang<span>=</span>"less scoped<span>></span><span><span>
<span>.title</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 不加 /deep/ 时，生成 .title[data-v-xxx] */</span>
<span>}</span>

<span>/deep/ .title</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 加上 /deep/ 时，生成 [data-v-xxx] .title */</span>
<span>}</span>

<span>:deep(.title)</span> <span>{</span>
    <span>color</span><span>:</span> blue<span>;</span> <span>/* 这是3.x的推荐写法，生成 [data-v-xxx] .title */</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件的-props" tabindex="-1"> 组件的 props</h3>
<p>为了提高组件的复用性，在封装 vue 组件时需要遵守如下的规则：</p>
<ul>
<li>组件的<strong>DOM 结构</strong>、<strong>style 样式</strong>要尽量复用</li>
<li>组件中<strong>要展示的数据</strong>，尽量由组件的使用者提供</li>
</ul>
<div><p>相关信息</p>
<p>props 是组件的自定义属性，组件的使用者可以通过 props 把数据传递到子组件内部，供子组件内部进行使用。</p>
</div>
<p>例子：</p>
<div><pre><code><span><span><span>&lt;</span>my-article</span> <span>title</span><span><span>=</span><span>"</span>面朝大海，春暖花开<span>"</span></span> <span>author</span><span><span>=</span><span>"</span>海子<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>props 的<strong>作用</strong>：父组件通过 props<strong>向子组件传递要展示的数据</strong>。</p>
<p>props 的<strong>好处</strong>：提高了组件的<strong>复用性</strong>。</p>
<h4 id="在组件中声明-props" tabindex="-1"> 在组件中声明 props</h4>
<p>在封装 vue 组件时，可以把动态的数据项声明为 props 自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>标题：</span><span>{</span><span>{</span>title<span>}</span><span>}</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h5</span><span>></span></span><span>作者：</span><span>{</span><span>{</span>author<span>}</span><span>}</span><span><span><span>&lt;/</span>h5</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: ['title', 'author'], // 父组件传递给my-article组件的数据，必须在props节点中声明
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>props 中未声明的属性，如果传递会被忽视。</p>
</div>
<h4 id="动态绑定-props-的值" tabindex="-1"> 动态绑定 props 的值</h4>
<p>可以使用 v-bind 属性绑定的形式，为组件动态绑定 props 的值。</p>
<div><pre><code><span><span><span>&lt;</span>my-article</span> <span>:title</span><span><span>=</span><span>"</span>info.title<span>"</span></span> <span>author</span><span><span>=</span><span>"</span>info.author<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="props-的大小写命名" tabindex="-1"> props 的大小写命名</h4>
<p>组件中如果使用“camelCase（驼峰命名法）”声明了 props 属性的名称，则有两种方式为其绑定属性的值：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: ['**pubTime**'],
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>my-article</span> <span>pubTime</span><span><span>=</span><span>"</span>1989<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
<span><span><span>&lt;</span>my-article</span> <span>pub-time</span><span><span>=</span><span>"</span>1989<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-article</span><span>></span></span>
</code></pre><div><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="props-验证" tabindex="-1"> props 验证</h4>
<p>在分装组件时对外界传递过来的 props 数据进行合法性的校验，从而防止数据不合法的问题。使用对象类型的 props 节点，可以对每个 prop 进行数据类型的校验：</p>
<div><pre><code><span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    props: {  // 使用对象类型的 props 而不是数组类型，若不按类型传递会在浏览器中警告
        p1: Number,
        p2: Boolean,
        p3: String,
        p4: Array,
        p5: Object,
        p6: Date,
        p7: Funciton,
        p8: Symbol,  // 共8种基础类型

        pA: [String, Number],  // 可以使用数组来指定多个可能的类型

        pB: { // 使用配置对象形式
            type: String,
            required: true // 当前属性为必填项
        },

        pC: {
            type: String,
            default: "lzt" // 当前属性的默认值
        },

        pD: {
            validator(value) {  // 自定义的验证函数，返回true代表合法
                return ['A', 'B', 'C'].indexOf(value) !== -1
            }
        }
    }
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="class-与-style-绑定" tabindex="-1"> Class 与 Style 绑定</h3>
<h4 id="以三元表达式绑定-html-的-class" tabindex="-1"> 以三元表达式绑定 HTML 的 class</h4>
<p>可以使用三元表达式，动态地为元素绑定 class 的类名。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>isItalic ? 'italic' : ''<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="以数组语法绑定-html-的-clas" tabindex="-1"> 以数组语法绑定 HTML 的 clas</h4>
<p>如果元素需要动态绑定多个 class 的类名，此时可以使用数组的语法格式。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>[isItalic ? 'italic' : '', isDelete ? 'delete' : '']<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="以对象语法绑定-html-的-class" tabindex="-1"> 以对象语法绑定 HTML 的 class</h4>
<p>推荐使用此方法绑定 class。</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>class</span><span><span>=</span><span>"</span>thin<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>{italic:isItalic}<span>"</span></span><span>></span></span><span>halo</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span>:class</span><span><span>=</span><span>"</span>classObj<span>"</span></span><span>></span></span><span>how are you</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>isItalic</span><span>:</span> <span>true</span><span>,</span>
        <span>classObj</span><span>:</span> <span>{</span> <span>// 对象中，属性名是class名，值是布尔值</span>
            <span>italic</span><span>:</span> <span>true</span><span>,</span>  <span>// true代表应用这个类名</span>
            <span>delete</span><span>:</span> <span>false</span><span>,</span>  <span>// false代表不应用这个类名</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="以对象语法绑定内联的-style" tabindex="-1"> 以对象语法绑定内联的 style</h4>
<p><code>:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式或短横线分隔（需要加引号）来命名：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>:style</span><span><span>=</span><span>"</span>{color: active, fontSize: fsize + 'px', 'background-color': bgcolor}<span>"</span></span><span>></span></span><span>
    lalala
</span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>active</span><span>:</span> <span>'red'</span><span>,</span>
        <span>fsize</span><span>:</span> <span>30</span><span>,</span>
        <span>bgcolor</span><span>:</span> <span>'pink'</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="计算属性" tabindex="-1"> 计算属性</h3>
<div><p>相关信息</p>
<p>计算属性本质上就是一个函数，它可以实时监听 data 中数据的变化，并 return 一个计算后的新值，供组件渲染 DOM 时使用。</p>
</div>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model.number</span><span><span>=</span><span>"</span>count<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>{</span>count<span>}</span><span>}</span><span> 乘以 2 的值为：</span><span>{</span><span>{</span>plus<span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>1</span> <span>}</span>
<span>}</span><span>,</span>
<span>computed</span><span>:</span> <span>{</span>
    <span>plus</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>count <span>*</span> <span>2</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>调用时不需要加()，当作普通属性使用。</li>
<li>计算属性会缓存结果，只用依赖发生变化时才重新计算，因此性能比方法好。</li>
<li>使用场景：购物车金额等</li>
</ul>
<div><pre><code><span>computed</span><span>:</span> <span>{</span>
    <span>total</span><span>(</span><span>)</span> <span>{</span>
        <span>let</span> t <span>=</span> <span>0</span>
        <span>this</span><span>.</span>fruitlist<span>.</span><span>forEach</span><span>(</span><span>x</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span>x<span>.</span>state<span>)</span> <span>{</span>
                t <span>+=</span> x<span>.</span>count
            <span>}</span>
        <span>}</span><span>)</span>
        <span>return</span> t
    <span>}</span><span>,</span>
    <span>amount</span><span>(</span><span>)</span> <span>{</span>
        <span>let</span> a <span>=</span> <span>0</span>
        <span>this</span><span>.</span>fruitlist<span>.</span><span>filter</span><span>(</span><span>x</span> <span>=></span> x<span>.</span>state<span>)</span><span>.</span><span>forEach</span><span>(</span><span>x</span> <span>=></span> <span>{</span>
            a <span>+=</span> x<span>.</span>price <span>*</span> x<span>.</span>count
        <span>}</span><span>)</span>
        <span>return</span> a
    <span>}</span><span>,</span>
    <span>isDisabled</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>total <span>==</span> <span>0</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="自定义事件-子传父" tabindex="-1"> 自定义事件（子传父）</h3>
<div><p>相关信息</p>
<p>在封装组件时，为了让<strong>组件的使用者</strong>可以<strong>监听到组件内状态的变化</strong>，此时需要用到<strong>组件的自定义事件</strong>。</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/6LdgWa.png" alt="6LdgWa" loading="lazy"></p>
<h4 id="自定义事件的使用" tabindex="-1"> 自定义事件的使用</h4>
<p>在封装组件时：</p>
<ol>
<li><strong>声明</strong>自定义事件：定义自定义组件时，在 emits 节点中声明。</li>
<li><strong>触发</strong>自定义事件：</li>
</ol>
<p>在使用组件时：</p>
<ol>
<li><strong>监听</strong>自定义事件</li>
</ol>
<div><pre><code><span>// 组件定义</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>button</span><span>></span></span><span>press me</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    emits: ['change'],  // 1. 声明自定义事件
    methods: {
        onBtnClick() {
            this.$emit('change') // 2. 手动触发自定义事件，参数为自定义事件名称
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 使用组件</span>
<span>// 3. 使用v-on监听事件</span>
<span>&lt;</span>my<span>-</span>counter @change<span>=</span><span>"getCount"</span><span>></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

<span>methods</span><span>:</span> <span>{</span>
    <span>getCount</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'count changed!'</span><span>)</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="自定义事件传参" tabindex="-1"> 自定义事件传参</h4>
<p>在调用 <code>this.$emit()</code> 方法触发自定义事件时，可以通过<strong>第 2 个</strong>参数为自定义事件传参。</p>
<div><pre><code><span>// 组件定义</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>button</span><span>></span></span><span>press me</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    emits: ['change'],
    methods: {
        onBtnClick() {
            this.$emit('change', this.count) // 可以使用**第2个**参数来向外传递信息
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>// 使用组件</span>
<span>&lt;</span>my<span>-</span>counter @change<span>=</span><span>"getCount"</span><span>></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

<span>methods</span><span>:</span> <span>{</span>
    <span>getCount</span><span>(</span><span>val</span><span>)</span> <span>{</span> <span>// 这里可以得到传递的信息</span>
        console<span>.</span><span>log</span><span>(</span><span>'count changed'</span><span>,</span> val<span>)</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件上的-v-model" tabindex="-1"> 组件上的 v-model</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hQRD5V.png" alt="hQRD5V" loading="lazy"></p>
<p>v-model 是双向数据绑定指令，当需要<strong>维护组件内外数据的同步</strong>时，可以在组件上使用 v-model 指令。</p>
<hr>
<ul>
<li><strong>外界数据的变化</strong>会<strong>自动同步</strong>到 counter 组件中</li>
<li>counter 组件中数据的变化，也会<strong>自动同步到外界</strong>。</li>
</ul>
<h4 id="在组件上使用-v-model-的步骤" tabindex="-1"> 在组件上使用 v-model 的步骤</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xb4bel.png" alt="xb4bel" loading="lazy"></p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>父组件 --- count:</span><span>{</span><span>{</span> count <span>}</span><span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    &lt;button @click="count += 1">+1</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>hr</span> <span>/></span></span><span>
    &lt;MyCounter **v-model**:number="count"></span><span><span><span>&lt;/</span><span>MyCounter</span></span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span>
import MyCounter from "./MyCounter.vue";
export default {
  name: "Father",
  data() {
    return {
      count: 0,
    };
  },
  components: { MyCounter },
};
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>count值是：</span><span>{</span><span>{</span> number <span>}</span><span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
    &lt;button @click="handleClick">-1</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>  // 注意子组件中并没有v-model
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
  name: "MyCounter",
  props: ["number"],
  emits: ["**update:**number"],
  methods: {
    handleClick() {
      this.$emit("update:number", this.number - 1);  // 可以通过 this.number 访问到 props 中的值
    },
  },
};
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p><code>update:xxx</code> 表示让 v-model 去更新 xxx 的值，为后面传递的参数</p>
</div>
<div><p>注意</p>
<p>此词条为 3.x 专属特性，请参考 <a href="https://cn.vuejs.org/guide/components/events.html#usage-with-v-model" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2 id="vue-组件高级" tabindex="-1"> vue 组件高级</h2>
<h3 id="watch-侦听器" tabindex="-1"> watch 侦听器</h3>
<div><p>相关信息</p>
<p>watch 侦听器允许开发者监视数据的变化，从而<strong>针对数据的变化做特定的操作</strong>。例如，监听用户名的变化并发起请求，判断用户名是否可用。</p>
</div>
<p>开发者需要在 watch 节点下，定义自己的侦听器。实例代码如下：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>username</span><span>:</span> <span>""</span> <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>watch</span><span>:</span> <span>{</span>
    <span>// 监听 username 的值的变化，</span>
    <span>// 形参列表中，第一个值是“变化后的新值”，第二个为“变化之前的旧值”</span>
    <span>username</span><span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>newVal<span>,</span> oldVal<span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用 object 的形式定义 watch，可以设置更多的选项：</p>
<ul>
<li>immediate 选项：组件加载完立即调用一次</li>
<li>deep 选项：当监听的是一个对象，对象的属性值变化都会被监听（若只想监听一个属性，则不需要使用 deep 选项，而是使用 ‘info.username’ 这样的形式作为监听的变量）</li>
</ul>
<div><pre><code><span>watch</span><span>:</span> <span>{</span>
    <span>username</span><span>:</span> <span>{</span>
        <span>async</span> <span>hander</span><span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>{</span>  <span>// handler 为处理方法</span>
            <span>const</span> <span>{</span> <span>data</span><span>:</span> res<span>}</span> <span>=</span> <span>await</span> axios<span>.</span><span>get</span><span>(</span><span><span>`</span><span>https://www.example.cn/api/</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            console<span>.</span><span>log</span><span>(</span>res<span>)</span>
        <span>}</span><span>,</span>
        <span>immediate</span><span>:</span> <span>true</span><span>;</span>  <span>// 表示组件加载完立即调用一次 watch 监听器</span>
    <span>}</span><span>,</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="组件的生命周期" tabindex="-1"> 组件的生命周期</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/hEeD6v.png" alt="hEeD6v" loading="lazy"></p>
<p>组件的生命周期：组件从 <strong>创建</strong> → <strong>运行</strong>（渲染）→ <strong>销毁</strong> 的整个过程，强调的是一个时间段。</p>
<p>生命周期函数：</p>
<ol>
<li>created：当组件在内存中被创建完毕之后调用（唯一一次）</li>
<li>mounted：当组件被成功渲染到页面上之后调用（唯一一次）</li>
<li>unmounted：当组件被销毁完毕之后调用（例如 v-if 为 false）（唯一一次）</li>
<li>updated：组件被重新渲染（data 更新了）完毕之后调用（0 至多次）</li>
<li>beforeCreate 等：在上述周期之前执行。</li>
</ol>
<div><p>相关信息</p>
<p>在实际开发中，created 是最常用的，比如进行 ajax 请求数据。若需要操作 dom 元素，则需要使用 mounted，因为 created 时组件还未被渲染。</p>
</div>
<h3 id="组件之间的数据共享" tabindex="-1"> 组件之间的数据共享</h3>
<p>在项目开发中，组件之间的关系分为如下 3 种：</p>
<ol>
<li>父子关系</li>
<li>兄弟关系</li>
<li>后代关系</li>
</ol>
<h4 id="父子组件的数据共享" tabindex="-1"> 父子组件的数据共享</h4>
<p>父子组件之间的数据共享又分为：</p>
<ol>
<li>父 → 子</li>
<li>子 → 父</li>
<li>父 ↔  子</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/X1WYvK.png" alt="X1WYvK" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gRIHQf.png" alt="gRIHQf" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/TktxFT.png" alt="TktxFT" loading="lazy"></p>
<h4 id="兄弟组件的数据共享" tabindex="-1"> 兄弟组件的数据共享</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/DWEqdA.png" alt="DWEqdA" loading="lazy"></p>
<h5 id="_1-安装-mit" tabindex="-1"> 1. 安装 mit</h5>
<div><pre><code>npm install mitt <span>-</span><span>S</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h5 id="_2-创建公共的-eventbus-模块" tabindex="-1"> 2. 创建公共的 EventBus 模块</h5>
<p>在项目中创建公共的 eventBus 模块如下：</p>
<div><pre><code><span>// 创建一个文件 eventBus.js</span>

<span>import</span> mitt <span>from</span> <span>"mitt"</span><span>;</span>
<span>const</span> bus <span>=</span> <span>mitt</span><span>(</span><span>)</span><span>;</span>

<span>export</span> <span>default</span> bus<span>;</span> <span>// 把创建的EventBus的实例共享出去</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="_3-在数据接收方自定义事件" tabindex="-1"> 3. 在数据接收方自定义事件</h5>
<p>在数据接收方，调用 bus.on(’事件名称’, 事件处理函数） 方法注册一个自定义事件。</p>
<div><pre><code><span>import</span> bus <span>from</span> <span>'./eventBus.js'</span>

<span>export</span> <span>default</span> <span>{</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span> <span>return</span> <span>{</span><span>count</span><span>:</span> <span>0</span><span>}</span> <span>}</span><span>,</span>
    <span>created</span><span>(</span><span>)</span> <span>{</span>
        bus<span>.</span><span>on</span><span>(</span><span>'countChange'</span><span>,</span> <span>(</span><span>count</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>count <span>=</span> count<span>;</span>
        <span>}</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="_4-在数据发送方触发事件" tabindex="-1"> 4. 在数据发送方触发事件</h5>
<p>在数据发送方，调用 bus.emit(’事件名称’，要发送的数据) 方法触发自定义事件。</p>
<div><pre><code><span>import</span> bus <span>from</span> <span>"./eventBus.js"</span><span>;</span>

<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>addCount</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>count<span>++</span><span>;</span>
      bus<span>.</span><span>emit</span><span>(</span><span>"countChange"</span><span>,</span> <span>this</span><span>.</span>count<span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="后代关系组件之间的数据共享" tabindex="-1"> 后代关系组件之间的数据共享</h4>
<p>可以使用 provide 和 inject 实现后代组件之间的数据共享。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/5QQbjj.png" alt="5QQbjj" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dM8Wma.png" alt="dM8Wma" loading="lazy"></p>
<p>上述的方法不是响应式的，改变了父组件的值，子孙组件没有变化，要使用 computed 函数修改：</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WLpXE4.png" alt="WLpXE4" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/gPCKax.png" alt="gPCKax" loading="lazy"></p>
<h4 id="vuex——终极的组件之间数据共享方案" tabindex="-1"> vuex——终极的组件之间数据共享方案</h4>
<p>vuex 可以让组件之间的数据共享变得高效、清晰、且易于维护。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/0HtmYq.png" alt="0HtmYq" loading="lazy"></p>
<p>创建一个共享的 store，存取数据都通过 store，实现不同组件之间的数据共享。</p>
<h3 id="vue3-x-中全局配置-axios" tabindex="-1"> vue3.x 中全局配置 axios</h3>
<h4 id="为什么要全局配置-axios" tabindex="-1"> 为什么要全局配置 axios？</h4>
<ol>
<li>每个组件中都需要导入 axios 包（代码臃肿）</li>
<li>没吃发请求都需要填写完整的请求路径（不利于后期的维护）</li>
</ol>
<h4 id="如何全局配置-axios" tabindex="-1"> 如何全局配置 axios？</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CwAmsY.png" alt="CwAmsY" loading="lazy"></p>
<div><pre><code><span>// main.js</span>

<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>
<span>import</span> <span>"./index.css"</span><span>;</span>

<span>import</span> axios <span>from</span> <span>"axios"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>"https://timpcfan.site"</span><span>;</span>
app<span>.</span>config<span>.</span>globalProperties<span>.</span>$http <span>=</span> axios<span>;</span> <span>// 这里的 $http 为自己取的名字，可以在组件中通过 this.$http 访问**</span>

app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="ref-的使用" tabindex="-1"> ref 的使用</h3>
<p>ref 是用于辅助开发者获得 DOM 元素或者组件的引用的。（不建议使用 jQuery 获取 DOM 元素，建议使用 ref）</p>
<h4 id="使用-ref-获取-dom-元素" tabindex="-1"> 使用 ref 获取 DOM 元素</h4>
<p>vue 在每个组件的引用中(this)都添加了一个<code>$refs</code>的属性，这个属性默认指向一个空对象，若开发者需要获取某个 DOM 元素，可以为该 DOM 元素添加属性 <code>ref=”name1”</code>，则可以使用 <code>this.$refs.name1</code> 获取该 DOM 元素的引用。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span> <span>ref</span><span><span>=</span><span>"</span>myh1<span>"</span></span><span>></span></span><span>lalala</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span>
export default {
    methods: {
        getRefs() {
            console.log(this.$refs.myh1);
        },
    },
}
</span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="使用-ref-引用组件实例" tabindex="-1"> 使用 ref 引用组件实例</h4>
<div><pre><code><span>&lt;</span><span>!</span><span>--</span> 给组件添加属性 ref <span>--</span><span>></span>
<span><span><span>&lt;</span>my-counter</span> <span>ref</span><span><span>=</span><span>"</span>counterRef<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>my-counter</span><span>></span></span>

console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$refs<span>.</span>counterRef<span>)</span><span>;</span>
<span>this</span><span>.</span>$refs<span>.</span>counterRef<span>.</span><span>add</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="要引用的对象还没有渲染怎么办-使用-nexttick-callback-方法" tabindex="-1"> 要引用的对象还没有渲染怎么办？使用 $.nextTick(callback) 方法</h4>
<p>组件的 <code>$nextTick(cb)</code> 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行。</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>inputVisible<span>"</span></span> <span>ref</span><span><span>=</span><span>"</span>ipt<span>"</span></span><span>></span></span><span>
&lt;button v-else @click="showInput">展示input输入框</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>

methods: </span><span>{</span>
    <span>showInput</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>inputVisible <span>=</span> <span>true</span><span>;</span>
        <span>this</span><span>.</span><span>$nextTick</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>$refs<span>.</span>ipt<span>.</span><span>focus</span><span>(</span><span>)</span><span>;</span> <span>// 若不使用 $nextTick 则找不到这个 ipt</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span><span>
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="动态组件" tabindex="-1"> 动态组件</h3>
<div><p>相关信息</p>
<p>动态组件指的是动态切换组件的显示和隐藏。vue 提供了一个内置的<code>&lt;component&gt;</code> 组件，专门用来实现组件的动态渲染。</p>
</div>
<ol>
<li><code>&lt;component&gt;</code> 是组件的占位符</li>
<li>通过 is 属性动态指定要渲染的组件名称</li>
<li><code>&lt;component is=”要渲染的组件的名称”&gt;&lt;/component&gt;</code></li>
</ol>
<h4 id="使用-keep-alive-保持组件状态" tabindex="-1"> 使用 keep-alive 保持组件状态</h4>
<p>使用<code>&lt;component&gt;</code>时，若切换成其他组件，则原本的组件将会被销毁，其状态无法保持，可以使用<code>&lt;keep-alive&gt;</code>标签将<code>&lt;component&gt;</code>进行包裹，以保持切换走的组件的状态。</p>
<div><pre><code><span><span><span>&lt;</span>keep-alive</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>component</span> <span>:is</span><span><span>=</span><span>"</span>comName<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>keep-alive</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="插槽" tabindex="-1"> 插槽</h3>
<div><p>相关信息</p>
<p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望用户指定的部分</strong>定义为插槽。</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/vZewR9.png" alt="vZewR9" loading="lazy"></p>
<p>可以把插槽认为是组件封装期间，为用户预留的<strong>内容的占位符</strong>。</p>
<h4 id="插槽的基础用法" tabindex="-1"> 插槽的基础用法</h4>
<p>在封装组件时，可以通过<code>&lt;slot&gt;</code>元素定义插槽，在使用时组件标签包裹的内容将会插入到插槽中。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是组件MyCom1的第一个p标签</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>slot</span><span>></span></span><span><span><span>&lt;/</span>slot</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是组件MyCom1的第二个p标签</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span><span>MyCom1</span></span><span>></span></span><span>
    </span><span><span><span>&lt;</span>p</span><span>></span></span><span>这是用户自定义的内容</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
</span><span><span><span>&lt;/</span><span>MyCom1</span></span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>若没有定义插槽，则组件包裹的任何内容都会被丢弃。</p>
</div>
<h4 id="插槽的后备内容" tabindex="-1"> 插槽的后备内容</h4>
<p>通过<code>&lt;slot&gt;</code>元素定义插槽时，可以在其中定义后备内容，若用户未提供自定义内容，则显示后备内容。</p>
<h4 id="具名插槽" tabindex="-1"> 具名插槽</h4>
<p>如果在封装组件时需要预留多个插槽节点，则需要为每个<code>&lt;slot&gt;</code>插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/nWdPi4.png" alt="nWdPi4" loading="lazy"></p>
<div><p>相关信息</p>
<p>没有 name 名称的插槽会有隐含的名称叫做“default”</p>
</div>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/eGacvB.png" alt="eGacvB" loading="lazy"></p>
<div><p>相关信息</p>
<p><code>v-slot:</code>可以简写为<code>#</code>，即<code>v-slot:header</code> → <code>#header</code></p>
</div>
<h4 id="作用域插槽" tabindex="-1"> 作用域插槽</h4>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/I0YDN5.png" alt="I0YDN5" loading="lazy"></p>
<p>省略了插槽的 props 属性的介绍，有缘再见吧。</p>
<h3 id="自定义指令" tabindex="-1"> 自定义指令</h3>
<p>vue 官方提供了 v-for, v-model 等常用的内置指令。除此之外，vue 还允许开发者自定义指令。</p>
<p>我想省略了 orz。</p>
<h2 id="vue-路由" tabindex="-1"> vue 路由</h2>
<h3 id="前端路由的概念与原理" tabindex="-1"> 前端路由的概念与原理</h3>
<p>路由就是<strong>对应关系</strong>。路由分为两大类：</p>
<ol>
<li>后端路由：后端路由指的是<strong>请求方法、请求地址</strong>与<strong>function 处理函数</strong>之间的<strong>对应关系</strong>。</li>
<li>前端路由：前端路由指的是<strong>Hash 地址</strong>与<strong>组件</strong>之间的<strong>对应关系</strong>。</li>
</ol>
<div><p>相关信息</p>
<p>在 SPA 中，web 网站只有唯一的一个 HTML 页面，<strong>所有组件的展示与切换</strong>都在这为一的一个页面内完成。此时，<strong>不同组件之间的切换</strong>需要通过<strong>前端路由</strong>来实现。</p>
</div>
<h4 id="前端路由的工作方式" tabindex="-1"> 前端路由的工作方式</h4>
<ol>
<li>用户点击了页面上的路由地址</li>
<li>导致了 URL 地址栏中的 Hash 值发生了变化</li>
<li>前端路由监听到了 Hash 地址的变化</li>
<li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/HbwSnR.png" alt="HbwSnR" loading="lazy"></p>
<h4 id="实现简易的前端路由" tabindex="-1"> 实现简易的前端路由</h4>
<ol>
<li>导入并注册 MyHome、MyMovie、MyAbout 三个组件：</li>
</ol>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>components</span><span>:</span> <span>{</span>
    MyHome<span>,</span>
    MyMovie<span>,</span>
    MyAbout<span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>通过<code>&lt;component&gt;</code>标签的 is 属性，动态切换要显示的组件：</li>
</ol>
<div><pre><code><span><span><span>&lt;</span>component</span> <span>:is</span><span><span>=</span><span>"</span>comName<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>component</span><span>></span></span>

<span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
        <span>comName</span><span>:</span> <span>'my-home'</span><span>,</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li>在组件的结构中声明如下 3 个<code>&lt;a&gt;</code>连接，通过点击不同的<code>&lt;a&gt;</code>连接，切换浏览器地址栏中的 Hash 值：</li>
</ol>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/home<span>"</span></span><span>></span></span><span>Home</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/movie<span>"</span></span><span>></span></span><span>Movie</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#/about<span>"</span></span><span>></span></span><span>About</span><span><span><span>&lt;/</span>a</span><span>></span></span> <span>&amp;</span> nbsp<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><ol start="4">
<li>在 created 生命周期函数中监听浏览器地址栏中 Hash 地址的变化，动态切换要展示的组件的名称：</li>
</ol>
<div><pre><code><span>created</span><span>(</span><span>)</span> <span>{</span>
    window<span>.</span><span>onhashchange</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>switch</span> <span>(</span>location<span>.</span>hash<span>)</span> <span>{</span>
            <span>case</span> <span>'#/home'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-home'</span><span>,</span>
                <span>break</span>
            <span>case</span> <span>'#/movie'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-movie'</span><span>,</span>
                <span>break</span>
            <span>case</span> <span>'#/about'</span><span>:</span>
                <span>this</span><span>.</span>comName <span>=</span> <span>'my-about'</span><span>,</span>
                <span>break</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="vue-router-的基本使用" tabindex="-1"> vue-router 的基本使用</h3>
<div><p>相关信息</p>
<p>vue-router 是 vue 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换。</p>
</div>
<ul>
<li>vue-router 3.x：对应 vue2.x ：<a href="https://router.vuejs.org/zh" target="_blank" rel="noopener noreferrer">https://router.vuejs.org/zh</a></li>
<li>vue-router 4.x：对应 vue 3.x ：<a href="https://next.router.vuejs.org" target="_blank" rel="noopener noreferrer">https://next.router.vuejs.org</a></li>
</ul>
<h4 id="vue-router4-x-的基本使用步骤" tabindex="-1"> vue-router4.x 的基本使用步骤</h4>
<ul>
<li>
<p><strong>在项目中安装 vue-router</strong></p>
<div><pre><code>npm install vue<span>-</span>router@next <span>-</span><span>S</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong>定义路由组件</strong>
就是定义自己的组件，如 MyHome.vue, MyMovie.vue, MyAbout.vue</p>
</li>
<li>
<p><strong>声明路由链接与占位符</strong>
可以使用<code>&lt;router-link&gt;</code>标签来声明路由链接，并使用<code>&lt;router-view&gt;</code>标签来声明路由占位符。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> App 组件 </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
  &lt;!-- 声明路由链接 -->
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/home<span>"</span></span><span>></span></span><span>首页</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span> &lt;!-- 不需要加井号啦 -->
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/movie<span>"</span></span><span>></span></span><span>电影</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span><span>关于</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>

  &lt;!-- 声明路由占位符 -->
  </span><span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>创建路由模块</strong>
在项目中创建 router.js 路由模块，在其中按照如下 4 个步骤创建并得到路由的实例对象：</p>
<ol>
<li>从 vue-router 中按需导入两个方法</li>
<li>导入需要使用路由控制的组件</li>
<li>创建路由实例对象</li>
<li>向外共享路由实例对象</li>
<li>在 main.js 中导入并挂载路由模块</li>
</ol>
<div><pre><code><span>import</span> <span>{</span> createRouter<span>,</span> createWebHashHistory <span>}</span> <span>from</span> <span>'vue-router'</span>  <span>// 1.</span>

<span>import</span> MyHome <span>from</span> <span>'./MyHome.vue'</span>  <span>// 2.</span>
<span>import</span> MyMovie <span>from</span> <span>'./MyMovie.vue'</span>
<span>import</span> MyAbout <span>from</span> <span>'./MyAbout.vue'</span>

<span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>  <span>// 3.</span>
  <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
  <span>routes</span><span>:</span> <span>[</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
      <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>

<span>export</span> <span>default</span> router<span>;</span>  <span>// 4.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>导出并挂载路由模块</p>
<div><pre><code><span>// main.js</span>
<span>// ...</span>
<span>import</span> router <span>from</span> <span>"./router"</span><span>;</span>
<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>)</span><span>;</span> <span>// 5.</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ul>
<h3 id="vue-router-的高级用法" tabindex="-1"> vue-router 的高级用法</h3>
<h4 id="路由重定向" tabindex="-1"> 路由重定向</h4>
<div><p>相关信息</p>
<p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C，从而展示特定的组件页面。</p>
</div>
<p>通过路由规则的 redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向：</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>  <span>// 3.</span>
    <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
    <span>routes</span><span>:</span> <span>[</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
        <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="为激活的路由链接设置高亮样式" tabindex="-1"> 为激活的路由链接设置高亮样式</h4>
<ol>
<li>
<p><strong>默认的高亮 class 类</strong>：被激活的路由链接，默认会应用一个叫做 router-link-active 的类名。开发者可以使用此类名选择器，为激活的路由链接设置高亮样式：</p>
<div><pre><code><span>/* index.css */</span>
<span>.router-link-active</span> <span>{</span>
  <span>background-color</span><span>:</span> red<span>;</span>
  <span>color</span><span>:</span> white<span>;</span>
  <span>font-weight</span><span>:</span> bold<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>自定义路由高亮的 class 类</strong>：开发者可以基于 linkActiveClass 属性，自定义路由链接被激活时所应用的类名：</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>
 <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
 <span>linkActiveClass</span><span>:</span> <span>'router-active'</span><span>,</span>
 <span>routes</span><span>:</span> <span>[</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/about'</span><span>,</span> <span>component</span><span>:</span> MyAbout <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h4 id="嵌套路由" tabindex="-1"> 嵌套路由</h4>
<p>通过路由实现组件的嵌套展示，叫做嵌套路由。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/um5ec9.png" alt="um5ec9" loading="lazy"></p>
<ol>
<li>
<p>声明子路由链接和子路由占位符（声明在子组件内部即可）</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>MyAbout 组件</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>

    </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about/tab1<span>"</span></span><span>></span></span><span>Tab1</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about/tab2<span>"</span></span><span>></span></span><span>Tab2</span><span><span><span>&lt;/</span>router-link</span><span>></span></span><span>

    </span><span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>在父路由规则中，通过 children 属性嵌套声明子路由规则</p>
<div><pre><code><span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span>
 <span>history</span><span>:</span> <span>createWebHashHistory</span><span>(</span><span>)</span><span>,</span>
 <span>linkActiveClass</span><span>:</span> <span>'router-active'</span><span>,</span>
 <span>routes</span><span>:</span> <span>[</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/'</span><span>,</span> <span>**</span>redirect<span>:</span> <span>'/home'</span><span>**</span> <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/home'</span><span>,</span> <span>component</span><span>:</span> MyHome <span>}</span><span>,</span>
     <span>{</span> <span>path</span><span>:</span> <span>'/movie'</span><span>,</span> <span>component</span><span>:</span> MyMovie <span>}</span><span>,</span>
     <span>{</span>
         <span>path</span><span>:</span> <span>'/about'</span><span>,</span>
         <span>component</span><span>:</span> MyAbout<span>,</span>
         <span>**</span>redirect<span>:</span> <span>'/about/tab1'</span><span>,</span><span>**</span> <span>// 访问 /about 时就直接显示 tab1</span>
         <span>**</span>children<span>:</span> <span>[</span>
             <span>{</span> <span>path</span><span>:</span> <span>'tab1'</span><span>,</span> <span>component</span><span>:</span> Tab1 <span>}</span><span>,</span><span>**</span> <span>// 访问 /about/tab1 时展示 Tab1</span>
             <span>**</span><span>{</span> <span>path</span><span>:</span> <span>'tab2'</span><span>,</span> <span>component</span><span>:</span> Tab2 <span>}</span><span>,</span>
         <span>]</span><span>,</span><span>**</span>
     <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h4 id="动态路由匹配" tabindex="-1"> 动态路由匹配</h4>
<div><p>相关信息</p>
<p>动态路由指的是：把 Hash 地址中的<strong>可变部分</strong>定义为<strong>参数项</strong>，从而提高路由规则的可复用性。</p>
</div>
<p>在 vue-router 中使用英文的冒号（:）来定义路由的参数：</p>
<div><pre><code><span>{</span> <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>

<span>{</span> <span>path</span><span>:</span> <span>'/movie/1'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
<span>{</span> <span>path</span><span>:</span> <span>'/movie/2'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
<span>{</span> <span>path</span><span>:</span> <span>'/movie/3'</span><span>,</span> <span>component</span><span>:</span> Movie <span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>使用 <code>$route.params</code> 对象获取动态匹配的参数值。</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> id：</span><span>{</span><span>{</span> $route<span>.</span>params<span>.</span>id <span>}</span><span>}</span><span> </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用 <code>props</code> 接收路由参数，需要在路由规则中开启：</p>
<div><pre><code><span>{</span> <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span> <span>component</span><span>:</span> Movie<span>,</span> <span>**</span>props<span>:</span> <span>true</span><span>**</span> <span>}</span>

<span><span><span>&lt;</span>template</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h1</span><span>></span></span><span> id：</span><span>{</span><span>{</span> id <span>}</span><span>}</span><span> </span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>

<span>export</span> <span>default</span> <span>{</span>
    <span>name</span><span>:</span> <span>'MyMovie'</span><span>,</span>
    <span>props</span><span>:</span> <span>[</span><span>'id'</span><span>]</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="编程式导航" tabindex="-1"> 编程式导航</h4>
<div><p>相关信息</p>
<p>编程式导航 vs 声明式导航：通过调用 API（调用 location.href）实现导航的方式叫做编程式导航，而通过点击链接（a 标签）实现导航的方式称为声明式导航。</p>
</div>
<p><strong>vue-router 中的编程式导航 API</strong></p>
<ul>
<li>this.$router.push(’hash 地址’)：跳转到指定的 hash 地址</li>
<li>this.$router.go(数值 n)：实现导航历史的前进、后退（-1）</li>
</ul>
<div><pre><code><span>gotoMovie</span><span>(</span><span>id</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>$router<span>.</span><span>push</span><span>(</span><span><span>`</span><span>/movie/</span><span><span>${</span>id<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h4 id="命名路由" tabindex="-1"> 命名路由</h4>
<p>通过 name 属性为路由规则定义名称的方式，叫做命名路由：</p>
<div><pre><code><span>{</span>
    <span>path</span><span>:</span> <span>'/movie/:id'</span><span>,</span>
    <span>name</span><span>:</span> <span>'mov'</span><span>,</span>
    <span>component</span><span>:</span> Movie<span>,</span>
    <span>props</span><span>:</span> <span>true</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：命名路由的 name 值不能重复。</p>
<p>使用命名路由可以在<code>&lt;router-link&gt;</code>中直接使用其名称，而不用显示地写 hash 地址：</p>
<div><pre><code><span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>"</span>{ name: 'mov', params: { id: 3 } }<span>"</span></span><span>></span></span><span>go to Movie</span><span><span><span>&lt;/</span>router-link</span><span>></span></span>

<span>this</span><span>.</span>$router<span>.</span><span>push</span><span>(</span><span>{</span>
    <span>name</span><span>:</span> <span>'mov'</span><span>,</span>
    <span>params</span><span>:</span> <span>{</span> <span>id</span><span>:</span> <span>3</span> <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="导航守卫" tabindex="-1"> 导航守卫</h4>
<p>导航守卫可以控制路由的访问权限。</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/iSrYhO.png" alt="iSrYhO" loading="lazy"></p>
<h3 id="如何声明全局导航守卫" tabindex="-1"> 如何声明全局导航守卫</h3>
<p><strong>全局导航守卫</strong>会<strong>拦截每个路由规则</strong>，从而对每个路由进行<strong>访问权限</strong>的控制。可以按照如下的方式定义全局导航守卫：</p>
<div><pre><code><span>// 创建路由实例对象</span>
<span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>{</span> <span>...</span> <span>}</span><span>)</span>

<span>// 调用路由实例对象的 beforeEach 函数，声明“全局前置守卫”</span>
<span>// fn 必须是一个函数，每次拦截到路由的请求，都会调用 fn 进行处理</span>
<span>// 因此 fn 叫做 “守卫方法”</span>
router<span>.</span><span>beforeEach</span><span>(</span>fn<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="守卫方法的-3-个参数" tabindex="-1"> 守卫方法的 3 个参数</h4>
<p>全局导航守卫的守卫方法中接收 3 个形参，格式为：</p>
<div><pre><code>router<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>// to 目标路由对象</span>
  <span>// from 当前导航要离开的路由对象</span>
  <span>// next 时一个函数，表示放行</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>如果不接收第 3 个形参，则默认允许用户访问每一个路由。如果接收了 next 形参，则必须调用 next()函数，否则不允许用户访问该路由。</p>
</div>
<p>next 函数的 3 种调用方式：</p>
<ul>
<li>直接放行：next()</li>
<li>强制其停留在当前页面：next(false)</li>
<li>强制其跳转到登录页面：next(’/login’)</li>
</ul>
<h4 id="结合-token-控制后台主页的访问权限" tabindex="-1"> 结合 token 控制后台主页的访问权限</h4>
<div><pre><code>router<span>.</span><span>beforeEach</span><span>(</span><span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> token <span>=</span> localStorage<span>.</span><span>getItem</span><span>(</span><span>"token"</span><span>)</span><span>;</span> <span>// 1. 读取 token</span>
  <span>if</span> <span>(</span>to<span>.</span>path <span>===</span> <span>"/main"</span> <span>&amp;&amp;</span> <span>!</span>token<span>)</span> <span>{</span>
    <span>// 2. 想要访问“后台主页”，且 token 不存在</span>
    <span>// next(false);  // 3.1 不允许跳转</span>
    <span>next</span><span>(</span><span>"/login"</span><span>)</span><span>;</span> <span>// 3.2 强制跳转到“登录页面”</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>next</span><span>(</span><span>)</span><span>;</span> <span>// 3.3 直接放行，允许访问“后台主页”</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="vue-项目的创建" tabindex="-1"> vue 项目的创建</h2>
<h3 id="如何快速创建-vue-的-spa-项目" tabindex="-1"> 如何快速创建 vue 的 SPA 项目</h3>
<ol>
<li>基于 vite 创建 SPA 项目
<ul>
<li>仅支持 3.x</li>
<li>不基于 webpack</li>
<li>速度快</li>
<li>小而巧</li>
</ul>
</li>
<li>给予 vue-cli 创建 SPA 项目
<ul>
<li>支持 2.x 与 3.x</li>
<li>基于 webpack</li>
<li>较慢</li>
<li>大而全</li>
</ul>
</li>
</ol>
<div><pre><code><span>npm</span> init vite-app code1  <span># 创建一个vite项目，命名为code1</span>
<span>cd</span> code1
<span>npm</span> <span>install</span>  <span># 安装依赖包</span>
<span>npm</span> run dev  <span># 启动项目</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="vite-的基本使用" tabindex="-1"> vite 的基本使用</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/ZG3kP3.png" alt="ZG3kP3" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/yITax7.png" alt="yITax7" loading="lazy"></p>
<h4 id="vite-项目的运行流程" tabindex="-1"> vite 项目的运行流程</h4>
<p>在工程化的项目中，vue 要做的事情很单纯：通过 <code>main.js</code> 把 <code>App.vue</code> 渲染到 <code>index.html</code> 的指定区域中。</p>
<p>其中：</p>
<ol>
<li><code>App.vue</code> 用来编写待渲染的模板结构</li>
<li><code>index.html</code> 中需要预留一个 <code>el</code> 区域</li>
<li><code>main.js</code> 把 <code>App.vue</code> 渲染到了 <code>index.html</code> 所预留的区域中</li>
</ol>
<h4 id="app-vue" tabindex="-1"> App.vue</h4>
<div><pre><code><span>// 需要使用&lt;template>标签把组件包围</span>
<span><span><span>&lt;</span>template</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>hello world</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h4 id="main-js" tabindex="-1"> main.js</h4>
<div><pre><code><span>// 1. 按需导入 createApp 函数</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>// 2. 导入待渲染的 App.vue 组件</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>// 3. 调用 createApp 函数，创建 SPA 应用的实例</span>
<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

<span>// 4. 调用 mount() 把 App 组件的模版结构，渲染到指定的 el 区域中</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><a href="/code/frontend/vue_todos.html">Todos - Vite 项目案例</a></p>
<h3 id="vue-cli-的使用" tabindex="-1"> vue-cli 的使用</h3>
<p><a href="http://cli.vuejs.org/zh" target="_blank" rel="noopener noreferrer">Vue CLI</a></p>
<h4 id="基于-vue-ui-创建-vue-项目" tabindex="-1"> 基于 vue ui 创建 vue 项目</h4>
<ol>
<li>运行 <code>vue ui</code> 命令，自动在浏览器中打开创建项目的可视化面板。</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/CALMwI.png" alt="CALMwI" loading="lazy"></p>
<ol start="2">
<li>填写项目名称</li>
<li>在预设页面选择手动配置项目</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/xHZnib.png" alt="xHZnib" height="300" loading="lazy"></p>
<ol start="4">
<li>在功能页面勾选需要安装的功能</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/rwl84Y.png" alt="rwl84Y" loading="lazy"></p>
<ol start="5">
<li>在配置页面勾选 vue 的版本和需要的预处理器</li>
</ol>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/cl0cMR.png" alt="cl0cMR" loading="lazy"></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/WSUYun.png" alt="WSUYun" loading="lazy"></p>
<h4 id="基于命令行创建-vue-项目" tabindex="-1"> 基于命令行创建 vue 项目</h4>
<div><pre><code>vue create my<span>-</span>project
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="vue-组件库" tabindex="-1"> vue 组件库</h2>
<h3 id="什么是-vue-组件库" tabindex="-1"> 什么是 vue 组件库</h3>
<p>在实际开发中，前端开发者可以把自己封装的.vue 组件整理、打包、并发布为 npm 的包，从而供其他人下载和使用。这种可以直接下载并在项目中使用的现成组件，就叫做 vue 组件库。</p>
<h3 id="vue-组件库与-bootstrap-的区别" tabindex="-1"> vue 组件库与 bootstrap 的区别</h3>
<ul>
<li>bootstrap 只提供了纯粹的原材料（css 样式、HTML 结构以及 JS 特效），需要由开发者做进一步的组装和改造。</li>
<li>vue 组件库是遵循 vue 语法、高度定制的现成组件，开箱即用的。</li>
</ul>
<h3 id="最常用的-vue-组件库" tabindex="-1"> 最常用的 vue 组件库</h3>
<ul>
<li>PC 端
<ul>
<li>Element UI</li>
<li>View UI</li>
</ul>
</li>
<li>移动端
<ul>
<li>Mint UI</li>
<li>Vant</li>
</ul>
</li>
</ul>
<h3 id="element-ui" tabindex="-1"> Element UI</h3>
<div><p>提示</p>
<p>是由饿了么前端团队开源的一套 PC 端 vue 组件库。</p>
</div>
<ul>
<li>vue2 使用旧版的 Element UI</li>
<li>vue3 使用新版的 <a href="https://element-plus.gitee.io/zh-CN/guide/design.html" target="_blank" rel="noopener noreferrer">Element Plus</a></li>
</ul>
<h4 id="安装" tabindex="-1"> 安装</h4>
<div><pre><code>npm install element<span>-</span>plus <span>--</span>save
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="引入-element-ui" tabindex="-1"> 引入 element-ui</h4>
<ul>
<li>完整引入：操作简单，但体积过大</li>
<li>按需引入：操作复杂，优化体积</li>
</ul>
<h5 id="完整引入" tabindex="-1"> 完整引入</h5>
<div><pre><code><span>// main.ts</span>
<span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"vue"</span><span>;</span>
<span>import</span> ElementPlus <span>from</span> <span>"element-plus"</span><span>;</span>
<span>import</span> <span>"element-plus/dist/index.css"</span><span>;</span>
<span>import</span> App <span>from</span> <span>"./App.vue"</span><span>;</span>

<span>const</span> app <span>=</span> <span>createApp</span><span>(</span>App<span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span>ElementPlus<span>)</span><span>;</span>
app<span>.</span><span>mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h5 id="按需引入" tabindex="-1"> 按需引入</h5>
<p>自动导入（推荐）</p>
<div><pre><code>npm install <span>-</span><span>D</span> unplugin<span>-</span>vue<span>-</span>components unplugin<span>-</span>auto<span>-</span><span>import</span>

<span>// webpack.config.js</span>
<span>const</span> AutoImport <span>=</span> <span>require</span><span>(</span><span>'unplugin-auto-import/webpack'</span><span>)</span>
<span>const</span> Components <span>=</span> <span>require</span><span>(</span><span>'unplugin-vue-components/webpack'</span><span>)</span>
<span>const</span> <span>{</span> ElementPlusResolver <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'unplugin-vue-components/resolvers'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// ...</span>
  <span>plugins</span><span>:</span> <span>[</span>
    <span>AutoImport</span><span>(</span><span>{</span>
      <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
    <span>}</span><span>)</span><span>,</span>
    <span>Components</span><span>(</span><span>{</span>
      <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
    <span>}</span><span>)</span><span>,</span>
  <span>]</span><span>,</span>
<span>}</span>

<span>**</span><span>// 或者对于vue-cli项目，修改vue.config.js**</span>
<span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"@vue/cli-service"</span><span>)</span><span>;</span>

<span>const</span> AutoImport <span>=</span> <span>require</span><span>(</span><span>"unplugin-auto-import/webpack"</span><span>)</span><span>;</span>
<span>const</span> Components <span>=</span> <span>require</span><span>(</span><span>"unplugin-vue-components/webpack"</span><span>)</span><span>;</span>
<span>const</span> <span>{</span> ElementPlusResolver <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"unplugin-vue-components/resolvers"</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>configureWebpack</span><span>:</span> <span>{</span>
    <span>plugins</span><span>:</span> <span>[</span>
      <span>AutoImport</span><span>(</span><span>{</span>
        <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
      <span>}</span><span>)</span><span>,</span>
      <span>Components</span><span>(</span><span>{</span>
        <span>resolvers</span><span>:</span> <span>[</span><span>ElementPlusResolver</span><span>(</span><span>)</span><span>]</span><span>,</span>
      <span>}</span><span>)</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>手动导入（不推荐就不写啦）</p>
<h2 id="axios-vue" tabindex="-1"> axios+vue</h2>
<ul>
<li>axios 回调函数中的 <code>this</code> 已经改变，无法访问到 <code>data</code> 中数据</li>
<li>把 <code>this</code> 保存起来，回调函数中直接使用保存的 <code>this</code> 即可</li>
</ul>
<div><pre><code><span>var</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>joke</span><span>:</span> <span>"lala"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>getJoke</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>var</span> that <span>=</span> <span>this</span><span>;</span> <span>// 这里先保存this，在回调函数中this将会变化</span>
      axios<span>.</span><span>get</span><span>(</span><span>"https://autumnfish.cn/api/joke"</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>response</span><span>)</span> <span>{</span>
        that<span>.</span>joke <span>=</span> response<span>.</span>data<span>;</span> <span>// 这里的this已经变化，使用事先保存的that</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="配置全局-axios" tabindex="-1"> 配置全局 axios</h3>
<p>vue2.x</p>
<div><pre><code><span>// main.js</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> App <span>from</span> <span>'./App.vue'</span>
<span>import</span> router <span>from</span> <span>'./router'</span>
<span>import</span> store <span>from</span> <span>'./store'</span>

<span>import</span> <span>"@picocss/pico/css/pico.min.css"</span>

Vue<span>.</span>config<span>.</span>productionTip <span>=</span> <span>false</span>

<span>**</span><span>// 全局配置axios</span>
<span>import</span> axios <span>from</span> <span>"axios"</span><span>;</span>
axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>'http://localhost:8080'</span><span>;</span>
<span>Vue</span><span>.</span>prototype<span>.</span>$axios <span>=</span> axios<span>;</span><span>**</span>

<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  router<span>,</span>
  store<span>,</span>
  <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span>
<span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span><span>'#app'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="解决跨域问题" tabindex="-1"> 解决跨域问题</h3>
<ul>
<li>使用一个代理服务器来解决跨域问题（这个代理服务器部署在 vue 相同的端口）</li>
<li>将 baseURL 改为 vue 项目的运行地址，因此不存在跨域</li>
<li>当 vue 发现请求的接口不存在，把请求转交给 proxy 代理</li>
<li>代理把请求的根路径替换为 devServer.proxy 属性的值，发起真正的请求</li>
<li>代理把请求到的数据，转发给 axios</li>
</ul>
<div><pre><code><span>**</span>axios<span>.</span>defaults<span>.</span>baseURL <span>=</span> <span>'http://localhost:8080'</span><span>;</span>  <span>// baseURL设置为vue的服务器地址**</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>// vue.config.js</span>
<span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'@vue/cli-service'</span><span>)</span>
module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>**</span>devServer<span>:</span> <span>{</span>
    <span>proxy</span><span>:</span> <span>{</span>
      <span>'/api'</span><span>:</span> <span>{</span>
        <span>target</span><span>:</span> <span>'http://localhost:9012'</span><span>,</span>  <span>// 这里才是真正的api域名</span>
        <span>changeOrigin</span><span>:</span> <span>true</span><span>,</span>
        <span>pathRewrite</span><span>:</span><span>{</span>  <span>// 路径重写，</span>
          <span>'^/api'</span><span>:</span> <span>'/api'</span>  <span>// 把 /api 替换成 /api，也就是不替换！</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>**</span>
<span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/1Ku8ff.png" alt="1Ku8ff" loading="lazy"></p>
<h2 id="部署-vue-项目到-docker" tabindex="-1"> 部署 vue 项目到 docker</h2>
<p><a href="https://cli.vuejs.org/guide/deployment.html#docker-nginx" target="_blank" rel="noopener noreferrer">Deployment | Vue CLI</a></p>
<h2 id="设置-https" tabindex="-1"> 设置 HTTPS</h2>
<p>vue.config.js</p>
<div><pre><code><span>const</span> <span>{</span> defineConfig <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"@vue/cli-service"</span><span>)</span><span>;</span>
module<span>.</span>exports <span>=</span> <span>defineConfig</span><span>(</span><span>{</span>
  <span>transpileDependencies</span><span>:</span> <span>true</span><span>,</span>
  <span>devServer</span><span>:</span> <span>{</span>
    <span>https</span><span>:</span> <span>{</span>
      <span>cert</span><span>:</span> <span>"/Users/timpcfan/cert/localhost.pem"</span><span>,</span>
      <span>key</span><span>:</span> <span>"/Users/timpcfan/cert/localhost-key.pem"</span><span>,</span>
    <span>}</span><span>,</span>
    <span>proxy</span><span>:</span> <span>{</span>
      <span>"/api"</span><span>:</span> <span>{</span>
        <span>target</span><span>:</span> <span>"https://localhost:9012"</span><span>,</span>
        <span>changeOrigin</span><span>:</span> <span>true</span><span>,</span>
        <span>pathRewrite</span><span>:</span> <span>{</span>
          <span>// 路径重写，</span>
          <span>"^/api"</span><span>:</span> <span>"/api"</span><span>,</span> <span>// 把 /api 替换成 /api</span>
        <span>}</span><span>,</span>
      <span>}</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="问题收集" tabindex="-1"> 问题收集</h2>
<h3 id="props-属性是只读的不能使用-v-model-怎么办" tabindex="-1"> props 属性是只读的不能使用 v-model 怎么办？</h3>
<p><a href="https://b23.tv/P8YRl6W" target="_blank" rel="noopener noreferrer">https://b23.tv/P8YRl6W</a></p>
<p>把它转存到 data 中，data 中的数据是可读可写的。</p>
<h2 id="案例收集" tabindex="-1"> 案例收集</h2>
<h3 id="计数器" tabindex="-1"> 计数器</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>基础</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      &lt;button @click="sub">-</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-text</span><span><span>=</span><span>"</span>count<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span>
      &lt;button @click="add">+</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          count: 0,
        },
        methods: {
          add: function () {
            if (this.count &lt; 10) {
              this.count++;
            } else {
              alert("已达到最大值");
            }
          },
          sub: function () {
            if (this.count > 0) {
              this.count--;
            } else {
              alert("已达到最小值");
            }
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="图片切换" tabindex="-1"> 图片切换</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>图片切换</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-text</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span>&lt;button @click="nextImg">NEXT</span><span><span><span>&lt;/</span>button</span><span>></span></span><span><span><span>&lt;</span>br</span> <span>/></span></span><span>
      </span><span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>"</span>imgList[curIdx]<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          title: "",
          curIdx: 0,
          imgList: [
            "https://images.unsplash.com/photo-1546508428-f76b668cc812?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1222&amp;q=80",
            "https://images.unsplash.com/photo-1546417492-0e81e5e9d161?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80",
            "https://images.unsplash.com/photo-1546884680-a1de22e94d50?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80",
            "https://images.unsplash.com/photo-1544946632-b73cacef16ad?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1332&amp;q=80",
            "https://images.unsplash.com/photo-1548561711-73eae96ad48d?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=991&amp;q=80",
            "https://images.unsplash.com/photo-1545557800-740d9fe3524a?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1074&amp;q=80",
            "https://images.unsplash.com/photo-1540202404-d0c7fe46a087?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1333&amp;q=80",
            "https://images.unsplash.com/photo-1548604303-af502df13131?ixlib=rb-1.2.1&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=1170&amp;q=80",
          ],
        },
        methods: {
          nextImg: function () {
            this.curIdx = (this.curIdx + 1) % this.imgList.length;
            console.log(this.curIdx);
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="记事本" tabindex="-1"> 记事本</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span><span>
  </span><span><span><span>&lt;</span>head</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;</span>title</span><span>></span></span><span>记事本</span><span><span><span>&lt;/</span>title</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>head</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>body</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>记事本</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
      &lt;input type="text" v-model="taskName" @keyup.enter="addTask" />
      </span><span><span><span>&lt;</span>ul</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>(item, idx) in taskList<span>"</span></span><span>></span></span><span>
          </span><span>{</span><span>{</span>idx<span>+</span><span>1</span><span>}</span><span>}</span><span>. </span><span>{</span><span>{</span>item<span>}</span><span>}</span><span>&lt;button @click="removeTask(idx)">x</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
        </span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>ul</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>span</span> <span>v-if</span><span><span>=</span><span>"</span>taskList.length>0<span>"</span></span>
        <span>></span></span><span>{</span><span>{</span>taskList<span>.</span>length<span>}</span><span>}</span><span> items left
        &lt;button @click="clearAll">Clear</span><span><span><span>&lt;/</span>button</span><span>></span></span><span><span><span>&lt;/</span>span</span>
      <span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://unpkg.com/vue@2.6.14/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>script</span><span>></span></span><span>
      var app = new Vue({
        el: "#app",
        data: {
          taskName: "",
          taskList: [],
        },
        methods: {
          addTask: function () {
            this.taskList.push(this.taskName);
            this.taskName = "";
          },
          removeTask: function (id) {
            this.taskList.splice(id, 1);
          },
          clearAll: function () {
            this.taskList = [];
          },
        },
      });
    </span><span><span><span>&lt;/</span>script</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>body</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/AYFU9u.png" type="image/png"/>
    </item>
    <item>
      <title>前端工程化与Webpack</title>
      <link>https://timpcfan.site/code/frontend/webpack.html</link>
      <guid>https://timpcfan.site/code/frontend/webpack.html</guid>
      <source url="https://timpcfan.site/rss.xml">前端工程化与Webpack</source>
      <category>笔记</category>
      <category>前端</category>
      <pubDate>Mon, 03 Oct 2022 12:48:14 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="前端工程化" tabindex="-1"> 前端工程化</h2>
<div><p>前端工程化的四个「现代化」</p>
<ul>
<li>模块化（js 的模块化，css 的模块化，资源的模块化）</li>
<li>组件化（复用现有的 UI 结构，样式，行为）</li>
<li>规范化（目录结构的画风，编码规范化，接口规范化，文本规范化， Git 分支管理）</li>
<li>自动化（自动化构建，自动部署，自动化测试）</li>
</ul>
</div>
<h3 id="什么是前端开发工程化" tabindex="-1"> 什么是前端开发工程化？</h3>
<p>在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、标准化。</p>
<p>企业中的 Vue 项目和 React 项目，都是基于工程化的方式开发的。</p>
<h3 id="前端工程化的解决方案" tabindex="-1"> 前端工程化的解决方案</h3>
<p>目前流行的：</p>
<ul>
<li><a href="http://www.webpackjs.com" target="_blank" rel="noopener noreferrer">webpack</a></li>
<li><a href="http://zh.parceljs.org" target="_blank" rel="noopener noreferrer">parcel</a></li>
</ul>
<h2 id="webpack" tabindex="-1"> webpack</h2>
<div><p>提示</p>
<p>webpack 是前端项目工程化的具体解决方案，它提供了友好的<strong>前端模块化开发</strong>支持，以及<strong>代码压缩混淆</strong>、<strong>处理浏览器端 JavaScript 的兼容性</strong>、<strong>性能优化</strong>等强大的功能。</p>
</div>
<h3 id="创建一个-npm-的项目" tabindex="-1"> 创建一个 npm 的项目</h3>
<div><pre><code><span>npm</span> init <span>-y</span>  <span># 生成配置文件package.json</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="在项目中安装-webpack" tabindex="-1"> 在项目中安装 webpack</h3>
<div><pre><code><span>npm</span> i webpack@5.42.1 webpack-cli@4.7.2 <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中，<code>-D</code> 表示 <code>--save-dev</code>，将安装的包写入 <code>devDependencies</code> 中，表示开发时才会被利用到。默认为 <code>-S</code> 表示 <code>--save</code> ，将安装的包写入 <code>depedencies</code> 中，表示在开发以及生产环境中都会被用到。</p>
<h3 id="在项目中配置-webpack" tabindex="-1"> 在项目中配置 webpack</h3>
<ol>
<li>在项目根目录中，创建名为 <code>webpack.config.js</code> 的 webpack 配置文件，并初始化如下的基本配置：</li>
</ol>
<div><pre><code><span>// 使用 Node.js 中的导出语法，向外导出一个 webpack 的配置对象</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 代表 webpack 运行的模式，可选值为 development、production</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><ol start="2">
<li>在 <code>package.json</code> 的 <code>scripts</code> 节点下，新增 dev 脚本如下：</li>
</ol>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
	<span>"dev"</span><span>:</span> <span>"webpack"</span><span>,</span>  <span>// script 节点下的脚本，可以通过 npm run 执行，例如 npm run dev</span>
  <span>"build"</span><span>:</span> <span>"webpack --mode=production"</span>  <span>// 生产模式打包</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><ol start="3">
<li>在终端中运行 <code>npm run dev</code> 命令，启动 webpack 进行项目的打包构建</li>
</ol>
<div><p>提示</p>
<p>webpack 会将所有依赖的 js 文件都整合到一个 main.js 文件中，在 html 中应该直接引用整合后的 main.js 文件。</p>
</div>
<h3 id="webpack-中的默认约定" tabindex="-1"> webpack 中的默认约定</h3>
<p>在 webpack4.x 和 5.x 的版本中，有如下的默认约定：</p>
<ol>
<li>默认的打包入口文件为：src→index.js</li>
<li>默认的输出文件路径为：dist→main.js</li>
</ol>
<div><p>提示</p>
<p>注：可在 <code>webpack.config.js</code> 中修改打包的默认约定</p>
<p>通过 entry 节点指定打包的入口，通过 output 节点指定打包的出口。</p>
</div>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>"path"</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>entry</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"src/index.js"</span><span>)</span><span>,</span>
  <span>output</span><span>:</span> <span>{</span>
    <span>path</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"dist"</span><span>)</span><span>,</span>
    <span>filename</span><span>:</span> <span>"main.js"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="webpack-插件的使用" tabindex="-1"> webpack 插件的使用</h2>
<h3 id="一些常用的插件" tabindex="-1"> 一些常用的插件</h3>
<ol>
<li><strong>webpack-dev-server</strong>
<ul>
<li>每当修改了源代码，webpack 会自动进行项目的打包和构建</li>
</ul>
</li>
<li><strong>html-webpack-plugin</strong>
<ul>
<li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li>
<li>可以通过此插件自定义 index.html 页面的内容</li>
<li>插件生成的 html 页面中会自动注入了打包的 main.js 文件</li>
</ul>
</li>
</ol>
<h3 id="如何使用webpack-dev-server" tabindex="-1"> 如何使用<strong>webpack-dev-server</strong></h3>
<p>安装</p>
<div><pre><code><span>npm</span> i webpack-dev-server <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>修改 <code>package.json</code> 中的 <code>scripts</code> 的 <code>dev</code> 命令如下：</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
  <span>"dev"</span><span>:</span> <span>"webpack **serve**"</span>
<span>}</span><span>,</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>再次运行 <code>npm run dev</code> 命令，重新进行项目的打包</p>
<p>在浏览器中访问：<a href="http://localhost:8080" target="_blank" rel="noopener noreferrer">http://localhost:8080</a> 地址，查看自动打包效果</p>
<div><p>一些坑</p>
<ul>
<li>该插件自动打包生成的 js 文件是存储在内存中的，因此在物理磁盘路径下无法看见</li>
<li>该插件生成的 js 文件默认的位置是项目的根目录</li>
</ul>
</div>
<h3 id="如何使用-html-webpack-plugin" tabindex="-1"> 如何使用 html-webpack-plugin</h3>
<div><p>相关信息</p>
<p>为什么要用 html-webpack-plugin？</p>
<p>使用上面的插件时，访问 http://localhost:8080 地址，默认是打开根目录，但实际的项目入口在 src 文件夹中，因此希望将 src 文件夹中的 index.html 复制一份到根目录下，使得可以直接访问。</p>
</div>
<p>安装</p>
<div><pre><code><span>npm</span> i html-webpack-plugin <span>-D</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>配置</p>
<div><pre><code><span>// 1. 导入 HTML 插件</span>
<span>const</span> HtmlPlugin <span>=</span> <span>require</span><span>(</span><span>"html-webpack-plugin"</span><span>)</span><span>;</span>

<span>// 2. 创建 HTML 插件的实例对象</span>
<span>const</span> htmlPlugin <span>=</span> <span>new</span> <span>HtmlPlugin</span><span>(</span><span>{</span>
  <span>template</span><span>:</span> <span>"./src/index.html"</span><span>,</span> <span>// 指定原文件的路径</span>
  <span>filename</span><span>:</span> <span>"./index.html"</span><span>,</span> <span>// 指定生成文件的路径</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>plugins</span><span>:</span> <span>[</span>htmlPlugin<span>]</span><span>,</span> <span>// 3. 通过 plugins 节点，使 htmlPlugin 插件生效</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>启动时自动打开浏览器</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"development"</span><span>,</span>
  <span>devServer</span><span>:</span> <span>{</span>
    <span>open</span><span>:</span> <span>true</span><span>,</span> <span>// 自动打开浏览器</span>
    <span>host</span><span>:</span> <span>"127.0.0.1"</span><span>,</span> <span>// 实时打包使用的主机地址</span>
    <span>port</span><span>:</span> <span>8080</span><span>,</span> <span>//实时打包使用的端口号</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div>
<h3 id="webpack-中的-loader" tabindex="-1"> webpack 中的 loader</h3>
<div><p>提示</p>
<p>webpack 默认只能处理.js 文件，当遇到其他文件时它会寻找有没有对应的 loader 能够进行处理。例如，在处理 css 文件时，需要安装处理 css 文件的 loader。</p>
</div>
<p>安装 loader：</p>
<div><pre><code><span>npm</span> i style-loader css-loader <span>-D</span>
<span>npm</span> i less-loader - D  <span># 若要处理less文件</span>
<span>npm</span> i url-loader file-loader <span>-D</span> <span># 若要处理图片</span>
<span>npm</span> i babel-loader @babel/core @babel/plugin-proposal-decorators <span>-D</span> <span># 处理高级js语法</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>在 <code>webpack.config.js</code> 的 <code>module-&gt;rules</code> 数组中，添加 loader 规则如下：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>module</span><span>:</span> <span>{</span>
    <span>// 所有第三方文件模块匹配规则</span>
    <span>rules</span><span>:</span> <span>[</span>
      <span>// 文件后缀名的匹配规则</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"style-loader"</span><span>,</span> <span>"css-loader"</span><span>]</span> <span>}</span><span>,</span> <span>// 允许在js中使用 import 'xxx.css' 的方式导入css</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.less$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"style-loader"</span><span>,</span> <span>"css-loader"</span><span>,</span> <span>"less-loader"</span><span>]</span> <span>}</span><span>,</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.jpg|png|gif$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>[</span><span>"url-loader?limit=20000"</span><span>]</span> <span>}</span><span>,</span> <span>// 处理图片，小于等于20000字节的会被转换成base64，否则为地址</span>
      <span>{</span> <span>test</span><span>:</span> <span><span>/</span><span>\.js$</span><span>/</span></span><span>,</span> <span>use</span><span>:</span> <span>"babel-loader"</span><span>,</span> <span>exclude</span><span>:</span> <span><span>/</span><span>node_modules</span><span>/</span></span> <span>}</span><span>,</span> <span>// 处理高级js语法，node_modules中的第三方包不需要被打包</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>其中， <code>test</code> 表示匹配的文件类型，<code>use</code> 表示对应要调用的 loader</p>
<div><p>注意</p>
<ul>
<li>use 数组中指定的 loader 顺序是固定的</li>
<li>多个 loader 的调用顺序是：<strong>从后往前调用</strong></li>
</ul>
</div>
<h4 id="配置-babel-loader" tabindex="-1"> 配置 babel-loader</h4>
<p>不想看了，省略！</p>
<p>要创建一个 <code>babel.config.js</code> 文件</p>
<h3 id="自动清理-dist-目录" tabindex="-1"> 自动清理 dist 目录</h3>
<p>包：clean-webpack-plugin</p>
<p>使用方法：<a href="https://www.npmjs.com/package/clean-webpack-plugin" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h3 id="解决-source-map-的问题" tabindex="-1"> 解决 Source Map 的问题</h3>
<div><p>提示</p>
<p>由于 webpack 会进行混淆代码，因此运行时报错的行号可能与源代码的行号不一致，可以使用下面的方法来保持一致：</p>
</div>
<p>在配置文件中添加：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>mode</span><span>:</span> <span>"devlopment"</span><span>,</span>
  <span>devtool</span><span>:</span> <span>"eval-source-map"</span><span>,</span> <span>// this!</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>考虑到安全原因，建议使用折衷的 <code>nonsources-source-map</code></p>
</div>
<h3 id="符号的定义" tabindex="-1"> @符号的定义</h3>
<div><p>提示</p>
<p>import 时，若使用相对路径会使得代码非常繁琐，可以使用@符号代表 src 目录的绝对路径，从外往里指定路径。</p>
</div>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>resolve</span><span>:</span> <span>{</span>
    <span>alias</span><span>:</span> <span>{</span>
      <span>"@"</span><span>:</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>"src"</span><span>)</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python异步I/O与协程</title>
      <link>https://timpcfan.site/code/language/python/python-asyncio.html</link>
      <guid>https://timpcfan.site/code/language/python/python-asyncio.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python异步I/O与协程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>注意</p>
<p>这里实际上就是官方文档的搬运，非常不完整，建议直接看<a href="https://docs.python.org/zh-cn/3.10/library/asyncio.html" target="_blank" rel="noopener noreferrer">官方文档</a>。</p>
</div>
<h2 id="asyncio-—-异步-i-o-协程" tabindex="-1"> asyncio — 异步 I/O &amp; 协程</h2>
<p>协程运行的原理见： <a href="/code/language/python/python-concurrent.html#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81">协程的原理以及代码</a></p>
<p>asyncio 是用来编写  <strong>并发</strong>  代码的库，使用  <strong>async/await</strong>  语法。</p>
<p>asyncio 被用作多个提供高性能 Python 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等。</p>
<p>asyncio 往往是构建 IO 密集型和高层级  <strong>结构化</strong>  网络代码的最佳选择。</p>
<p>asyncio 提供一组  <strong>高层级</strong> API 用于:</p>
<ul>
<li>并发地  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">运行 Python 协程</a>  并对其执行过程实现完全控制;</li>
<li>执行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">网络 IO 和 IPC</a>;</li>
<li>控制  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程</a>;</li>
<li>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列</a>  实现分布式任务;</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio-sync" target="_blank" rel="noopener noreferrer">同步</a>  并发代码;</li>
</ul>
<p>此外，还有一些  <strong>低层级</strong> API 以支持  <em>库和框架的开发者</em>  实现:</p>
<ul>
<li>创建和管理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio-event-loop" target="_blank" rel="noopener noreferrer">事件循环</a>，以提供异步 API 用于  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.create_server" target="_blank" rel="noopener noreferrer">网络化</a>, 运行  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec" target="_blank" rel="noopener noreferrer">子进程</a>，处理  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html#asyncio.loop.add_signal_handler" target="_blank" rel="noopener noreferrer">OS 信号</a>  等等;</li>
<li>使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-protocol.html#asyncio-transports-protocols" target="_blank" rel="noopener noreferrer">transports</a>  实现高效率协议;</li>
<li>通过 async/await 语法  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-future.html#asyncio-futures" target="_blank" rel="noopener noreferrer">桥接</a>  基于回调的库和代码。</li>
</ul>
<h2 id="协程与任务" tabindex="-1"> 协程与任务 <sup></sup></h2>
<h3 id="协程" tabindex="-1"> 协程</h3>
<p>通过 async/await 关键字来定义的协程是一种被推荐的编写异步程序的方式。</p>
<p>下面的代码定义并运行了一个协程：</p>
<div><pre><code><span>>></span><span>></span> <span>import</span> asyncio

<span>>></span><span>></span> <span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'hello'</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
<span>.</span><span>.</span><span>.</span>     <span>print</span><span>(</span><span>'world'</span><span>)</span>

<span>>></span><span>></span> asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
hello
world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意：简单地调用一个协程并不会使其被调度执行。</p>
<div><pre><code><span>>></span><span>></span> main<span>(</span><span>)</span>
<span>&lt;</span>coroutine <span>object</span> main at <span>0x1053bb7c8</span><span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>要正在运行一个协程，asyncio 提供了三种主要机制：</p>
<ol>
<li>
<p><code>asyncio.run()</code> 函数用来运行最高层级的入口点 “main()” 函数</p>
</li>
<li>
<p><code>await</code> 一个协程。以下代码会在等待 1 秒后打印“hello”，然后等待 2 秒后打印“world”。（await 一个协程会让其开始运行，并等待其完成）</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> time

<span>async</span> <span>def</span> <span>say_after</span><span>(</span>delay<span>,</span> what<span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span>delay<span>)</span>
    <span>print</span><span>(</span>what<span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span>
    <span>await</span> say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># started at 17:13:52</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:13:55</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p><code>asyncio.create_task()</code> 函数用来并发运行作为 asyncio 任务的多个协程。（create_task()之后会使任务出于就绪状态随时准备运行，而 await task 则是等待这个任务运行完成）</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    task1 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>1</span><span>,</span> <span>'hello'</span><span>)</span><span>)</span>

    task2 <span>=</span> asyncio<span>.</span>create_task<span>(</span>
        say_after<span>(</span><span>2</span><span>,</span> <span>'world'</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"started at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span># Wait until both tasks are completed (should take</span>
    <span># around 2 seconds.)</span>
    <span>await</span> task1
    <span>await</span> task2

    <span>print</span><span>(</span><span><span>f"finished at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span># 比上面的要快1秒，因为两个task是同时运行的</span>
<span># started at 17:14:32</span>
<span># hello</span>
<span># world</span>
<span># finished at 17:14:34</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
</ol>
<h3 id="可等待对象-awaitable-objects" tabindex="-1"> 可等待对象 awaitable objects</h3>
<p>如果一个对象可以在 await 语句中使用，那么它就是 awaitable 对象。许多 asyncio API 都被设计为接受 awaitable 对象。</p>
<p>可等待 对象有三种主要类型：协程（Coroutine）、任务（Task）、Future。</p>
<h3 id="协程-1" tabindex="-1"> 协程</h3>
<p>Python 协程属于可等待对象，因此可以在其他协程中被等待：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Nothing happens if we just call "nested()".</span>
    <span># A coroutine object is created but not awaited,</span>
    <span># so it *won't run at all*.</span>
    nested<span>(</span><span>)</span>  <span># 这个不会运行，只是单纯返回了一个coroutine对象</span>

    <span># Let's do it differently now and await it:</span>
    <span>print</span><span>(</span><span>await</span> nested<span>(</span><span>)</span><span>)</span>  <span># will print "42".  # 这里会运行，因为有await</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>重要</strong></p>
<p>在本文档中 &quot;协程&quot; 可用来表示两个紧密关联的概念:</p>
<ul>
<li><em>协程函数</em>: 定义形式为  <code>[async def](https://docs.python.org/zh-cn/3/reference/compound_stmts.html#async-def)</code>  的函数;</li>
<li><em>协程对象</em>: 调用  <em>协程函数</em>  所返回的对象。</li>
</ul>
<h3 id="任务" tabindex="-1"> 任务</h3>
<p>Task 被用来 “并行地” 调度协程。</p>
<p>当一个协程通过 asyncio.create_task() 等函数被封装为了一个 Task，该协程会被自动调度执行：</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>nested</span><span>(</span><span>)</span><span>:</span>
    <span>return</span> <span>42</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule nested() to run soon concurrently</span>
    <span># with "main()".</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>nested<span>(</span><span>)</span><span>)</span>  <span># 这里 task 就开始运行了</span>

    <span># "task" can now be used to cancel "nested()", or</span>
    <span># can simply be awaited to wait until it is complete:</span>
    <span>await</span> task  <span># 这里只是单纯地等待其运行完</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="futures" tabindex="-1"> Futures</h3>
<p>Future 是一种特殊的 <strong>低层级</strong> 可等待对象，表示一个异步操作的 <strong>最终结果</strong>。</p>
<p>当一个 Future 对象 <em>被等待</em>，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。</p>
<p>在 asyncio 中需要 Future 对象以便允许 async/await 使用基于回调的代码。</p>
<p>通常情况下 <strong>没有必要</strong> 在应用层级的代码中创建 Future 对象。</p>
<p>Future 对象有时会由库和某些 asyncio API 暴露给用户，用作可等待对象：</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> function_that_returns_a_future_object<span>(</span><span>)</span>

    <span># this is also valid:</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        function_that_returns_a_future_object<span>(</span><span>)</span><span>,</span>
        some_python_coroutine<span>(</span><span>)</span>
    <span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>一个很好的返回对象的低层级函数的示例是：loop.run_in_executor()</p>
<h3 id="运行-asyncio-程序" tabindex="-1"> 运行 asyncio 程序</h3>
<p><code>asyncio.run(coro, *, debug=False)</code></p>
<p>执行 coro 并返回结果。</p>
<p>吃函数会运行传入的协程，负责管理 asyncio 事件循环，终结异步生成器，并关闭线程池。</p>
<p>但有其他 asyncio 事件循环在同一线程中运行时，此函数不能被调用。</p>
<p>如果 debug 为 True，事件循环将以调试模式运行。</p>
<p>此函数<strong>总是会创建一个新的事件循环</strong>并在结束时关闭之。它应当用作 asyncio 程序的主入口点，理想情况下应当只被调用一次。</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span>'hello'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="创建任务" tabindex="-1"> 创建任务</h3>
<p><code>asyncio.create_task(coro, *, name=None)</code></p>
<p>将 coro 封装为一个 Task 并调度其执行。返回 Task 对象。</p>
<p>name 不为 None 时，它将使用 Task.set_name() 来设为任务的名称。</p>
<p>该任务会在 get_running_loop() 返回的循环中执行，如果当前线程没有在运行的循环则会引发 RuntimeError。</p>
<div><p>相关信息</p>
<p>需要保存这个方法返回值 Task 的引用，因为 event_loop 中只会保存一个弱引用，如果不保存引用，可能这个协程没有被执行完毕就被垃圾回收给清理了。</p>
</div>
<div><pre><code>background_tasks <span>=</span> <span>set</span><span>(</span><span>)</span>

<span>for</span> i <span>in</span> <span>range</span><span>(</span><span>10</span><span>)</span><span>:</span>
    task <span>=</span> asyncio<span>.</span>create_task<span>(</span>some_coro<span>(</span>param<span>=</span>i<span>)</span><span>)</span>

    <span># Add task to the set. This creates a strong reference.</span>
    background_tasks<span>.</span>add<span>(</span>task<span>)</span>

    <span># To prevent keeping references to finished tasks forever,</span>
    <span># make each task remove its own reference from the set after</span>
    <span># completion:</span>
    task<span>.</span>add_done_callback<span>(</span>background_tasks<span>.</span>discard<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="休眠" tabindex="-1"> 休眠</h3>
<p><code>coroutine asyncio.sleep(delay, result=None)</code></p>
<p>阻塞 delay 指定的秒数。</p>
<p>如果指定了 result，则当协程完成时 result 其返回给调用者。</p>
<p>sleep() 总是会挂起当前任务，以允许其他任务运行。</p>
<p>将 delay 设为 0 将提供一个经优化的路径以允许其他任务运行。 这可供长期间运行的函数使用以避免在函数调用的全过程中阻塞事件循环。</p>
<p>以下协程示例运行 5 秒，每秒显示一次当前日期:</p>
<div><pre><code><span>import</span> asyncio
<span>import</span> datetime

<span>async</span> <span>def</span> <span>display_date</span><span>(</span><span>)</span><span>:</span>
    loop <span>=</span> asyncio<span>.</span>get_running_loop<span>(</span><span>)</span>
    end_time <span>=</span> loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>5.0</span>
    <span>while</span> <span>True</span><span>:</span>
        <span>print</span><span>(</span>datetime<span>.</span>datetime<span>.</span>now<span>(</span><span>)</span><span>)</span>
        <span>if</span> <span>(</span>loop<span>.</span>time<span>(</span><span>)</span> <span>+</span> <span>1.0</span><span>)</span> <span>>=</span> end_time<span>:</span>
            <span>break</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>

asyncio<span>.</span>run<span>(</span>display_date<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="并发运行任务" tabindex="-1"> 并发运行任务</h3>
<p><code>awaitable asyncio.gather(*aws, return_exceptions=False)</code></p>
<p><em>并发</em> 运行 aws 序列中的 可等待对象。</p>
<p>如果 aws 中的某个可等待对象为协程，它将自动被作为一个任务调度。</p>
<p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而层的列表。结果值的顺序与 aws 中可等待对象的<strong>顺序一致</strong>。</p>
<p>如果 return_exceptions 为 False，所引发的首个异常会立即传播给等待 gather() 的任务。aws 序列中的其他可等待对象 <strong>不会被取消</strong> 并继续运行。</p>
<p>如果 return_exceptions 为 True，异常会和成功的结果一样处理，并聚合至结果列表。</p>
<p>如果 gather() 被取消，所有被提交（尚未完成）的可等待对象也会 被取消。</p>
<p>如果 aws 序列中的任一 Task 或 Future 对象 被取消，它将被当作引发了 CancelledError 一样处理 — 在此情况下 gather() 调用 <strong>不会</strong> 被取消。这是为了防止一个已提交的 Task/Future 被取消导致其他 Tasks/Future 也被取消。</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>factorial</span><span>(</span>name<span>,</span> number<span>)</span><span>:</span>
    f <span>=</span> <span>1</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> number <span>+</span> <span>1</span><span>)</span><span>:</span>
        <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: Compute factorial(</span><span><span>{</span>number<span>}</span></span><span>), currently i=</span><span><span>{</span>i<span>}</span></span><span>..."</span></span><span>)</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
        f <span>*=</span> i
    <span>print</span><span>(</span><span><span>f"Task </span><span><span>{</span>name<span>}</span></span><span>: factorial(</span><span><span>{</span>number<span>}</span></span><span>) = </span><span><span>{</span>f<span>}</span></span><span>"</span></span><span>)</span>
    <span>return</span> f

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Schedule three calls *concurrently*:</span>
    L <span>=</span> <span>await</span> asyncio<span>.</span>gather<span>(</span>
        factorial<span>(</span><span>"A"</span><span>,</span> <span>2</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"B"</span><span>,</span> <span>3</span><span>)</span><span>,</span>
        factorial<span>(</span><span>"C"</span><span>,</span> <span>4</span><span>)</span><span>,</span>
    <span>)</span>
    <span>print</span><span>(</span>L<span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     Task A: Compute factorial(2), currently i=2...</span>
<span>#     Task B: Compute factorial(3), currently i=2...</span>
<span>#     Task C: Compute factorial(4), currently i=2...</span>
<span>#     Task A: factorial(2) = 2</span>
<span>#     Task B: Compute factorial(3), currently i=3...</span>
<span>#     Task C: Compute factorial(4), currently i=3...</span>
<span>#     Task B: factorial(3) = 6</span>
<span>#     Task C: Compute factorial(4), currently i=4...</span>
<span>#     Task C: factorial(4) = 24</span>
<span>#     [2, 6, 24]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>如果  <em>return_exceptions</em>  为 False，则在 gather() 被标记为已完成后取消它将不会取消任何已提交的可等待对象。 例如，在将一个异常传播给调用者之后，gather 可被标记为已完成，因此，在从 gather 捕获一个（由可等待对象所引发的）异常之后调用  <code>gather.cancel()</code>  将不会取消任何其他可等待对象。</p>
</div>
<h3 id="屏蔽取消操作" tabindex="-1"> 屏蔽取消操作</h3>
<p><code>awaitable asyncio.shield(aw)</code></p>
<p>保护一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  防止其被  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p>以下语句:</p>
<p><code>res = **await** shield(something())</code></p>
<p>相当于:</p>
<p><code>res = **await** something()</code></p>
<p><em>不同之处</em>  在于如果包含它的协程被取消，在  <code>something()</code>  中运行的任务不会被取消。从  <code>something()</code>  的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 &quot;await&quot; 表达式仍然会引发<a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>。</p>
<h3 id="超时" tabindex="-1"> 超时</h3>
<p><code>coroutine asyncio.wait_for(aw, timeout)</code></p>
<p>等待  <em>aw</em> <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  完成，指定 timeout 秒数后超时。</p>
<p>如果  <em>aw</em>  是一个协程，它将自动被作为任务调度。</p>
<p><em>timeout</em>  可以为  <code>None</code>，也可以为 float 或 int 型数值表示的等待秒数。如果  <em>timeout</em>  为  <code>None</code>，则等待直到完成。</p>
<p>如果发生超时，任务将取消并引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>.</p>
<p>要避免任务  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">取消</a>，可以加上  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.shield" target="_blank" rel="noopener noreferrer">shield()</a>。</p>
<p>此函数将等待直到 Future 确实被取消，所以总等待时间可能超过  <em>timeout</em>。 如果在取消期间发生了异常，异常将会被传播。</p>
<p>如果等待被取消，则  <em>aw</em>  指定的对象也会被取消。</p>
<div><pre><code><span>async</span> <span>def</span> <span>eternity</span><span>(</span><span>)</span><span>:</span>
    <span># Sleep for one hour</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>3600</span><span>)</span>
    <span>print</span><span>(</span><span>'yay!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Wait for at most 1 second</span>
    <span>try</span><span>:</span>
        <span>await</span> asyncio<span>.</span>wait_for<span>(</span>eternity<span>(</span><span>)</span><span>,</span> timeout<span>=</span><span>1.0</span><span>)</span>
    <span>except</span> asyncio<span>.</span>TimeoutError<span>:</span>
        <span>print</span><span>(</span><span>'timeout!'</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span>#     timeout!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="简单等待" tabindex="-1"> 简单等待</h3>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>  并进入阻塞状态直到满足  <em>return_when</em>  所指定的条件。</p>
<p><em>aws</em>  可迭代对象必须不为空。</p>
<p>返回两个 Task/Future 集合: <code>(done, pending)</code>。</p>
<p>用法：</p>
<p><code>done, pending = **await** asyncio.wait(aws)</code></p>
<p>如指定  <em>timeout</em> (float 或 int 类型) 则它将被用于控制返回之前等待的最长秒数。</p>
<p>请注意此函数不会引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。当超时发生时，未完成的 Future 或 Task 将在指定秒数后被返回。</p>
<p><em>return_when</em>  指定此函数应在何时返回。它必须为以下常数之一:</p>
<table>
<thead>
<tr>
<th>常量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIRST_COMPLETED</td>
<td>函数将在任意可等待对象结束或取消时返回。</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于  ALL_COMPLETED。</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td>函数将在所有可等待对象结束或取消时返回。</td>
</tr>
</tbody>
</table>
<p><code>asyncio.as_completed(aws, *, timeout=None)</code></p>
<p>并发地运行  <em>aws</em>  可迭代对象中的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio-awaitables" target="_blank" rel="noopener noreferrer">可等待对象</a>。 返回一个协程的迭代器。 所返回的每个协程可被等待以从剩余的可等待对象的可迭代对象中获得最早的下一个结果。</p>
<p>如果在所有 Future 对象完成前发生超时则将引发  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.TimeoutError" target="_blank" rel="noopener noreferrer">asyncio.TimeoutError</a>。</p>
<div><pre><code><span>for</span> coro <span>in</span> as_completed<span>(</span>aws<span>)</span><span>:</span>
    earliest_result <span>=</span> <span>await</span> coro
    <span># ...</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="在线程中运行" tabindex="-1"> 在线程中运行</h3>
<p><code>coroutine asyncio.to_thread(func, /, *args, **kwargs)</code></p>
<p>在不同的线程中异步地运行函数  <em>func</em>。</p>
<p>向此函数提供的任何 *args 和 **kwargs 会被直接传给  *func*。 并且，当前  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#contextvars.Context" target="_blank" rel="noopener noreferrer">contextvars.Context</a>  会被传播，允许在不同的线程中访问来自事件循环的上下文变量。</p>
<p>返回一个可被等待以获取  <em>func</em>  的最终结果的协程。</p>
<p>这个协程函数主要是用于执行在其他情况下会阻塞事件循环的 IO 密集型函数/方法。 例如:</p>
<div><pre><code><span>def</span> <span>blocking_io</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"start blocking_io at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>
    <span># Note that time.sleep() can be replaced with any blocking</span>
    <span># IO-bound operation, such as file operations.</span>
    time<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    <span>print</span><span>(</span><span><span>f"blocking_io complete at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span><span>f"started main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>await</span> asyncio<span>.</span>gather<span>(</span>
        asyncio<span>.</span>to_thread<span>(</span>blocking_io<span>)</span><span>,</span>
        asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"finished main at </span><span><span>{</span>time<span>.</span>strftime<span>(</span><span>'%X'</span><span>)</span><span>}</span></span><span>"</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># Expected output:</span>
<span>#</span>
<span># started main at 19:50:53</span>
<span># start blocking_io at 19:50:53</span>
<span># blocking_io complete at 19:50:54</span>
<span># finished main at 19:50:54</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在任何协程中直接调用  blocking_io() 将会在调用期间阻塞事件循环，导致额外的 1 秒运行时间。 而通过改用  asyncio.to_thread()，我们可以在不同的线程中运行它从而不会阻塞事件循环。</p>
<h3 id="跨线程调度" tabindex="-1"> 跨线程调度</h3>
<p><code>asyncio.run_coroutine_threadsafe(coro, loop)</code></p>
<p>向指定事件循环提交一个协程。（线程安全）</p>
<p>返回一个  <a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html#concurrent.futures.Future" target="_blank" rel="noopener noreferrer">concurrent.futures.Future</a>  以等待来自其他 OS 线程的结果。</p>
<p>此函数应该从另一个 OS 线程中调用，而非事件循环运行所在线程。示例:</p>
<div><pre><code><span># Create a coroutine</span>
coro <span>=</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>,</span> result<span>=</span><span>3</span><span>)</span>

<span># Submit the coroutine to a given loop</span>
future <span>=</span> asyncio<span>.</span>run_coroutine_threadsafe<span>(</span>coro<span>,</span> loop<span>)</span>

<span># Wait for the result with an optional timeout argument</span>
<span>assert</span> future<span>.</span>result<span>(</span>timeout<span>)</span> <span>==</span> <span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果在协程内产生了异常，将会通知返回的 Future 对象。它也可被用来取消事件循环中的任务:</p>
<div><pre><code><span>try</span><span>:</span>
    result <span>=</span> future<span>.</span>result<span>(</span>timeout<span>)</span>
<span>except</span> concurrent<span>.</span>futures<span>.</span>TimeoutError<span>:</span>
    <span>print</span><span>(</span><span>'The coroutine took too long, cancelling the task...'</span><span>)</span>
    future<span>.</span>cancel<span>(</span><span>)</span>
<span>except</span> Exception <span>as</span> exc<span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine raised an exception: </span><span><span>{</span>exc<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
<span>else</span><span>:</span>
    <span>print</span><span>(</span><span><span>f'The coroutine returned: </span><span><span>{</span>result<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>参见  <a href="https://docs.python.org/zh-cn/3/library/asyncio-dev.html#asyncio-multithreading" target="_blank" rel="noopener noreferrer">concurrency and multithreading</a>  部分的文档。</p>
<p>不同与其他 asyncio 函数，此函数要求显式地传入  <em>loop</em>  参数。</p>
<h3 id="内省" tabindex="-1"> 内省</h3>
<p><code>asyncio.**current_task**(*loop=None*)</code></p>
<p>返回当前运行的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  实例，如果没有正在运行的任务则返回  <code>None</code>。
如果  <em>loop</em>  为  <code>None</code>  则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<p><code>asyncio.**all_tasks**(*loop=None*)</code></p>
<p>返回事件循环所运行的未完成的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">Task</a>  对象的集合。
如果  <em>loop</em>  为  <code>None</code>，则会使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.get_running_loop" target="_blank" rel="noopener noreferrer">get_running_loop()</a>  获取当前事件循环。</p>
<h3 id="task-对象" tabindex="-1"> Task 对象</h3>
<p><code>class asyncio.Task(coro, *, loop=None, name=None)</code></p>
<p>一个与  <code>[Future 类似](https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future)</code>  的对象，可运行 Python <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程</a>。非线程安全。</p>
<p>Task 对象被用来在事件循环中运行协程。如果一个协程在等待一个 Future 对象，Task 对象会挂起该协程的执行并等待该 Future 对象完成。当该 Future 对象  <em>完成</em>，被打包的协程将恢复执行。</p>
<p>事件循环使用协同日程调度: 一个事件循环每次运行一个 Task 对象。而一个 Task 对象会等待一个 Future 对象完成，该事件循环会运行其他 Task、回调或执行 IO 操作。</p>
<p>使用高层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数来创建 Task 对象，也可用低层级的  <a href="https://docs.python.org/zh-cn/3/library/asyncio-eventloop.html#asyncio.loop.create_task" target="_blank" rel="noopener noreferrer">loop.create_task()</a>  或  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.ensure_future" target="_blank" rel="noopener noreferrer">ensure_future()</a>  函数。不建议手动实例化 Task 对象。</p>
<p>要取消一个正在运行的 Task 对象可使用  <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancel" target="_blank" rel="noopener noreferrer">cancel()</a>  方法。调用此方法将使该 Task 对象抛出一个  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常给打包的协程。如果取消期间一个协程正在等待一个 Future 对象，该 Future 对象也将被取消。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task.cancelled" target="_blank" rel="noopener noreferrer">cancelled()</a>  可被用来检测 Task 对象是否被取消。如果打包的协程没有抑制  <a href="https://docs.python.org/zh-cn/3/library/asyncio-exceptions.html#asyncio.CancelledError" target="_blank" rel="noopener noreferrer">CancelledError</a>  异常并且确实被取消，该方法将返回  <code>True</code>。</p>
<p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.Task" target="_blank" rel="noopener noreferrer">asyncio.Task</a>  从  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future" target="_blank" rel="noopener noreferrer">Future</a>  继承了其除  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_result" target="_blank" rel="noopener noreferrer">Future.set_result()</a>  和  <a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future.set_exception" target="_blank" rel="noopener noreferrer">Future.set_exception()</a>  以外的所有 API。</p>
<p>Task 对象支持  <a href="https://docs.python.org/zh-cn/3/library/contextvars.html#module-contextvars" target="_blank" rel="noopener noreferrer">contextvars</a>  模块。当一个 Task 对象被创建，它将复制当前上下文，然后在复制的上下文中运行其协程。</p>
<ul>
<li>cancel(msg=None)：取消任务，这将抛出 CancelledError</li>
<li>done()：如果 Task 对象已完成，则返回 true</li>
<li>result()：返回 Task 的结果</li>
<li>add_done_callback(callback, *, context=None)：添加一个回调，在 Task 完成时调用。</li>
</ul>
<h2 id="stream-流" tabindex="-1"> Stream 流 <sup></sup></h2>
<p>流是用于处理网络连接的支持 async/await 的高层级原语。 流允许发送和接收数据，而不需要使用回调或低级协议和传输。</p>
<h3 id="stream-函数" tabindex="-1"> Stream 函数</h3>
<ul>
<li>open_connection</li>
<li>start_server</li>
</ul>
<h3 id="unix-套接字-socket" tabindex="-1"> Unix 套接字（Socket）</h3>
<ul>
<li>open_unix_connection</li>
<li>start_unix_server</li>
</ul>
<h3 id="streamreader-与-streamwriter" tabindex="-1"> StreamReader 与 StreamWriter</h3>
<h3 id="例子-echo-服务器与客户端" tabindex="-1"> 例子：echo 服务器与客户端</h3>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>handle_echo</span><span>(</span>reader<span>,</span> writer<span>)</span><span>:</span>
    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    message <span>=</span> data<span>.</span>decode<span>(</span><span>)</span>
    addr <span>=</span> writer<span>.</span>get_extra_info<span>(</span><span>'peername'</span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Received </span><span><span>{</span>message<span>!r</span><span>}</span></span><span> from </span><span><span>{</span>addr<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>

    <span>print</span><span>(</span><span><span>f"Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>"</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>data<span>)</span>
    <span>await</span> writer<span>.</span>drain<span>(</span><span>)</span>

    <span>print</span><span>(</span><span>"Close the connection"</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    server <span>=</span> <span>await</span> asyncio<span>.</span>start_server<span>(</span>
        handle_echo<span>,</span> <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    addrs <span>=</span> <span>', '</span><span>.</span>join<span>(</span><span>str</span><span>(</span>sock<span>.</span>getsockname<span>(</span><span>)</span><span>)</span> <span>for</span> sock <span>in</span> server<span>.</span>sockets<span>)</span>
    <span>print</span><span>(</span><span><span>f'Serving on </span><span><span>{</span>addrs<span>}</span></span><span>'</span></span><span>)</span>

    <span>async</span> <span>with</span> server<span>:</span>
        <span>await</span> server<span>.</span>serve_forever<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>tcp_echo_client</span><span>(</span>message<span>)</span><span>:</span>
    reader<span>,</span> writer <span>=</span> <span>await</span> asyncio<span>.</span>open_connection<span>(</span>
        <span>'127.0.0.1'</span><span>,</span> <span>8888</span><span>)</span>

    <span>print</span><span>(</span><span><span>f'Send: </span><span><span>{</span>message<span>!r</span><span>}</span></span><span>'</span></span><span>)</span>
    writer<span>.</span>write<span>(</span>message<span>.</span>encode<span>(</span><span>)</span><span>)</span>

    data <span>=</span> <span>await</span> reader<span>.</span>read<span>(</span><span>100</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'Received: </span><span><span>{</span>data<span>.</span>decode<span>(</span><span>)</span><span>!r</span><span>}</span></span><span>'</span></span><span>)</span>

    <span>print</span><span>(</span><span>'Close the connection'</span><span>)</span>
    writer<span>.</span>close<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>tcp_echo_client<span>(</span><span>'Hello World!'</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="同步原语" tabindex="-1"> 同步原语 <sup></sup></h2>
<p>asyncio 同步原语被设计为与  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>  模块的类似，但有两个关键注意事项:</p>
<ul>
<li>asyncio 原语不是线程安全的，因此它们不应被用于 OS 线程同步 (而应当使用  <a href="https://docs.python.org/zh-cn/3.10/library/threading.html#module-threading" target="_blank" rel="noopener noreferrer">threading</a>)；</li>
<li>这些同步原语的方法不接受  <em>timeout</em>  参数；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数来执行带有超时的操作。</li>
</ul>
<p>asyncio 具有下列基本同步原语:</p>
<h3 id="lock" tabindex="-1"> Lock</h3>
<p><code>class asyncio.Lock</code></p>
<p>实现一个用于 asyncio 任务的互斥锁。 非线程安全。</p>
<p>asyncio 锁可被用来保证对共享资源的独占访问。</p>
<p>使用 Lock 的推荐方式是通过  <code>[async with](https://docs.python.org/zh-cn/3.10/reference/compound_stmts.html#async-with)</code>  语句:</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>async</span> <span>with</span> lock<span>:</span>
    <span># access shared state</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这等价于：</p>
<div><pre><code>lock <span>=</span> asyncio<span>.</span>Lock<span>(</span><span>)</span>

<span># ... later</span>
<span>await</span> lock<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
    <span># access shared state</span>
<span>finally</span><span>:</span>
    lock<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine acquire()</code></p>
<p>获取锁。
此方法会等待直至锁为  <em>unlocked</em>，将其设为  <em>locked</em>  并返回  <code>True</code>。
当有一个以上的协程在  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Lock.acquire" target="_blank" rel="noopener noreferrer">acquire()</a>  中被阻塞则会等待解锁，最终只有一个协程会被执行。
锁的获取是  <em>公平的</em>: 被执行的协程将是第一个开始等待锁的协程。</p>
<p><code>release()</code></p>
<p>释放锁。</p>
<p>当锁为  <em>locked</em>  时，将其设为  <em>unlocked</em>  并返回。</p>
<p>如果锁为  <em>unlocked</em>，则会引发  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeError" target="_blank" rel="noopener noreferrer">RuntimeError</a>。</p>
<p><code>locked()</code></p>
<p>如果锁为  <em>locked</em>  则返回  <code>True</code>。</p>
<h3 id="event" tabindex="-1"> Event</h3>
<p><code>class asyncio.Event</code></p>
<p>事件对象。 该对象不是线程安全的。</p>
<p>asyncio 事件可被用来通知多个 asyncio 任务已经有事件发生。</p>
<p>Event 对象会管理一个内部旗标，可通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法将其设为  <em>true</em>  并通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.clear" target="_blank" rel="noopener noreferrer">clear()</a>  方法将其重设为  <em>false</em>。 <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  方法会阻塞直至该旗标被设为  <em>true</em>。 该旗标初始时会被设为  <em>false</em>。</p>
<div><pre><code><span>async</span> <span>def</span> <span>waiter</span><span>(</span>event<span>)</span><span>:</span>
    <span>print</span><span>(</span><span>'waiting for it ...'</span><span>)</span>
    <span>await</span> event<span>.</span>wait<span>(</span><span>)</span>
    <span>print</span><span>(</span><span>'... got it!'</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create an Event object.</span>
    event <span>=</span> asyncio<span>.</span>Event<span>(</span><span>)</span>

    <span># Spawn a Task to wait until 'event' is set.</span>
    waiter_task <span>=</span> asyncio<span>.</span>create_task<span>(</span>waiter<span>(</span>event<span>)</span><span>)</span>

    <span># Sleep for 1 second and set the event.</span>
    <span>await</span> asyncio<span>.</span>sleep<span>(</span><span>1</span><span>)</span>
    event<span>.</span><span>set</span><span>(</span><span>)</span>

    <span># Wait until the waiter task is finished.</span>
    <span>await</span> waiter_task

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>coroutine wait()</code></p>
<p>等待直至事件被设置。</p>
<p>如果事件已被设置，则立即返回  <code>True</code>。 否则将阻塞直至另一个任务调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>。</p>
<p><code>set()</code></p>
<p>设置事件。</p>
<p>所有等待事件被设置的任务将被立即唤醒。</p>
<p><code>clear()</code></p>
<p>清空（取消设置）事件。</p>
<p>通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.wait" target="_blank" rel="noopener noreferrer">wait()</a>  进行等待的任务现在将会阻塞直至  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#asyncio.Event.set" target="_blank" rel="noopener noreferrer">set()</a>  方法被再次调用。</p>
<p><code>is_set()</code></p>
<p>如果事件已被设置则返回  <code>True</code>。</p>
<h3 id="condition" tabindex="-1"> Condition</h3>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition" target="_blank" rel="noopener noreferrer">https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html#condition</a></p>
<h3 id="semaphore" tabindex="-1"> Semaphore</h3>
<h3 id="boundedsemaphore" tabindex="-1"> BoundedSemaphore</h3>
<h2 id="队列集合" tabindex="-1"> 队列集合 <sup></sup></h2>
<p>asyncio 队列被设计成与  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a>  模块类似。尽管 asyncio 队列不是线程安全的，但是他们是被设计专用于 async/await 代码。</p>
<p>注意 asyncio 的队列没有  <em>timeout</em>  形参；请使用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.wait_for" target="_blank" rel="noopener noreferrer">asyncio.wait_for()</a>  函数为队列添加超时操作。</p>
<p>参见下面的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#examples" target="_blank" rel="noopener noreferrer">Examples</a>  部分。</p>
<h3 id="queue" tabindex="-1"> Queue</h3>
<p><code>class asyncio.Queue(maxsize=0)</code></p>
<p>FIFO 队列</p>
<p>如果  <em>maxsize</em>  小于等于零，则队列尺寸是无限的。如果是大于  <code>0</code>  的整数，则当队列达到  <em>maxsize</em>  时， <code>await put()</code>  将阻塞至某个元素被  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.get" target="_blank" rel="noopener noreferrer">get()</a>  取出。</p>
<p>不像标准库中的并发型  <a href="https://docs.python.org/zh-cn/3.10/library/queue.html#module-queue" target="_blank" rel="noopener noreferrer">queue</a> ，队列的尺寸一直是已知的，可以通过调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.qsize" target="_blank" rel="noopener noreferrer">qsize()</a>  方法返回。</p>
<ul>
<li>maxsize</li>
<li>empty()</li>
<li>full()</li>
<li>coroutine join()</li>
<li>get_nowait() 不阻塞的出队</li>
<li>coroutine join() 阻塞至队列中所有的元素都被接收和处理完毕。
<ul>
<li>当条目添加到队列的时候，未完成任务的计数就会增加。每当消费协程调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.task_done" target="_blank" rel="noopener noreferrer">task_done()</a>表示这个条目已经被回收，该条目所有工作已经完成，未完成计数就会减少。当未完成计数降到零的时候， <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue.join" target="_blank" rel="noopener noreferrer">join()</a>阻塞被解除。</li>
</ul>
</li>
<li>coroutine put(item)</li>
<li>put_nowait(item) 不阻塞的入队</li>
<li>qsize()</li>
<li>task_done() 表明前面排队的任务已经完成，即 get 出来的元素相关操作已经完成。</li>
</ul>
<h3 id="优先级队列" tabindex="-1"> 优先级队列</h3>
<p><code>class asyncio.PriorityQueue</code></p>
<p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio.Queue" target="_blank" rel="noopener noreferrer">Queue</a>  的变体；按优先级顺序取出条目 (最小的先取出)。</p>
<p>条目通常是  <code>(priority_number, data)</code>  形式的元组。</p>
<h3 id="后进先出队列" tabindex="-1"> <strong>后进先出队列</strong></h3>
<p><code>class asyncio.LifoQueue</code></p>
<h3 id="例子" tabindex="-1"> 例子</h3>
<div><pre><code><span>import</span> asyncio
<span>import</span> random
<span>import</span> time

<span>async</span> <span>def</span> <span>worker</span><span>(</span>name<span>,</span> queue<span>)</span><span>:</span>
    <span>while</span> <span>True</span><span>:</span>
        <span># Get a "work item" out of the queue.</span>
        sleep_for <span>=</span> <span>await</span> queue<span>.</span>get<span>(</span><span>)</span>

        <span># Sleep for the "sleep_for" seconds.</span>
        <span>await</span> asyncio<span>.</span>sleep<span>(</span>sleep_for<span>)</span>

        <span># Notify the queue that the "work item" has been processed.</span>
        queue<span>.</span>task_done<span>(</span><span>)</span>

        <span>print</span><span>(</span><span><span>f'</span><span><span>{</span>name<span>}</span></span><span> has slept for </span><span><span>{</span>sleep_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span># Create a queue that we will use to store our "workload".</span>
    queue <span>=</span> asyncio<span>.</span>Queue<span>(</span><span>)</span>

    <span># Generate random timings and put them into the queue.</span>
    total_sleep_time <span>=</span> <span>0</span>
    <span>for</span> _ <span>in</span> <span>range</span><span>(</span><span>20</span><span>)</span><span>:</span>
        sleep_for <span>=</span> random<span>.</span>uniform<span>(</span><span>0.05</span><span>,</span> <span>1.0</span><span>)</span>
        total_sleep_time <span>+=</span> sleep_for
        queue<span>.</span>put_nowait<span>(</span>sleep_for<span>)</span>

    <span># Create three worker tasks to process the queue concurrently.</span>
    tasks <span>=</span> <span>[</span><span>]</span>
    <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>3</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>worker<span>(</span><span><span>f'worker-</span><span><span>{</span>i<span>}</span></span><span>'</span></span><span>,</span> queue<span>)</span><span>)</span>
        tasks<span>.</span>append<span>(</span>task<span>)</span>

    <span># Wait until the queue is fully processed.</span>
    started_at <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span>
    <span>await</span> queue<span>.</span>join<span>(</span><span>)</span>
    total_slept_for <span>=</span> time<span>.</span>monotonic<span>(</span><span>)</span> <span>-</span> started_at

    <span># Cancel our worker tasks.</span>
    <span>for</span> task <span>in</span> tasks<span>:</span>
        task<span>.</span>cancel<span>(</span><span>)</span>
    <span># Wait until all worker tasks are cancelled.</span>
    <span>await</span> asyncio<span>.</span>gather<span>(</span><span>*</span>tasks<span>,</span> return_exceptions<span>=</span><span>True</span><span>)</span>

    <span>print</span><span>(</span><span>'===='</span><span>)</span>
    <span>print</span><span>(</span><span><span>f'3 workers slept in parallel for </span><span><span>{</span>total_slept_for<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>
    <span>print</span><span>(</span><span><span>f'total expected sleep time: </span><span><span>{</span>total_sleep_time<span>:</span><span>.2f</span><span>}</span></span><span> seconds'</span></span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="事件循环" tabindex="-1"> 事件循环 <sup></sup></h2>
<h3 id="前言" tabindex="-1"> <strong>前言</strong></h3>
<p>事件循环是每个 asyncio 应用的核心。 事件循环会运行异步任务和回调，执行网络 IO 操作，以及运行子进程。</p>
<p>应用开发者通常应当使用高层级的 asyncio 函数，例如  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.run" target="_blank" rel="noopener noreferrer">asyncio.run()</a>，应当很少有必要引用循环对象或调用其方法。 本节所针对的主要是低层级代码、库和框架的编写者，他们需要更细致地控制事件循环行为。</p>
<h2 id="高层级-api-索引" tabindex="-1"> 高层级 API 索引 <sup></sup></h2>
<p>这个页面列举了所有能用于 async/wait 的高层级 asyncio API 集。</p>
<h3 id="任务-1" tabindex="-1"> 任务</h3>
<p>运行异步程序，创建 Task 对象，等待多件事运行超时的公共集。</p>
<table>
<thead>
<tr>
<th>run()</th>
<th>创建事件循环，运行一个协程，关闭事件循环。</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_task()</td>
<td>启动一个 asyncio 的 Task 对象。</td>
</tr>
<tr>
<td>await sleep()</td>
<td>休眠几秒。</td>
</tr>
<tr>
<td>await gather()</td>
<td>并发执行所有事件的调度和等待。</td>
</tr>
<tr>
<td>await wait_for()</td>
<td>有超时控制的运行。</td>
</tr>
<tr>
<td>await shield()</td>
<td>屏蔽取消操作</td>
</tr>
<tr>
<td>await wait()</td>
<td>完成情况的监控器</td>
</tr>
<tr>
<td>current_task()</td>
<td>返回当前 Task 对象</td>
</tr>
<tr>
<td>all_tasks()</td>
<td>返回事件循环中所有的 task 对象。</td>
</tr>
<tr>
<td>Task</td>
<td>Task 对象</td>
</tr>
<tr>
<td>to_thread()</td>
<td>在不同的 OS 线程中异步地运行一个函数。</td>
</tr>
<tr>
<td>run_coroutine_threadsafe()</td>
<td>从其他 OS 线程中调度一个协程。</td>
</tr>
<tr>
<td>for in as_completed()</td>
<td>用  for  循环监控完成情况。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-gather" target="_blank" rel="noopener noreferrer">使用 asyncio.gather() 并行运行</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-waitfor" target="_blank" rel="noopener noreferrer">使用 asyncio.wait_for() 强制超时</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">撤销协程</a>.</li>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-sleep" target="_blank" rel="noopener noreferrer">asyncio.sleep() 的用法</a>.</li>
<li>请主要参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#coroutine" target="_blank" rel="noopener noreferrer">协程与任务文档</a>.</li>
</ul>
<h3 id="队列集" tabindex="-1"> <strong>队列集</strong></h3>
<p>队列集被用于多个异步 Task 对象的运行调度，实现连接池以及发布/订阅模式。</p>
<table>
<thead>
<tr>
<th>Queue</th>
<th>先进先出队列</th>
</tr>
</thead>
<tbody>
<tr>
<td>PriorityQueue</td>
<td>优先级队列。</td>
</tr>
<tr>
<td>LifoQueue</td>
<td>后进先出队列。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-example-queue-dist" target="_blank" rel="noopener noreferrer">使用 asyncio.Queue 在多个并发任务间分配工作量</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html#asyncio-queues" target="_blank" rel="noopener noreferrer">队列集文档</a>.</li>
</ul>
<h3 id="子进程集" tabindex="-1"> 子进程集</h3>
<p>用于生成子进程和运行 shell 命令的工具包。</p>
<table>
<thead>
<tr>
<th>await create_subprocess_exec()</th>
<th>创建一个子进程。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await create_subprocess_shell()</td>
<td>运行一个 shell 命令。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-example-subprocess-shell" target="_blank" rel="noopener noreferrer">执行一个 shell 命令</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-subprocess.html#asyncio-subprocess" target="_blank" rel="noopener noreferrer">子进程 APIs</a>  相关文档.</li>
</ul>
<h3 id="流" tabindex="-1"> 流</h3>
<p>用于网络 IO 处理的高级 API 集。</p>
<table>
<thead>
<tr>
<th>await open_connection()</th>
<th>建立一个 TCP 连接。</th>
</tr>
</thead>
<tbody>
<tr>
<td>await open_unix_connection()</td>
<td>建立一个 Unix socket 连接。</td>
</tr>
<tr>
<td>await start_server()</td>
<td>启动 TCP 服务。</td>
</tr>
<tr>
<td>await start_unix_server()</td>
<td>启动一个 Unix 套接字服务。</td>
</tr>
<tr>
<td>StreamReader</td>
<td>接收网络数据的高级 async/await 对象。</td>
</tr>
<tr>
<td>StreamWriter</td>
<td>发送网络数据的高级 async/await 对象。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-example-stream" target="_blank" rel="noopener noreferrer">TCP 客户端样例</a>.</li>
<li>请参阅  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html#asyncio-streams" target="_blank" rel="noopener noreferrer">streams APIs</a>  文档。</li>
</ul>
<h3 id="同步" tabindex="-1"> <strong>同步</strong></h3>
<p>能被用于 Task 对象集的，类似线程的同步基元组件。</p>
<table>
<thead>
<tr>
<th>Lock</th>
<th>互斥锁。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Event</td>
<td>事件对象。</td>
</tr>
<tr>
<td>Condition</td>
<td>条件对象</td>
</tr>
<tr>
<td>Semaphore</td>
<td>信号量</td>
</tr>
<tr>
<td>BoundedSemaphore</td>
<td>有界的信号量。</td>
</tr>
</tbody>
</table>
<h3 id="异常" tabindex="-1"> <strong>异常</strong></h3>
<table>
<thead>
<tr>
<th>asyncio.TimeoutError</th>
<th>类似  wait_for()  等函数在超时时候被引发。请注意  asyncio.TimeoutError  与内建异常  TimeoutError  无关。</th>
</tr>
</thead>
<tbody>
<tr>
<td>asyncio.CancelledError</td>
<td>当一个 Task 对象被取消的时候被引发。请参阅  Task.cancel()。</td>
</tr>
</tbody>
</table>
<p><strong>例子</strong></p>
<ul>
<li><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio-example-task-cancel" target="_blank" rel="noopener noreferrer">在取消请求发生的运行代码中如何处理 CancelledError 异常</a>.</li>
<li>请参阅完整的  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-exceptions.html#asyncio-exceptions" target="_blank" rel="noopener noreferrer">asyncio 专用异常</a>  列表.</li>
</ul>
<h2 id="关于-never-awaited-协程" tabindex="-1"> 关于 never-awaited 协程</h2>
<p>当协程函数被调用而不是被等待时 (即执行  <code>coro()</code>  而不是  <code>await coro()</code>) 或者协程没有通过  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  被排入计划日程，asyncio 将会发出一条  <a href="https://docs.python.org/zh-cn/3.10/library/exceptions.html#RuntimeWarning" target="_blank" rel="noopener noreferrer">RuntimeWarning</a>:</p>
<div><pre><code><span>import</span> asyncio

<span>async</span> <span>def</span> <span>test</span><span>(</span><span>)</span><span>:</span>
    <span>print</span><span>(</span><span>"never scheduled"</span><span>)</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    test<span>(</span><span>)</span>

asyncio<span>.</span>run<span>(</span>main<span>(</span><span>)</span><span>)</span>

<span># test.py:7: RuntimeWarning: coroutine 'test' was never awaited</span>
<span>#  test()</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通常的修复方法是 <code>await</code> 协程或者调用  <a href="https://docs.python.org/zh-cn/3.10/library/asyncio-task.html#asyncio.create_task" target="_blank" rel="noopener noreferrer">asyncio.create_task()</a>  函数:</p>
<div><pre><code><span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
    <span>await</span> test<span>(</span><span>)</span>  <span># 开始运行并等待完成</span>

<span>async</span> <span>def</span> <span>main</span><span>(</span><span>)</span><span>:</span>
        task <span>=</span> asyncio<span>.</span>create_task<span>(</span>test<span>(</span><span>)</span><span>)</span>  <span># 开始运行</span>
        <span>await</span> task  <span># 等待完成</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<section>
<ol>
<li id="footnote1"><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html" target="_blank" rel="noopener noreferrer">协程与任务</a> </p>
</li>
<li id="footnote2"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-stream.html" target="_blank" rel="noopener noreferrer">Stream 流</a> </p>
</li>
<li id="footnote3"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-sync.html" target="_blank" rel="noopener noreferrer">同步原语</a> </p>
</li>
<li id="footnote4"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-queue.html" target="_blank" rel="noopener noreferrer">队列集合</a> </p>
</li>
<li id="footnote5"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-eventloop.html" target="_blank" rel="noopener noreferrer">事件循环</a> </p>
</li>
<li id="footnote6"><p><a href="https://docs.python.org/zh-cn/3.10/library/asyncio-api-index.html" target="_blank" rel="noopener noreferrer">高层级 API 索引</a> </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Python二分查找 - bisect</title>
      <link>https://timpcfan.site/code/language/python/python-bisect.html</link>
      <guid>https://timpcfan.site/code/language/python/python-bisect.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python二分查找 - bisect</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="二分查找模块-bisect" tabindex="-1"> 二分查找模块 bisect</h2>
<p><code>bisect_left(a, x, lo=0, hi=len(a))</code></p>
<p>相当于 left_bound，返回目标值的左侧边界，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最左侧索引</li>
<li>解读 2：a 中小于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于等于 x 的最小元素索引</li>
</ul>
<hr>
<p><code>bisect_right(a, x, lo=0, hi=len(a))</code></p>
<p><code>bisect(a, x, lo=0, hi=len(a))</code></p>
<p>⚠️ 不相当于 right_bound，返回目标值的右侧边界+1，其返回值的解读：</p>
<ul>
<li>解读 1：将 x 插入有序数组 a 中的最右侧索引</li>
<li>解读 2：a 中小于等于 x 的值的数量</li>
<li>解读 3：有序数组 a 中大于 x 的最小元素索引（返回的索引位置的值肯定不等于 x！！！</li>
</ul>
<hr>
<p><code>insort_left(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_left(a, x, lo, hi), x)</p>
<hr>
<p><code>insort_right(a, x, lo=0, hi=len(a))</code>
<code>insort(a, x, lo=0, hi=len(a))</code></p>
<p>等价于 a.insert(bisect.bisect_right(a, x, lo, hi), x)</p>
<hr>
<div><pre><code><span>#idx 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span>
a <span>=</span> <span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>8</span><span>]</span>

<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>3</span><span>)</span>
<span>3</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>3</span><span>)</span>  <span># bisect(a, 3)</span>
<span>8</span>
<span>>></span><span>></span> bisect_left<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
<span>>></span><span>></span> bisect_right<span>(</span>a<span>,</span> <span>4</span><span>)</span>
<span>8</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python3-10-之后的版本新增参数-key" tabindex="-1"> python3.10 之后的版本新增参数 key</h2>
<p>类似 sort 的 key 参数，可以指定搜索时使用的具体的键</p>
<p>例子：</p>
<div><pre><code><span># leetcode #875</span>
<span>class</span> <span>Solution</span><span>:</span>
    <span>def</span> <span>minEatingSpeed</span><span>(</span>self<span>,</span> piles<span>:</span> List<span>[</span><span>int</span><span>]</span><span>,</span> h<span>:</span> <span>int</span><span>)</span> <span>-</span><span>></span> <span>int</span><span>:</span>
        <span>def</span> <span>canEatAll</span><span>(</span>k<span>)</span><span>:</span>
            <span>if</span> k <span>==</span> <span>0</span><span>:</span>
                <span>return</span> <span>False</span>
            cost_time <span>=</span> <span>0</span>
            <span>for</span> pile <span>in</span> piles<span>:</span>
                cost_time <span>+=</span> math<span>.</span>ceil<span>(</span>pile <span>/</span> k<span>)</span>
            <span>return</span> cost_time <span>&lt;=</span> h
        <span>return</span> bisect_left<span>(</span><span>range</span><span>(</span><span>max</span><span>(</span>piles<span>)</span> <span>+</span> <span>1</span><span>)</span><span>,</span> <span>True</span><span>,</span> key<span>=</span>canEatAll<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>若使用这种方法解题，a 要包括所有的答案域，且如果使用 range，尽量使用 range(max_ans+1)的形式，若使用 range(min_ans, max_ans+1)，需要给返回的结果添加偏置 min_ans！</p>
</div>
<h2 id="在有序列表中搜索" tabindex="-1"> 在有序列表中搜索</h2>
<p>如何将 bisect 转换为一般的搜索方法：</p>
<div><pre><code><span>def</span> <span>index</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Locate the leftmost value exactly equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span> <span>and</span> a<span>[</span>i<span>]</span> <span>==</span> x<span>:</span>
        <span>return</span> i
    <span>raise</span> ValueError

<span>def</span> <span>find_lt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_le</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find rightmost value less than or equal to x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i<span>:</span>
        <span>return</span> a<span>[</span>i<span>-</span><span>1</span><span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_gt</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost value greater than x'</span>
    i <span>=</span> bisect_right<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError

<span>def</span> <span>find_ge</span><span>(</span>a<span>,</span> x<span>)</span><span>:</span>
    <span>'Find leftmost item greater than or equal to x'</span>
    i <span>=</span> bisect_left<span>(</span>a<span>,</span> x<span>)</span>
    <span>if</span> i <span>!=</span> <span>len</span><span>(</span>a<span>)</span><span>:</span>
        <span>return</span> a<span>[</span>i<span>]</span>
    <span>raise</span> ValueError
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python并发编程</title>
      <link>https://timpcfan.site/code/language/python/python-concurrent.html</link>
      <guid>https://timpcfan.site/code/language/python/python-concurrent.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python并发编程</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="多进程程序例子" tabindex="-1"> 多进程程序例子</h2>
<div><pre><code><span>import</span> argparse
<span>import</span> redis
<span>from</span> tqdm <span>import</span> tqdm
<span>from</span> multiprocessing <span>import</span> Pool<span>,</span> Process

parser <span>=</span> argparse<span>.</span>ArgumentParser<span>(</span>description<span>=</span><span>'PyTorch MM Training'</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--port'</span><span>,</span> default<span>=</span><span>6379</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"port id"</span><span>)</span>
parser<span>.</span>add_argument<span>(</span><span>'--file'</span><span>,</span> default<span>=</span><span>None</span><span>,</span> <span>type</span><span>=</span><span>str</span><span>,</span> <span>help</span><span>=</span><span>"paths for train instances"</span><span>)</span>
args <span>=</span> parser<span>.</span>parse_args<span>(</span><span>)</span>

host <span>=</span> <span>'127.0.0.1'</span>
port <span>=</span> args<span>.</span>port

<span># r = redis.Redis(host=host, port=port)</span>

train_file <span>=</span> args<span>.</span><span>file</span>

<span>def</span> <span>worker_i</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>=</span><span>16</span><span>)</span><span>:</span>
    r <span>=</span> redis<span>.</span>Redis<span>(</span>host<span>=</span>host<span>,</span> port<span>=</span>port<span>)</span>
    k <span>=</span> <span>0</span>

    <span>if</span> i <span>==</span> <span>0</span><span>:</span>
        iter_ <span>=</span> tqdm<span>(</span><span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span><span>)</span>
    <span>else</span><span>:</span>
        iter_ <span>=</span> <span>open</span><span>(</span>train_file<span>,</span> <span>'r'</span><span>)</span>

    <span>for</span> info <span>in</span> iter_<span>:</span>
        <span>if</span> k <span>%</span> nums <span>==</span> i<span>:</span> <span># 将多个任务分成nums份</span>
            r<span>.</span><span>set</span><span>(</span>k<span>,</span> info<span>.</span>strip<span>(</span><span>)</span><span>)</span>
        k <span>+=</span> <span>1</span>
process_list <span>=</span> <span>[</span><span>]</span>

nums <span>=</span> <span>8</span>
<span>for</span> i <span>in</span> <span>range</span><span>(</span>nums<span>)</span><span>:</span>
    p <span>=</span> Process<span>(</span>target<span>=</span>worker_i<span>,</span> args<span>=</span><span>(</span>train_file<span>,</span> i<span>,</span> nums<span>)</span><span>)</span>
    p<span>.</span>start<span>(</span><span>)</span>
    process_list<span>.</span>append<span>(</span>p<span>)</span>

<span>for</span> i <span>in</span> process_list<span>:</span>
    p<span>.</span>join<span>(</span><span>)</span>

<span>print</span><span>(</span><span>'写入完成'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="python-中的三种并发编程方式" tabindex="-1"> Python 中的三种并发编程方式</h2>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" alt="tch30Z" loading="lazy"></p>
<h3 id="三种方式-多线程-thread-、多进程-process-、协程-coroutine" tabindex="-1"> 三种方式：多线程（Thread）、多进程（Process）、协程（Coroutine）</h3>
<h3 id="什么是-cpu-密集型计算、io-密集型计算" tabindex="-1"> 什么是 CPU 密集型计算、IO 密集型计算</h3>
<ul>
<li>CPU 密集型计算（CPU-bound）：
<ul>
<li>例如：压缩解压缩、加密解密</li>
</ul>
</li>
<li>IO 密集型计算（I/O bound）：
<ul>
<li>爬虫、文件处理等</li>
</ul>
</li>
</ul>
<h3 id="多线程、多进程、协程的对比" tabindex="-1"> 多线程、多进程、协程的对比</h3>
<ul>
<li>多进程 Process（multiprocessing）
<ul>
<li>优点：可以利用多核 CPU 并行运算</li>
<li>缺点：占用资源最多、可启动数目比线程少</li>
<li>适用于：CPU 密集型计算</li>
</ul>
</li>
<li>多线程 Thread（threading）
<ul>
<li>优点：相比进程，更轻量级、占用资源少</li>
<li>缺点：
<ul>
<li>相比进程：多线程只能并发执行，不能利用多 CPU（GIL）</li>
<li>相比协程：启动数目有限制，占用内存资源，有线程切换开销</li>
</ul>
</li>
<li>适用于：IO 密集型计算、同时允许的任务数目要求不多</li>
</ul>
</li>
<li>协程 Coroutine（asyncio）
<ul>
<li>优点：内存开销最少、启动协程数量最多</li>
<li>缺点：支持的库有限制（aiohttp vs requests）、代码实现复杂</li>
<li>适用于：IO 密集型计算、需要超多任务运行、但有现成库支持的场景</li>
</ul>
</li>
</ul>
<h3 id="怎样根据任务选择对应技术" tabindex="-1"> 怎样根据任务选择对应技术</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/UsvTjR.png" alt="UsvTjR" loading="lazy"></p>
<h2 id="全局解释器锁-gil-global-interpreter-lock" tabindex="-1"> 全局解释器锁 GIL（Global Interpreter Lock）</h2>
<p>Python 速度慢的两大原因：</p>
<ul>
<li>动态类型语言，边解释边执行</li>
<li>GIL，无法利用多核 CPU 并发执行</li>
</ul>
<p>全局解释器锁：</p>
<ul>
<li>是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。</li>
<li>即便在多核处理器上，使用 GIL 的解释器也<strong>只能允许同一时间执行一个线</strong>程。相比并发加速的 C++/JAVA 会慢很多。</li>
<li>原因详解
<ul>
<li>为了解决多线程之间数据完整性和状态同步问题。</li>
<li>Python 中对象的管理，维护了每个对象的引用计数，在多线程时，为了保证引用计数的一致性，使用了锁的机制。</li>
</ul>
</li>
</ul>
<p>怎样规避 GIL 带来的限制：</p>
<ul>
<li>那 Python 中的线程无法同时运行，为什么还要使用多线程机制呢？多线程机制在 Python 中依然是有用的，由于<strong>IO 密集型计算</strong>，因为 IO 期间，线程会释放 GIL，实现 CPU 和 IO 的并行，因此多线程用于 IO 密集型计算依然可以大幅提升速度。</li>
<li>使用 multiprocessing 的多进程机制实现并行计算、利用多核 CPU 优势。</li>
</ul>
<h2 id="python-多线程代码" tabindex="-1"> Python 多线程代码</h2>
<h3 id="直接创建线程" tabindex="-1"> 直接创建线程</h3>
<div><pre><code><span>import</span> threading

<span>def</span> <span>craw</span><span>(</span>url<span>)</span><span>:</span>  <span># 1. 准备一个函数</span>
	r <span>=</span> requests<span>.</span>get<span>(</span>url<span>)</span>
	<span>print</span><span>(</span><span>len</span><span>(</span>r<span>.</span>text<span>)</span><span>)</span>

<span>def</span> <span>multi_thread</span><span>(</span><span>)</span><span>:</span>
	threads <span>=</span> <span>[</span><span>]</span>  <span># 2. 准备一个线程list</span>
	<span>for</span> url <span>in</span> urls<span>:</span>
		threads<span>.</span>append<span>(</span>  <span># 3. 创建线程</span>
			threading<span>.</span>Thread<span>(</span>target<span>=</span>craw<span>,</span> args<span>=</span><span>(</span>url<span>,</span><span>)</span><span>)</span>
		<span>)</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>start<span>(</span><span>)</span>  <span># 4. 启动线程</span>

	<span>for</span> thread <span>in</span> threads<span>:</span>
		thread<span>.</span>join<span>(</span><span>)</span>  <span># 5. 等待结束</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="使用线程池threadpoolexecutor" tabindex="-1"> 使用线程池<strong>ThreadPoolExecutor</strong></h3>
<p>用法 1：使用 map 函数（所有任务一起提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		result <span>=</span> pool<span>.</span><span>map</span><span>(</span>craw<span>,</span> urls<span>)</span>
		<span># map的结果和入参的顺序对应的</span>
		<span>for</span> result <span>in</span> results<span>:</span>
				<span>print</span><span>(</span>result<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用法 2：future 模式，更强大（一个任务一个任务提交）</p>
<div><pre><code><span>from</span> concurrent<span>.</span>futures <span>import</span> ThreadPoolExecutor<span>,</span> as_completed
<span>with</span> ThreadPoolExecutor<span>(</span><span>)</span> <span>as</span> pool<span>:</span>
		<span># 使用 dict 可以知道future对应的入参</span>
		futures <span>=</span> <span>{</span>pool<span>.</span>submit<span>(</span>craw<span>,</span> url<span>)</span><span>:</span> url
								<span>for</span> url <span>in</span> urls<span>}</span>
		<span># 方式1: 结果仍然按顺序</span>
		<span>for</span> future<span>,</span> url <span>in</span> futures<span>.</span>items<span>(</span><span>)</span><span>:</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>

		<span># 方式2: 使用 as_completed 顺序是不定的</span>
		<span>for</span> future <span>in</span> as_completed<span>(</span>futures<span>)</span><span>:</span>  <span># 注：字典的遍历是遍历key</span>
				url <span>=</span> futures<span>[</span>future<span>]</span>
				<span>print</span><span>(</span>url<span>,</span> future<span>.</span>result<span>(</span><span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p></p>
<h2 id="python-多进程代码" tabindex="-1"> Python 多进程代码</h2>
<p>多线程 threading 与多进程 multiprocessing 的代码对比</p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/oMERIi.png" alt="oMERIi" loading="lazy"></p>
<p>直接改个类名就能运行！</p>
<p>所以代码去看 </p>
<h3 id="多进程优雅退出" tabindex="-1"> 多进程优雅退出</h3>
<div><pre><code><span>import</span> ctypes
<span>import</span> time
<span>from</span> multiprocessing <span>import</span> Process<span>,</span> RawValue

<span>class</span> <span>CountdownTask</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running <span>=</span> RawValue<span>(</span>ctypes<span>.</span>c_bool<span>,</span> <span>True</span><span>)</span>
    <span>def</span> <span>terminate</span><span>(</span>self<span>)</span><span>:</span>
        self<span>.</span>_running<span>.</span>value <span>=</span> <span>False</span>
    <span>def</span> <span>run</span><span>(</span>self<span>,</span> n<span>)</span><span>:</span>
        <span>while</span> self<span>.</span>_running<span>.</span>value <span>and</span> n <span>></span> <span>0</span><span>:</span>
            <span>print</span><span>(</span><span>'T-minus'</span><span>,</span> n<span>)</span>
            n <span>-=</span> <span>1</span>
            time<span>.</span>sleep<span>(</span><span>5</span><span>)</span>

c <span>=</span> CountdownTask<span>(</span><span>)</span>
t <span>=</span> Process<span>(</span>target<span>=</span>c<span>.</span>run<span>,</span> args<span>=</span><span>(</span><span>10</span><span>,</span><span>)</span><span>)</span>
t<span>.</span>start<span>(</span><span>)</span>
c<span>.</span>terminate<span>(</span><span>)</span> <span># Signal termination</span>
t<span>.</span>join<span>(</span><span>)</span> <span># Wait for actual termination (if needed)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="线程池原理" tabindex="-1"> 线程池原理</h2>
<h3 id="线程池的原理" tabindex="-1"> 线程池的原理</h3>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/YPT9vT.png" alt="YPT9vT" loading="lazy"></p>
<h3 id="特点" tabindex="-1"> 特点</h3>
<ul>
<li>使用任务队列</li>
<li>可重用线程</li>
</ul>
<h3 id="优点" tabindex="-1"> 优点</h3>
<ul>
<li>提升性能：减少创建终止线程开销，重用线程资源</li>
<li>适用场景：突发性大量请求、但任务处理时间较短</li>
<li>防御功能：避免系统因为创建线程过多导致负荷过大</li>
<li>代码优势：简洁方便</li>
</ul>
<h2 id="协程的原理以及代码" tabindex="-1"> 协程的原理以及代码</h2>
<p><a href="https://www.bilibili.com/video/BV1bK411A7tV?p=11" target="_blank" rel="noopener noreferrer">【2021 最新版】Python 并发编程实战，用多线程、多进程、多协程加速程序运行_哔哩哔哩_bilibili</a></p>
<h3 id="协程的原理" tabindex="-1"> 协程的原理</h3>
<p>协程：在<strong>单线程内</strong>实现并发</p>
<ul>
<li>核心原理：用一个超级循环（其实就是 while true）循环，配合 IO 多路复用原理（IO 时 CPU 可以干其他事情）</li>
<li>于是在等待 IO 时，CPU 会同时开始计算下一个循环的 IO 前的部分，并开启多轮循环同时进行的局面</li>
<li>等待 IO 结束，CPU 将剩余部分的代码再一并执行</li>
</ul>
<p><strong>单线程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/dFUEmJ.png" alt="dFUEmJ" loading="lazy"></p>
<p><strong>协程爬虫执行路径</strong></p>
<p><img src="http://timpcfan-site.cdn.bcebos.com/imgs/OSigeS.png" alt="OSigeS" loading="lazy"></p>
<h3 id="协程的使用以及异步-io" tabindex="-1"> 协程的使用以及异步 IO</h3>
<div><pre><code><span>import</span> asyncio

<span># 获取事件循环（超级循环）</span>
loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>

<span># 定义协程</span>
<span>async</span> <span>def</span> <span>myfunc</span><span>(</span>url<span>)</span><span>:</span>
		<span>await</span> get_url<span>(</span>url<span>)</span>

<span># 创建task列表</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>myfunc<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>

<span># 执行爬虫事件列表</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>关键字<strong>async</strong>：表示定义一个协程。</p>
<p>关键字<strong>await</strong>：表示后面的函数是一个异步 IO，并且不进行阻塞，而是直接在超级循环直接进入下一个任务的执行（当前任务放弃 CPU，下一个任务获得 CPU）。</p>
<div><p>注意</p>
<p>异步 IO 中依赖的库必须支持异步 IO 特性（这要求库在 IO 时不能阻塞，否则切换不到下一个任务了）</p>
</div>
<div><p>注意</p>
<p>requests 库不支持异步 IO，需要使用 aiohttp 库</p>
</div>
<p>例子：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
				<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
						result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
						<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所有的异步对象也需要使用 async 关键字来标注。</p>
<div><p>相关信息</p>
<p>协程与普通函数运行的不同点在于协程需要使用超级循环来进行调度。</p>
</div>
<h3 id="协程并发度的控制" tabindex="-1"> 协程并发度的控制</h3>
<p>可以使用  来进行控制：</p>
<div><pre><code><span>import</span> asyncio<span>,</span> aiohtttp

semaphore <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>
<span>async</span> <span>def</span> <span>async_craw</span><span>(</span>url<span>)</span><span>:</span>
		<span>async</span> <span>with</span> semaphore<span>:</span>  <span># here</span>
				<span>async</span> <span>with</span> aiohttp<span>.</span>ClientSession<span>(</span><span>)</span> <span>as</span> sess<span>:</span>
						<span>async</span> <span>with</span> sess<span>.</span>get<span>(</span>url<span>)</span> <span>as</span> resp<span>:</span>
								result <span>=</span> <span>await</span> resp<span>.</span>text<span>(</span><span>)</span>
								<span>print</span><span>(</span>url<span>,</span> <span>len</span><span>(</span>result<span>)</span><span>)</span>

loop <span>=</span> asyncio<span>.</span>get_event_loop<span>(</span><span>)</span>
tasks <span>=</span> <span>[</span>loop<span>.</span>create_task<span>(</span>async_craw<span>(</span>url<span>)</span><span>)</span>
					<span>for</span> url <span>in</span> urls<span>]</span>
loop<span>.</span>run_until_complete<span>(</span>asyncio<span>.</span>wait<span>(</span>tasks<span>)</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="信号量-semaphore" tabindex="-1"> 信号量 Semaphore</h2>
<div><p>相关信息</p>
<p>信号量一般用于访问有限数量的共享资源。</p>
</div>
<p>信号量是一个<strong>同步对象</strong>，用于保持在 0 至指定最大值之间的一个计数器。</p>
<ul>
<li>当线程完成一次对改 semaphore 对象的等待（wait）时，该计数器减一</li>
<li>当线程完成一次对改 semaphore 对象的释放（release）时，该计数器加一</li>
<li>当计数器为 0 时，线程等待该 semaphore 对象不再能成功直到该 semaphore 对象变成 signaled 状态（阻塞）
<ul>
<li>计数器大于 0，为 signaled 状态</li>
<li>计数器等于 0，为 nonsignaled 状态</li>
</ul>
</li>
</ul>
<div><pre><code><span># 方法一：使用with</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>async</span> <span>with</span> sem<span>:</span>
		<span># work with shared resource</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># 方法二：手动acquire、release</span>
sem <span>=</span> asyncio<span>.</span>Semaphore<span>(</span><span>10</span><span>)</span>

<span># ...later</span>
<span>await</span> sem<span>.</span>acquire<span>(</span><span>)</span>
<span>try</span><span>:</span>
		<span># work with shared resource</span>
<span>finally</span><span>:</span>
		sem<span>.</span>release<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="http://timpcfan-site.cdn.bcebos.com/imgs/tch30Z.png" type="image/png"/>
    </item>
    <item>
      <title>Python常用数据结构</title>
      <link>https://timpcfan.site/code/language/python/python-data-structures.html</link>
      <guid>https://timpcfan.site/code/language/python/python-data-structures.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python常用数据结构</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="列表-list" tabindex="-1"> 列表 list</h2>
<h3 id="列表方法" tabindex="-1"> 列表方法</h3>
<ul>
<li>list.append(obj)</li>
<li>list.count(obj)</li>
<li>list.extend(seq)</li>
<li>list.index(obj)</li>
<li>list.insert(index, obj)</li>
<li>list.pop([index=-1])</li>
<li>list.remove(obj)</li>
<li>list.reverse()</li>
<li>list.sort(cmp=None, key=None, reverse=False)</li>
</ul>
<h3 id="列表脚本操作符" tabindex="-1"> 列表脚本操作符</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td>3</td>
<td>长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td>[1, 2, 3, 4, 5, 6]</td>
<td>组合</td>
</tr>
<tr>
<td>['Hi!'] * 4</td>
<td>['Hi!', 'Hi!', 'Hi!', 'Hi!']</td>
<td>重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td>True</td>
<td>元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td>1 2 3</td>
<td>迭代</td>
</tr>
</tbody>
</table>
<h3 id="列表截取" tabindex="-1"> 列表截取</h3>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td>'Taobao'</td>
<td>读取列表中第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td>'Runoob'</td>
<td>读取列表中倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td>['Runoob', 'Taobao']</td>
<td>从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<h2 id="双向队列-deque" tabindex="-1"> 双向队列 deque</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>deque<span>(</span><span>[</span>iterable<span>[</span><span>,</span> maxlen<span>]</span><span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>注意</p>
<p>若当作一个<strong>单向队列</strong>，append(x) 与 popleft() 才是一对。。。</p>
<ul>
<li>若当作一个<strong>栈</strong>，append(x)与 pop()就是一对</li>
</ul>
</div>
<h3 id="方法" tabindex="-1"> 方法</h3>
<ul>
<li>append(x) 添加到右侧</li>
<li>appendleft(x) 添加到左侧</li>
<li>pop() 从右侧出队</li>
<li>popleft() 从左侧出队</li>
<li>clear()</li>
<li>copy()</li>
<li>count(x)</li>
<li>extend(iter)</li>
<li>extendleft(iter)</li>
<li>index(x[, start[, stop]])</li>
<li>insert(i, x)</li>
<li>remove(x) 删除从左到右的第一个 x</li>
<li>reverse()</li>
<li>rotate(n=1)</li>
<li>maxlen</li>
</ul>
<h3 id="recipes" tabindex="-1"> Recipes</h3>
<h4 id="_1-用于实现-tail-程序" tabindex="-1"> 1. 用于实现 tail 程序</h4>
<div><pre><code><span>def</span> <span>tail</span><span>(</span>filename<span>,</span> n<span>=</span><span>10</span><span>)</span><span>:</span>
    <span>'Return the last n lines of a file'</span>
    <span>with</span> <span>open</span><span>(</span>filename<span>)</span> <span>as</span> f<span>:</span>
        <span>return</span> deque<span>(</span>f<span>,</span> n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>设置 maxlen=n，可以实现保留文本最后 n 行的功能。</p>
<h4 id="_2-用于维持一个定长的近期添加元素序列" tabindex="-1"> 2. 用于维持一个定长的近期添加元素序列</h4>
<div><pre><code><span>def</span> <span>moving_average</span><span>(</span>iterable<span>,</span> n<span>=</span><span>3</span><span>)</span><span>:</span>
    <span># moving_average([40, 30, 50, 46, 39, 44]) --> 40.0 42.0 45.0 43.0</span>
    <span># http://en.wikipedia.org/wiki/Moving_average</span>
    it <span>=</span> <span>iter</span><span>(</span>iterable<span>)</span>
    d <span>=</span> deque<span>(</span>itertools<span>.</span>islice<span>(</span>it<span>,</span> n<span>-</span><span>1</span><span>)</span><span>)</span>
    d<span>.</span>appendleft<span>(</span><span>0</span><span>)</span>
    s <span>=</span> <span>sum</span><span>(</span>d<span>)</span>
    <span>for</span> elem <span>in</span> it<span>:</span>
        s <span>+=</span> elem <span>-</span> d<span>.</span>popleft<span>(</span><span>)</span>
        d<span>.</span>append<span>(</span>elem<span>)</span>
        <span>yield</span> s <span>/</span> n
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_3-实现一个-round-robin-scheduler" tabindex="-1"> 3. 实现一个 round-robin scheduler</h4>
<div><pre><code><span>def</span> <span>roundrobin</span><span>(</span><span>*</span>iterables<span>)</span><span>:</span>
    <span>"roundrobin('ABC', 'D', 'EF') --> A D E B F C"</span>
    iterators <span>=</span> deque<span>(</span><span>map</span><span>(</span><span>iter</span><span>,</span> iterables<span>)</span><span>)</span>
    <span>while</span> iterators<span>:</span>
        <span>try</span><span>:</span>
            <span>while</span> <span>True</span><span>:</span>
                <span>yield</span> <span>next</span><span>(</span>iterators<span>[</span><span>0</span><span>]</span><span>)</span>
                iterators<span>.</span>rotate<span>(</span><span>-</span><span>1</span><span>)</span>
        <span>except</span> StopIteration<span>:</span>
            <span># Remove an exhausted iterator.</span>
            iterators<span>.</span>popleft<span>(</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h4 id="_4-删除第-n-个元素" tabindex="-1"> 4. 删除第 n 个元素</h4>
<p>可以使用 rotate(n)来轻松删除第 n 个元素</p>
<div><pre><code><span>def</span> <span>delete_nth</span><span>(</span>d<span>,</span> n<span>)</span><span>:</span>
    d<span>.</span>rotate<span>(</span><span>-</span>n<span>)</span>
    d<span>.</span>popleft<span>(</span><span>)</span>
    d<span>.</span>rotate<span>(</span>n<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="最小堆-heapq" tabindex="-1"> 最小堆 heapq</h2>
<p><strong>函 数</strong>                                                        <strong>描 述</strong></p>
<p>heappush(heap, x)                                将 x 压入堆中</p>
<p>heappop(heap)                                      从堆中弹出最小的元素</p>
<p>heapify(heap)                                         让列表具备堆特征</p>
<p>heapreplace(heap, x)                            弹出最小的元素，并将 x 压入堆中</p>
<p>nlargest(n, iter, key=None)                                      返回 iter 中 n 个最大的元素</p>
<p>nsmallest(n, iter, key=None)                                   返回 iter 中 n 个最小的元素</p>
<p>merge(*iters, key=None, reverse=False) 合并多个有序列表形成单独一个有序列表</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> heapq <span>import</span> <span>*</span>
<span>>></span><span>></span> <span>from</span> random <span>import</span> shuffle
<span>>></span><span>></span> data <span>=</span> <span>list</span><span>(</span><span>range</span><span>(</span><span>10</span><span>)</span><span>)</span>
<span>>></span><span>></span> shuffle<span>(</span>data<span>)</span>
<span>>></span><span>></span> heap <span>=</span> <span>[</span><span>]</span>
<span>>></span><span>></span> <span>for</span> n <span>in</span> data<span>:</span>
<span>.</span><span>.</span><span>.</span> heappush<span>(</span>heap<span>,</span> n<span>)</span>
<span>.</span><span>.</span><span>.</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>]</span>
<span>>></span><span>></span> heappush<span>(</span>heap<span>,</span> <span>0.5</span><span>)</span>
<span>>></span><span>></span> heap
<span>[</span><span>0</span><span>,</span> <span>0.5</span><span>,</span> <span>3</span><span>,</span> <span>6</span><span>,</span> <span>1</span><span>,</span> <span>8</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>9</span><span>,</span> <span>5</span><span>,</span> <span>2</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="python-如何实现最大堆" tabindex="-1"> <strong>python 如何实现最大堆？</strong></h3>
<div><pre><code><span># 最简单的方案就是，给你的堆的元素加一个值，使值逆序排列。以下是示例代码。</span>
<span>import</span> heapq
sss <span>=</span> <span>'abecgfidhjk'</span>
ll <span>=</span> <span>list</span><span>(</span>sss<span>)</span>
heapq<span>.</span>heapify<span>(</span>ll<span>)</span>
<span>print</span><span>(</span>ll<span>)</span>
<span># ['a', 'b', 'e', 'c', 'g', 'f', 'i', 'd', 'h', 'j', 'k']</span>
<span># 此时若想得到大顶堆</span>
newl <span>=</span> <span>[</span><span>(</span><span>-</span>i<span>,</span> ll<span>[</span>i<span>]</span><span>)</span> <span>for</span> i <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span>ll<span>)</span><span>)</span><span>]</span>
<span>#print(newl)</span>
heapq<span>.</span>heapify<span>(</span>newl<span>)</span>
<span># 此时已经按照第一个值变成了小顶堆，即变成了逆序</span>
max_heap <span>=</span> <span>list</span><span>(</span><span>)</span>
<span>while</span> newl<span>:</span>
    _<span>,</span> s <span>=</span> heapq<span>.</span>heappop<span>(</span>newl<span>)</span>
    max_heap<span>.</span>append<span>(</span>s<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="计数器-counter" tabindex="-1"> 计数器 Counter</h2>
<div><pre><code><span>class</span> <span>collections</span><span>.</span>Counter<span>(</span><span>[</span>iterable<span>-</span><span>or</span><span>-</span>mapping<span>]</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Counter 是一个 dict 的子类，存着每个元素出现的次数，若访问不存在的元素会返回 0。</p>
<div><pre><code>c <span>=</span> Counter<span>(</span><span>)</span>                           <span># a new, empty counter</span>
c <span>=</span> Counter<span>(</span><span>'gallahad'</span><span>)</span>                 <span># a new counter from an iterable</span>
c <span>=</span> Counter<span>(</span><span>{</span><span>'red'</span><span>:</span> <span>4</span><span>,</span> <span>'blue'</span><span>:</span> <span>2</span><span>}</span><span>)</span>      <span># a new counter from a mapping</span>
c <span>=</span> Counter<span>(</span>cats<span>=</span><span>4</span><span>,</span> dogs<span>=</span><span>8</span><span>)</span>             <span># a new counter from keyword args</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>直接以字典的方式去访问 Counter</p>
<div><pre><code>c<span>[</span><span>'cats'</span><span>]</span>         <span># return 4</span>
c<span>[</span><span>'cats'</span><span>]</span> <span>+=</span> <span>1</span>    <span># add one more cat</span>
c<span>[</span><span>'pigs'</span><span>]</span>         <span># missing value will return 0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>elements()</strong> 返回一个 iterator 根据每个元素的数量来访问所有元素（会忽略数量为 0 或负的元素）</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>c<span>.</span>elements<span>(</span><span>)</span><span>)</span>
<span>[</span><span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'b'</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>*<strong>*most_common**</strong>([<em>n</em>]) 返回一个 tuple 列表，包含按元素数量排序的最常见的元素列表</p>
<div><pre><code><span>>></span><span>></span> Counter<span>(</span><span>'abracadabra'</span><span>)</span><span>.</span>most_common<span>(</span><span>3</span><span>)</span>
<span>[</span><span>(</span><span>'a'</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>(</span><span>'b'</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>(</span><span>'r'</span><span>,</span> <span>2</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>*<strong>*subtract**</strong>([<em>iterable-or-mapping</em>]) 两个 Counter 可以相减</p>
<div><pre><code><span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>4</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>0</span><span>,</span> d<span>=</span><span>-</span><span>2</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>,</span> c<span>=</span><span>3</span><span>,</span> d<span>=</span><span>4</span><span>)</span>
<span>>></span><span>></span> c<span>.</span>subtract<span>(</span>d<span>)</span>
<span>>></span><span>></span> c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>0</span><span>,</span> <span>'c'</span><span>:</span> <span>-</span><span>3</span><span>,</span> <span>'d'</span><span>:</span> <span>-</span><span>6</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>*<strong>*fromkeys**</strong>(<em>iterable</em>) 没有对 Counter 实现该方法（dict 的类方法，用于根据 dict 的键生成一个新的 dict）</p>
<p>*<strong>*update**</strong>([<em>iterable-or-mapping</em>]) 与 dict 的 update 一样</p>
<p>其他的一些操作：</p>
<div><pre><code><span>sum</span><span>(</span>c<span>.</span>values<span>(</span><span>)</span><span>)</span>                 <span># total of all counts</span>
c<span>.</span>clear<span>(</span><span>)</span>                       <span># reset all counts</span>
<span>list</span><span>(</span>c<span>)</span>                         <span># list unique elements</span>
<span>set</span><span>(</span>c<span>)</span>                          <span># convert to a set</span>
<span>dict</span><span>(</span>c<span>)</span>                         <span># convert to a regular dictionary</span>
c<span>.</span>items<span>(</span><span>)</span>                       <span># convert to a list of (elem, cnt) pairs</span>
Counter<span>(</span><span>dict</span><span>(</span>list_of_pairs<span>)</span><span>)</span>    <span># convert from a list of (elem, cnt) pairs</span>
c<span>.</span>most_common<span>(</span><span>)</span><span>[</span><span>:</span><span>-</span>n<span>-</span><span>1</span><span>:</span><span>-</span><span>1</span><span>]</span>       <span># n least common elements</span>
<span>+</span>c                              <span># remove zero and negative counts</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>3</span><span>,</span> b<span>=</span><span>1</span><span>)</span>
<span>>></span><span>></span> d <span>=</span> Counter<span>(</span>a<span>=</span><span>1</span><span>,</span> b<span>=</span><span>2</span><span>)</span>
<span>>></span><span>></span> c <span>+</span> d                       <span># add two counters together:  c[x] + d[x]</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>4</span><span>,</span> <span>'b'</span><span>:</span> <span>3</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>-</span> d                       <span># subtract (keeping only positive counts)</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>&amp;</span> d                       <span># intersection:  min(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>1</span><span>,</span> <span>'b'</span><span>:</span> <span>1</span><span>}</span><span>)</span>
<span>>></span><span>></span> c <span>|</span> d                       <span># union:  max(c[x], d[x])</span>
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>3</span><span>,</span> <span>'b'</span><span>:</span> <span>2</span><span>}</span><span>)</span>

<span>>></span><span>></span> c <span>=</span> Counter<span>(</span>a<span>=</span><span>2</span><span>,</span> b<span>=</span><span>-</span><span>4</span><span>)</span>
<span>>></span><span>></span> <span>+</span>c
Counter<span>(</span><span>{</span><span>'a'</span><span>:</span> <span>2</span><span>}</span><span>)</span>
<span>>></span><span>></span> <span>-</span>c
Counter<span>(</span><span>{</span><span>'b'</span><span>:</span> <span>4</span><span>}</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="随机队列-randomizedqueue" tabindex="-1"> 随机队列 RandomizedQueue</h2>
<div><p>相关信息</p>
<p>自创数据结构，在工作中使用</p>
</div>
<div><pre><code><span>class</span> <span>RandomizedQueue</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> _iter<span>=</span><span>[</span><span>]</span><span>)</span><span>:</span>
        self<span>.</span>arr <span>=</span> <span>[</span><span>*</span>_iter<span>]</span>
    <span>def</span> <span>append</span><span>(</span>self<span>,</span> val<span>)</span><span>:</span>
        self<span>.</span>arr<span>.</span>append<span>(</span>val<span>)</span>
    <span>def</span> <span>remove</span><span>(</span>self<span>,</span> idx<span>)</span><span>:</span>
        <span>if</span> idx <span>>=</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>:</span>
            <span>return</span>
        r <span>=</span> self<span>.</span>arr<span>[</span>idx<span>]</span>
        self<span>.</span>arr<span>[</span>idx<span>]</span> <span>=</span> self<span>.</span>arr<span>[</span><span>-</span><span>1</span><span>]</span>  <span># 将最后一个元素移动到删除的元素位置</span>
        self<span>.</span>arr<span>.</span>pop<span>(</span><span>)</span>
        <span>return</span> r
    <span>def</span> <span>getRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        <span>return</span> self<span>.</span>arr<span>[</span><span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span><span>]</span>
    <span>def</span> <span>popRandom</span><span>(</span>self<span>)</span><span>:</span>
        <span>if</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span> <span>==</span> <span>0</span><span>:</span>
            <span>return</span>
        idx <span>=</span> <span>int</span><span>(</span>random<span>.</span>random<span>(</span><span>)</span> <span>*</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span><span>)</span>
        <span>return</span> self<span>.</span>remove<span>(</span>idx<span>)</span>
    <span>def</span> <span>__len__</span><span>(</span>self<span>)</span><span>:</span>
        <span>return</span> <span>len</span><span>(</span>self<span>.</span>arr<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li>入队：O(1)</li>
<li>获取随机元素：O(1)</li>
<li>随机出队：O(1)</li>
<li>删除指定位置的元素：O(1)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Python日志 - logging</title>
      <link>https://timpcfan.site/code/language/python/python-log.html</link>
      <guid>https://timpcfan.site/code/language/python/python-log.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python日志 - logging</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<div><pre><code><span>import</span> logging  <span># 引入logging模块</span>
<span>import</span> os<span>.</span>path
<span>import</span> time
<span># 第一步，创建一个logger</span>
logger <span>=</span> logging<span>.</span>getLogger<span>(</span><span>)</span>
logger<span>.</span>setLevel<span>(</span>logging<span>.</span>INFO<span>)</span>  <span># Log等级总开关</span>
<span># 第二步，创建一个handler，用于写入日志文件</span>
rq <span>=</span> time<span>.</span>strftime<span>(</span><span>'%Y%m%d%H%M'</span><span>,</span> time<span>.</span>localtime<span>(</span>time<span>.</span>time<span>(</span><span>)</span><span>)</span><span>)</span>
log_path <span>=</span> os<span>.</span>path<span>.</span>dirname<span>(</span>os<span>.</span>getcwd<span>(</span><span>)</span><span>)</span> <span>+</span> <span>'/Logs/'</span>
log_name <span>=</span> log_path <span>+</span> rq <span>+</span> <span>'.log'</span>
logfile <span>=</span> log_name
fh <span>=</span> logging<span>.</span>FileHandler<span>(</span>logfile<span>,</span> mode<span>=</span><span>'w'</span><span>)</span>
fh<span>.</span>setLevel<span>(</span>logging<span>.</span>DEBUG<span>)</span>  <span># 输出到file的log等级的开关</span>
<span># 第三步，定义handler的输出格式</span>
formatter <span>=</span> logging<span>.</span>Formatter<span>(</span><span>"%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s"</span><span>)</span>
fh<span>.</span>setFormatter<span>(</span>formatter<span>)</span>
<span># 第四步，将logger添加到handler里面</span>
logger<span>.</span>addHandler<span>(</span>fh<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>记录日志：</p>
<div><pre><code><span># 日志</span>
logger<span>.</span>debug<span>(</span><span>'this is a logger debug message'</span><span>)</span>
logger<span>.</span>info<span>(</span><span>'this is a logger info message'</span><span>)</span>
logger<span>.</span>warning<span>(</span><span>'this is a logger warning message'</span><span>)</span>
logger<span>.</span>error<span>(</span><span>'this is a logger error message'</span><span>)</span>
logger<span>.</span>critical<span>(</span><span>'this is a logger critical message'</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python字符数字之间的转换函数</title>
      <link>https://timpcfan.site/code/language/python/python-ordchr.html</link>
      <guid>https://timpcfan.site/code/language/python/python-ordchr.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python字符数字之间的转换函数</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x [,base ])</td>
<td>将 x 转换为一个整数</td>
</tr>
<tr>
<td>long(x [,base ])</td>
<td>将 x 转换为一个长整数</td>
</tr>
<tr>
<td>float(x )</td>
<td>将 x 转换到一个浮点数</td>
</tr>
<tr>
<td>complex(real [,imag ])</td>
<td>创建一个复数</td>
</tr>
<tr>
<td>str(x )</td>
<td>将对象  x  转换为字符串</td>
</tr>
<tr>
<td>repr(x )</td>
<td>将对象  x  转换为表达式字符串</td>
</tr>
<tr>
<td>eval(str )</td>
<td>用来计算在字符串中的有效 Python 表达式,并返回一个对象</td>
</tr>
<tr>
<td>tuple(s )</td>
<td>将序列  s  转换为一个元组</td>
</tr>
<tr>
<td>list(s )</td>
<td>将序列  s  转换为一个列表</td>
</tr>
<tr>
<td>chr(x )</td>
<td>将一个整数转换为一个字符</td>
</tr>
<tr>
<td>unichr(x )</td>
<td>将一个整数转换为 Unicode 字符</td>
</tr>
<tr>
<td>bin(x)</td>
<td>将数字转换为二进制字符串</td>
</tr>
</tbody>
</table>
<div><pre><code><span>chr</span><span>(</span><span>65</span><span>)</span> <span>=</span> <span>'A'</span>
<span>ord</span><span>(</span><span>'A'</span><span>)</span> <span>=</span> <span>65</span>

<span>int</span><span>(</span><span>'2'</span><span>)</span> <span>=</span> <span>2</span>
<span>str</span><span>(</span><span>2</span><span>)</span> <span>=</span> <span>'2'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Python排序 - sort</title>
      <link>https://timpcfan.site/code/language/python/python-sort.html</link>
      <guid>https://timpcfan.site/code/language/python/python-sort.html</guid>
      <source url="https://timpcfan.site/rss.xml">Python排序 - sort</source>
      <category>笔记</category>
      <category>API</category>
      <pubDate>Sun, 02 Oct 2022 16:52:25 GMT</pubDate>
      <content:encoded><![CDATA[<p>原文链接：<a href="https://docs.python.org/zh-cn/3.6/howto/sorting.html" target="_blank" rel="noopener noreferrer">Sorting HOW TO - Python 3.10.4 documentation</a></p>
<p>Python 列表内置的 list.sort()方法可以直接修改列表。另外 sorted()内置函数，可以传入迭代对象构建一个新的排序列表。</p>
<hr>
<p><strong><code>sorted</code></strong>(<em>iterable</em>, ***, <em>key=None</em>, *reverse=False*)</p>
<p>根据  <em>iterable</em>  中的项返回一个新的已排序列表。
具有两个可选参数，它们都必须指定为关键字参数。
<em>key</em>  指定带有单个参数的函数，用于从  <em>iterable</em>  的每个元素中提取用于比较的键 (例如  <code>key=str.lower</code>)。 默认值为  <code>None</code> (直接比较元素)。
<em>reverse</em>  为一个布尔值。 如果设为  <code>True</code>，则每个列表元素将按反向顺序比较进行排序。
使用  <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener noreferrer">functools.cmp_to_key()</a>  可将老式的  <em>cmp</em>  函数转换为  <em>key</em>  函数。
内置的  <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#sorted" target="_blank" rel="noopener noreferrer">sorted()</a>  确保是稳定的。 如果一个排序确保不会改变比较结果相等的元素的相对顺序就称其为稳定的 — 这有利于进行多重排序（例如先按部门、再按薪级排序）。</p>
<hr>
<h2 id="基本排序" tabindex="-1"> 基本排序</h2>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>]</span><span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>

<span>>></span><span>></span> a <span>=</span> <span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>1</span><span>,</span> <span>4</span><span>]</span>
<span>>></span><span>></span> a<span>.</span>sort<span>(</span><span>)</span>
<span>>></span><span>></span> a
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="key-函数" tabindex="-1"> key 函数</h2>
<p>可以使用一个函数来指定排序使用的键</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>"This is a test string from Andrew"</span><span>.</span>split<span>(</span><span>)</span><span>,</span> key<span>=</span><span>str</span><span>.</span>lower<span>)</span>
<span>[</span><span>'a'</span><span>,</span> <span>'Andrew'</span><span>,</span> <span>'from'</span><span>,</span> <span>'is'</span><span>,</span> <span>'string'</span><span>,</span> <span>'test'</span><span>,</span> <span>'This'</span><span>]</span>

<span>>></span><span>></span> student_tuples <span>=</span> <span>[</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span>     <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span>
<span>.</span><span>.</span><span>.</span> <span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span><span>lambda</span> student<span>:</span> student<span>[</span><span>2</span><span>]</span><span>)</span>   <span># sort by age</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="operator-模块函数" tabindex="-1"> Operator 模块函数</h2>
<p>上面显示的键函数模式非常常见，因此 Python 提供了便利功能，使访问器功能更容易，更快捷。  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#module-operator" target="_blank" rel="noopener noreferrer">operator</a>  模块有  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.itemgetter" target="_blank" rel="noopener noreferrer">itemgetter()</a> 、 <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.attrgetter" target="_blank" rel="noopener noreferrer">attrgetter()</a>  和  <a href="https://docs.python.org/zh-cn/3.6/library/operator.html#operator.methodcaller" target="_blank" rel="noopener noreferrer">methodcaller()</a>  函数。</p>
<div><pre><code><span>>></span><span>></span> <span>from</span> operator <span>import</span> itemgetter<span>,</span> attrgetter

<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>2</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'age'</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>

<span># 也支持多级排序！</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>]</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'grade'</span><span>,</span> <span>'age'</span><span>)</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="升序和降序" tabindex="-1"> <strong>升序和降序</strong></h2>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span>student_tuples<span>,</span> key<span>=</span>itemgetter<span>(</span><span>2</span><span>)</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="排序稳定性和排序复杂度" tabindex="-1"> <strong>排序稳定性和排序复杂度</strong></h2>
<p>排序保证是  <strong><a href="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability" target="_blank" rel="noopener noreferrer">稳定</a></strong> 的。 这意味着当多个记录具有相同的键值时，将保留其原始顺序。</p>
<p>注意  <em>blue</em>  的两个记录如何保留它们的原始顺序，以便  <code>('blue', 1)</code>  保证在  <code>('blue', 2)</code>  之前。</p>
<p>这个美妙的属性允许你在一系列排序步骤中构建复杂的排序。例如，要按  <em>grade</em>  降序然后  <em>age</em>  升序对学生数据进行排序，请先  <em>age</em>  排序，然后再使用  <em>grade</em>  排序：</p>
<div><pre><code><span>>></span><span>></span> s <span>=</span> <span>sorted</span><span>(</span>student_objects<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'age'</span><span>)</span><span>)</span>     <span># sort on secondary key</span>
<span>>></span><span>></span> <span>sorted</span><span>(</span>s<span>,</span> key<span>=</span>attrgetter<span>(</span><span>'grade'</span><span>)</span><span>,</span> reverse<span>=</span><span>True</span><span>)</span>       <span># now sort on primary key, descending</span>
<span>[</span><span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>Python 中使用的  <a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener noreferrer">Timsort</a>  算法可以有效地进行多种排序，因为它可以利用数据集中已存在的任何排序。</p>
<h2 id="使用装饰-排序-去装饰的旧方法" tabindex="-1"> <strong>使用装饰-排序-去装饰的旧方法</strong></h2>
<p>这个三个步骤被称为 Decorate-Sort-Undecorate ：</p>
<ul>
<li>首先，初始列表使用控制排序顺序的新值进行修饰。</li>
<li>然后，装饰列表已排序。</li>
<li>最后，删除装饰，创建一个仅包含新排序中初始值的列表。</li>
</ul>
<p>例如，要使用 DSU 方法按  <em>grade</em>  对学生数据进行排序：</p>
<div><pre><code><span>>></span><span>></span> decorated <span>=</span> <span>[</span><span>(</span>student<span>.</span>grade<span>,</span> i<span>,</span> student<span>)</span> <span>for</span> i<span>,</span> student <span>in</span> <span>enumerate</span><span>(</span>student_objects<span>)</span><span>]</span>
<span>>></span><span>></span> decorated<span>.</span>sort<span>(</span><span>)</span>
<span>>></span><span>></span> <span>[</span>student <span>for</span> grade<span>,</span> i<span>,</span> student <span>in</span> decorated<span>]</span>               <span># undecorate</span>
<span>[</span><span>(</span><span>'john'</span><span>,</span> <span>'A'</span><span>,</span> <span>15</span><span>)</span><span>,</span> <span>(</span><span>'jane'</span><span>,</span> <span>'B'</span><span>,</span> <span>12</span><span>)</span><span>,</span> <span>(</span><span>'dave'</span><span>,</span> <span>'B'</span><span>,</span> <span>10</span><span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这方法语有效是因为元组按字典顺序进行比较，先比较第一项；如果它们相同则比较第二个项目，依此类推。</p>
<p>不一定在所有情况下都要在装饰列表中包含索引  <em>i</em> ，但包含它有两个好处：</p>
<ul>
<li>排序是稳定的——如果两个项具有相同的键，它们的顺序将保留在排序列表中。</li>
<li>原始项目不必具有可比性，因为装饰元组的排序最多由前两项决定。 因此，例如原始列表可能包含无法直接排序的复数。</li>
</ul>
<p>这个方法的另一个名字是 Randal L. Schwartz 在 Perl 程序员中推广的  <a href="https://en.wikipedia.org/wiki/Schwartzian_transform" target="_blank" rel="noopener noreferrer">Schwartzian transform</a>。</p>
<p>既然 Python 排序提供了键函数，那么通常不需要这种技术。</p>
<h2 id="使用-cmp-参数的旧方法" tabindex="-1"> 使用 cmp 参数的旧方法</h2>
<p>本 HOWTO 中给出的许多结构都假定为 Python 2.4 或更高版本。在此之前，没有内置  <a href="https://docs.python.org/zh-cn/3.6/library/functions.html#sorted" target="_blank" rel="noopener noreferrer">sorted()</a> ， <a href="https://docs.python.org/zh-cn/3.6/library/stdtypes.html#list.sort" target="_blank" rel="noopener noreferrer">list.sort()</a>  也没有关键字参数。相反，所有 Py2.x 版本都支持  <em>cmp</em>  参数来处理用户指定的比较函数。</p>
<p>在 Py3.0 中， <em>cmp</em>  参数被完全删除（作为简化和统一语言努力的一部分，消除了丰富的比较与  <code>__cmp__()</code>  魔术方法之间的冲突）。</p>
<p>在 Py2.x 中， sort 允许一个可选函数，可以调用它来进行比较。该函数应该采用两个参数进行比较，然后返回负值为小于，如果它们相等则返回零，或者返回大于大于的正值。例如，我们可以这样做：</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>numeric_compare</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> x <span>-</span> y
<span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>cmp</span><span>=</span>numeric_compare<span>)</span>
<span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>或者你可反转比较的顺序：</p>
<div><pre><code><span>>></span><span>></span> <span>def</span> <span>reverse_numeric</span><span>(</span>x<span>,</span> y<span>)</span><span>:</span>
<span>.</span><span>.</span><span>.</span>     <span>return</span> y <span>-</span> x
<span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> <span>cmp</span><span>=</span>reverse_numeric<span>)</span>
<span>[</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>将代码从 Python 2.x 移植到 3.x 时，如果用户提供比较功能并且需要将其转换为键函数，则会出现这种情况。 以下包装器使这很容易：</p>
<div><pre><code><span>def</span> <span>cmp_to_key</span><span>(</span>mycmp<span>)</span><span>:</span>
    <span>'Convert a cmp= function into a key= function'</span>
    <span>class</span> <span>K</span><span>:</span>
        <span>def</span> <span>__init__</span><span>(</span>self<span>,</span> obj<span>,</span> <span>*</span>args<span>)</span><span>:</span>
            self<span>.</span>obj <span>=</span> obj
        <span>def</span> <span>__lt__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>&lt;</span> <span>0</span>
        <span>def</span> <span>__gt__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>></span> <span>0</span>
        <span>def</span> <span>__eq__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>==</span> <span>0</span>
        <span>def</span> <span>__le__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>&lt;=</span> <span>0</span>
        <span>def</span> <span>__ge__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>>=</span> <span>0</span>
        <span>def</span> <span>__ne__</span><span>(</span>self<span>,</span> other<span>)</span><span>:</span>
            <span>return</span> mycmp<span>(</span>self<span>.</span>obj<span>,</span> other<span>.</span>obj<span>)</span> <span>!=</span> <span>0</span>
    <span>return</span> K
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>要转换为键函数，只需包装旧的比较函数：</p>
<div><pre><code><span>>></span><span>></span> <span>sorted</span><span>(</span><span>[</span><span>5</span><span>,</span> <span>2</span><span>,</span> <span>4</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>]</span><span>,</span> key<span>=</span>cmp_to_key<span>(</span>reverse_numeric<span>)</span><span>)</span>
<span>[</span><span>5</span><span>,</span> <span>4</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>,</span> <span>1</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>在 Python 3.2 中， <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#functools.cmp_to_key" target="_blank" rel="noopener noreferrer">functools.cmp_to_key()</a>  函数被添加到标准库中的  <a href="https://docs.python.org/zh-cn/3.6/library/functools.html#module-functools" target="_blank" rel="noopener noreferrer">functools</a>  模块中。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>